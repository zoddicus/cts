{"version":3,"file":"texture.js","names":["assert","isDepthOrStencilTextureFormat","kTextureFormatInfo","getTextureCopyLayout","reifyExtent3D","reifyOrigin3D","kLoadValueFromStorageInfo","r8unorm","storageType","texelType","unpackWGSL","r8uint","r8sint","rg8unorm","rg8uint","rg8sint","rgba8unorm","bgra8unorm","rgba8uint","rgba8sint","r16float","r16uint","r16sint","rg16float","rg16uint","rg16sint","rgba16float","rgba16uint","rgba16sint","r32float","rgb10a2uint","rgb10a2unorm","depth16unorm","useFragDepth","depth32float","getCopyBufferToTextureViaRenderCode","format","info","depthDecl","depthCode","copyBufferToTextureViaRender","t","encoder","source","dest","size","sampleCount","texture","origin","copySize","msInfo","device","code","module","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","primitive","topology","multisample","count","uniforms","Uint32Array","height","bytesPerRow","bytesPerBlock","uniformBuffer","makeBufferWithContents","GPUBufferUsage","COPY_DST","UNIFORM","storageBuffer","createBufferTracked","buffer","usage","STORAGE","copyBufferToBuffer","baseMipLevel","mipLevel","l","depthOrArrayLayers","baseArrayLayer","z","mipLevelCount","arrayLayerCount","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","depthClearValue","depthLoadOp","depthStoreOp","loadOp","storeOp","setViewport","x","y","width","setPipeline","offset","rowsPerImage","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","draw","end","createTextureFromTexelViews","texelViews","desc","length","every","e","createTextureTracked","GPUTextureUsage","commandEncoder","createCommandEncoder","stagingBuffers","mipSize","mipWidth","mipHeight","mipDepthOrArray","dimension","stagingBuffer","mappedAtCreation","COPY_SRC","push","writeTextureData","Uint8Array","getMappedRange","subrectOrigin","subrectSize","unmap","copyBufferToTexture","queue","submit","finish","forEach","value","destroy"],"sources":["../../../src/webgpu/util/texture.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { isDepthOrStencilTextureFormat, kTextureFormatInfo } from '../format_info.js';\nimport { GPUTest } from '../gpu_test.js';\n\nimport { getTextureCopyLayout } from './texture/layout.js';\nimport { TexelView } from './texture/texel_view.js';\nimport { reifyExtent3D, reifyOrigin3D } from './unions.js';\n\n// Note: For values that are supposedly unused we use 0.123 as a sentinel for\n// float formats and 123 for integer formats. For example, rendering to r8unorm\n// returns (v, 9.123, 0.123, 0.123). Since only v should be used this shouldn't\n// matter but just in case we set it to 123 so it's more likely to cause an\n// issue if something is wrong.\nconst kLoadValueFromStorageInfo: Partial<{\n  [k in GPUTextureFormat]: {\n    storageType: string;\n    texelType: string;\n    unpackWGSL: string;\n    useFragDepth?: boolean;\n  };\n}> = {\n  r8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    return vec4f(unpack4x8unorm(src[byteOffset / 4])[byteOffset % 4], 0.123, 0.123, 0.123)\n  `,\n  },\n  r8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    return vec4u(unpack4xU8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  r8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    return vec4i(unpack4xI8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  rg8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    let v = unpack4x8unorm(src[byteOffset / 4]);\n    return vec4f(select(v.rg, v.ba, byteOffset % 4 >= 2), 0.123, 0.123)\n  `,\n  },\n  rg8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    let v = unpack4xU8(src[byteOffset / 4]);\n    return vec4u(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rg8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    let v = unpack4xI8(src[byteOffset / 4]);\n    return vec4i(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rgba8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4])',\n  },\n  'rgba8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.rgb, v.a);\n    `,\n  },\n  bgra8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4]).bgra',\n  },\n  'bgra8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.bgr, v.a);\n    `,\n  },\n  rgba8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: 'return unpack4xU8(src[byteOffset / 4])',\n  },\n  rgba8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: 'return unpack4xI8(src[byteOffset / 4])',\n  },\n  r16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL:\n      'return vec4f(unpack2x16float(src[byteOffset / 4])[byteOffset % 4 / 2], 0.123, 0.123, 0.123)',\n  },\n  r16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL:\n      'return vec4u(extractBits(src[byteOffset / 4], (byteOffset % 4 / 2 * 16), 16), 123, 123, 123)',\n  },\n  r16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL:\n      'return vec4i(extractBits(src[byteOffset / 4], byteOffset % 4 / 2 * 16, 16), 123, 123, 123)',\n  },\n  rg16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(unpack2x16float(src[byteOffset / 4]), 0.123, 0.123)',\n  },\n  rg16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(v & 0xFFFF, v >> 16, 123, 123)\n    `,\n  },\n  rg16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4i(\n        extractBits(v, 0, 16),\n        extractBits(v, 16, 16),\n        123, 123)\n    `,\n  },\n  rgba16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      return vec4f(\n        unpack2x16float(src[byteOffset / 4]),\n        unpack2x16float(src[byteOffset / 4 + 1]))\n    `,\n  },\n  rgba16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4u(v0 & 0xFFFF, v0 >> 16, v1 & 0xFFFF, v1 >> 16)\n    `,\n  },\n  rgba16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4i(\n        extractBits(v0, 0, 16),\n        extractBits(v0, 16, 16),\n        extractBits(v1, 0, 16),\n        extractBits(v1, 16, 16),\n      )\n    `,\n  },\n  r32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(src[byteOffset / 4], 0.123, 0.123, 0.123)',\n  },\n  rgb10a2uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(\n        extractBits(v, 0, 10),\n        extractBits(v, 10, 10),\n        extractBits(v, 20, 10),\n        extractBits(v, 30, 2),\n      )\n    `,\n  },\n  rgb10a2unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(\n        f32(extractBits(v, 0, 10)) / f32(0x3FF),\n        f32(extractBits(v, 10, 10)) / f32(0x3FF),\n        f32(extractBits(v, 20, 10)) / f32(0x3FF),\n        f32(extractBits(v, 30, 2)) / f32(0x3),\n      )\n    `,\n  },\n  depth16unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack2x16unorm(src[byteOffset / 4])[byteOffset % 4 / 2];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n    useFragDepth: true,\n  },\n  depth32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n    useFragDepth: true,\n  },\n};\n\nfunction getCopyBufferToTextureViaRenderCode(format: GPUTextureFormat) {\n  const info = kLoadValueFromStorageInfo[format];\n  assert(!!info);\n  const { storageType, texelType, unpackWGSL, useFragDepth } = info;\n\n  const [depthDecl, depthCode] = useFragDepth\n    ? ['@builtin(frag_depth) d: f32,', 'fs.d = fs.v[0];']\n    : ['', ''];\n\n  return `\n    struct Uniforms {\n      numTexelRows: u32,\n      bytesPerRow: u32,\n      bytesPerSample: u32,\n      sampleCount: u32,\n    };\n\n    struct VSOutput {\n      @builtin(position) pos: vec4f,\n      @location(0) @interpolate(flat, either) sampleIndex: u32,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vNdx: u32) -> VSOutput {\n      let points = array(\n        vec2f(0, 0), vec2f(1, 0), vec2f(0, 1), vec2f(1, 1),\n      );\n      let sampleRow = vNdx / 4;\n      let numSampleRows = f32(uni.numTexelRows * uni.sampleCount);\n      let rowOffset = f32(sampleRow) / numSampleRows;\n      let rowMult = 1.0 / numSampleRows;\n      let p = (points[vNdx % 4] * vec2f(1, rowMult) + vec2f(0, rowOffset)) * 2.0 - 1.0;\n      return VSOutput(vec4f(p, 0, 1), uni.sampleCount - sampleRow % uni.sampleCount - 1);\n    }\n\n    @group(0) @binding(0) var<uniform> uni: Uniforms;\n    @group(0) @binding(1) var<storage> src: array<${storageType}>;\n\n    fn unpack(byteOffset: u32) -> ${texelType} {\n      ${unpackWGSL};\n    }\n\n    struct FSOutput {\n      @location(0) v: ${texelType},\n      ${depthDecl}\n    };\n\n    @fragment fn fs(vin: VSOutput) -> FSOutput {\n      let coord = vec2u(vin.pos.xy);\n      let byteOffset =\n        coord.y * uni.bytesPerRow +\n        (coord.x * uni.sampleCount + vin.sampleIndex) * uni.bytesPerSample;\n      var fs: FSOutput;\n      fs.v = unpack(byteOffset);\n      ${depthCode}\n      return fs;\n    }\n    `;\n}\n\nfunction copyBufferToTextureViaRender(\n  t: GPUTest,\n  encoder: GPUCommandEncoder,\n  source: GPUImageCopyBuffer,\n  dest: GPUImageCopyTexture,\n  size: GPUExtent3D\n) {\n  const { format, sampleCount } = dest.texture;\n  const origin = reifyOrigin3D(dest.origin ?? [0]);\n  const copySize = reifyExtent3D(size);\n\n  const msInfo = kLoadValueFromStorageInfo[format];\n  assert(!!msInfo);\n  const { useFragDepth } = msInfo;\n\n  const { device } = t;\n  const code = getCopyBufferToTextureViaRenderCode(format);\n  const module = device.createShaderModule({ code });\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    ...(useFragDepth\n      ? {\n          fragment: {\n            module,\n            targets: [],\n          },\n          depthStencil: {\n            depthWriteEnabled: true,\n            depthCompare: 'always',\n            format,\n          },\n        }\n      : {\n          fragment: {\n            module,\n            targets: [{ format }],\n          },\n        }),\n    primitive: {\n      topology: 'triangle-strip',\n    },\n    ...(sampleCount > 1 && { multisample: { count: sampleCount } }),\n  });\n\n  const info = kTextureFormatInfo[format];\n  const uniforms = new Uint32Array([\n    copySize.height, //  numTexelRows: u32,\n    source.bytesPerRow!, //  bytesPerRow: u32,\n    info.bytesPerBlock!, //  bytesPerSample: u32,\n    dest.texture.sampleCount, //  sampleCount: u32,\n  ]);\n  const uniformBuffer = t.makeBufferWithContents(\n    uniforms,\n    GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n  );\n  const storageBuffer = t.createBufferTracked({\n    size: source.buffer.size,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  encoder.copyBufferToBuffer(source.buffer, 0, storageBuffer, 0, storageBuffer.size);\n  const baseMipLevel = dest.mipLevel;\n  for (let l = 0; l < copySize.depthOrArrayLayers; ++l) {\n    const baseArrayLayer = origin.z + l;\n    const mipLevelCount = 1;\n    const arrayLayerCount = 1;\n    const pass = encoder.beginRenderPass(\n      useFragDepth\n        ? {\n            colorAttachments: [],\n            depthStencilAttachment: {\n              view: dest.texture.createView({\n                baseMipLevel,\n                baseArrayLayer,\n                mipLevelCount,\n                arrayLayerCount,\n              }),\n              depthClearValue: 0.5,\n              depthLoadOp: 'clear',\n              depthStoreOp: 'store',\n            },\n          }\n        : {\n            colorAttachments: [\n              {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                loadOp: 'clear',\n                storeOp: 'store',\n              },\n            ],\n          }\n    );\n    pass.setViewport(origin.x, origin.y, copySize.width, copySize.height, 0, 1);\n    pass.setPipeline(pipeline);\n\n    const offset =\n      (source.offset ?? 0) + (source.bytesPerRow ?? 0) * (source.rowsPerImage ?? 0) * l;\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: uniformBuffer } },\n        { binding: 1, resource: { buffer: storageBuffer, offset } },\n      ],\n    });\n\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(4 * copySize.height * dest.texture.sampleCount);\n    pass.end();\n  }\n}\n\n/**\n * Creates a mipmapped texture where each mipmap level's (`i`) content is\n * from `texelViews[i]`.\n */\nexport function createTextureFromTexelViews(\n  t: GPUTest,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  // All texel views must be the same format for mipmaps.\n  assert(texelViews.length > 0 && texelViews.every(e => e.format === texelViews[0].format));\n  const format = texelViews[0].format;\n  const { width, height, depthOrArrayLayers } = reifyExtent3D(desc.size);\n\n  // Create the texture and then initialize each mipmap level separately.\n  const texture = t.createTextureTracked({\n    ...desc,\n    format,\n    usage: desc.usage | GPUTextureUsage.COPY_DST,\n    mipLevelCount: texelViews.length,\n  });\n\n  // Copy the texel view into each mip level layer.\n  const commandEncoder = t.device.createCommandEncoder();\n  const stagingBuffers = [];\n  for (let mipLevel = 0; mipLevel < texelViews.length; mipLevel++) {\n    const {\n      bytesPerRow,\n      rowsPerImage,\n      mipSize: [mipWidth, mipHeight, mipDepthOrArray],\n    } = getTextureCopyLayout(format, desc.dimension ?? '2d', [width, height, depthOrArrayLayers], {\n      mipLevel,\n    });\n\n    // Create a staging buffer to upload the texture mip level contents.\n    const stagingBuffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bytesPerRow * mipHeight * mipDepthOrArray,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n    stagingBuffers.push(stagingBuffer);\n\n    // Write the texels into the staging buffer.\n    texelViews[mipLevel].writeTextureData(new Uint8Array(stagingBuffer.getMappedRange()), {\n      bytesPerRow,\n      rowsPerImage: mipHeight,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [mipWidth, mipHeight, mipDepthOrArray],\n      sampleCount: texture.sampleCount,\n    });\n    stagingBuffer.unmap();\n\n    if (texture.sampleCount > 1 || isDepthOrStencilTextureFormat(format)) {\n      copyBufferToTextureViaRender(\n        t,\n        commandEncoder,\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    } else {\n      // Copy from the staging buffer into the texture.\n      commandEncoder.copyBufferToTexture(\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    }\n  }\n  t.device.queue.submit([commandEncoder.finish()]);\n\n  // Cleanup the staging buffers.\n  stagingBuffers.forEach(value => value.destroy());\n\n  return texture;\n}\n"],"mappings":"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"}
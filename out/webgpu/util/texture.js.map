{"version":3,"file":"texture.js","names":["assert","isDepthOrStencilTextureFormat","kTextureFormatInfo","getTextureCopyLayout","reifyExtent3D","reifyOrigin3D","kLoadValueFromStorageInfo","r8unorm","storageType","texelType","unpackWGSL","r8uint","r8sint","rg8unorm","rg8uint","rg8sint","rgba8unorm","bgra8unorm","rgba8uint","rgba8sint","r16float","r16uint","r16sint","rg16float","rg16uint","rg16sint","rgba16float","rgba16uint","rgba16sint","r32float","rgb10a2uint","rgb10a2unorm","depth16unorm","useFragDepth","depth32float","stencil8","discardWithStencil","getCopyBufferToTextureViaRenderCode","format","info","depthDecl","depthCode","stencilCode","s_copyBufferToTextureViaRenderPipelines","WeakMap","copyBufferToTextureViaRender","t","encoder","source","dest","size","sampleCount","texture","origin","copySize","msInfo","device","numBlits","blitCount","code","stencilWriteMask","id","JSON","stringify","pipelines","get","Map","set","pipeline","module","createShaderModule","createRenderPipeline","label","layout","vertex","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","stencilFront","passOp","primitive","topology","multisample","count","uniforms","Uint32Array","height","bytesPerRow","bytesPerBlock","uniformBuffer","makeBufferWithContents","GPUBufferUsage","COPY_DST","UNIFORM","storageBuffer","createBufferTracked","buffer","usage","STORAGE","copyBufferToBuffer","baseMipLevel","mipLevel","l","depthOrArrayLayers","baseArrayLayer","z","mipLevelCount","arrayLayerCount","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","stencilClearValue","stencilLoadOp","stencilStoreOp","depthClearValue","depthLoadOp","depthStoreOp","loadOp","storeOp","setViewport","x","y","width","setPipeline","offset","rowsPerImage","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","setStencilReference","draw","end","createTextureFromTexelViews","texelViews","desc","length","every","e","createTextureTracked","GPUTextureUsage","commandEncoder","createCommandEncoder","stagingBuffers","mipSize","mipWidth","mipHeight","mipDepthOrArray","dimension","stagingBuffer","mappedAtCreation","COPY_SRC","push","writeTextureData","Uint8Array","getMappedRange","subrectOrigin","subrectSize","unmap","copyBufferToTexture","queue","submit","finish","forEach","value","destroy"],"sources":["../../../src/webgpu/util/texture.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { isDepthOrStencilTextureFormat, kTextureFormatInfo } from '../format_info.js';\nimport { GPUTest } from '../gpu_test.js';\n\nimport { getTextureCopyLayout } from './texture/layout.js';\nimport { TexelView } from './texture/texel_view.js';\nimport { reifyExtent3D, reifyOrigin3D } from './unions.js';\n\n// Note: For values that are supposedly unused we use 0.123 as a sentinel for\n// float formats and 123 for integer formats. For example, rendering to r8unorm\n// returns (v, 9.123, 0.123, 0.123). Since only v should be used this shouldn't\n// matter but just in case we set it to 123 so it's more likely to cause an\n// issue if something is wrong.\nconst kLoadValueFromStorageInfo: Partial<{\n  [k in GPUTextureFormat]: {\n    storageType: string;\n    texelType: string;\n    unpackWGSL: string;\n    useFragDepth?: boolean;\n    discardWithStencil?: boolean;\n  };\n}> = {\n  r8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    return vec4f(unpack4x8unorm(src[byteOffset / 4])[byteOffset % 4], 0.123, 0.123, 0.123)\n  `,\n  },\n  r8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    return vec4u(unpack4xU8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  r8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    return vec4i(unpack4xI8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  rg8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    let v = unpack4x8unorm(src[byteOffset / 4]);\n    return vec4f(select(v.rg, v.ba, byteOffset % 4 >= 2), 0.123, 0.123)\n  `,\n  },\n  rg8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    let v = unpack4xU8(src[byteOffset / 4]);\n    return vec4u(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rg8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    let v = unpack4xI8(src[byteOffset / 4]);\n    return vec4i(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rgba8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4])',\n  },\n  'rgba8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.rgb, v.a);\n    `,\n  },\n  bgra8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4]).bgra',\n  },\n  'bgra8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.bgr, v.a);\n    `,\n  },\n  rgba8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: 'return unpack4xU8(src[byteOffset / 4])',\n  },\n  rgba8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: 'return unpack4xI8(src[byteOffset / 4])',\n  },\n  r16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL:\n      'return vec4f(unpack2x16float(src[byteOffset / 4])[byteOffset % 4 / 2], 0.123, 0.123, 0.123)',\n  },\n  r16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL:\n      'return vec4u(extractBits(src[byteOffset / 4], (byteOffset % 4 / 2 * 16), 16), 123, 123, 123)',\n  },\n  r16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL:\n      'return vec4i(extractBits(src[byteOffset / 4], byteOffset % 4 / 2 * 16, 16), 123, 123, 123)',\n  },\n  rg16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(unpack2x16float(src[byteOffset / 4]), 0.123, 0.123)',\n  },\n  rg16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(v & 0xFFFF, v >> 16, 123, 123)\n    `,\n  },\n  rg16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4i(\n        extractBits(v, 0, 16),\n        extractBits(v, 16, 16),\n        123, 123)\n    `,\n  },\n  rgba16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      return vec4f(\n        unpack2x16float(src[byteOffset / 4]),\n        unpack2x16float(src[byteOffset / 4 + 1]))\n    `,\n  },\n  rgba16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4u(v0 & 0xFFFF, v0 >> 16, v1 & 0xFFFF, v1 >> 16)\n    `,\n  },\n  rgba16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4i(\n        extractBits(v0, 0, 16),\n        extractBits(v0, 16, 16),\n        extractBits(v1, 0, 16),\n        extractBits(v1, 16, 16),\n      )\n    `,\n  },\n  r32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(src[byteOffset / 4], 0.123, 0.123, 0.123)',\n  },\n  rgb10a2uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(\n        extractBits(v, 0, 10),\n        extractBits(v, 10, 10),\n        extractBits(v, 20, 10),\n        extractBits(v, 30, 2),\n      )\n    `,\n  },\n  rgb10a2unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(\n        f32(extractBits(v, 0, 10)) / f32(0x3FF),\n        f32(extractBits(v, 10, 10)) / f32(0x3FF),\n        f32(extractBits(v, 20, 10)) / f32(0x3FF),\n        f32(extractBits(v, 30, 2)) / f32(0x3),\n      )\n    `,\n  },\n  depth16unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack2x16unorm(src[byteOffset / 4])[byteOffset % 4 / 2];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n    useFragDepth: true,\n  },\n  depth32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n    useFragDepth: true,\n  },\n  stencil8: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      return vec4u(unpack4xU8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n    `,\n    discardWithStencil: true,\n  },\n};\n\nfunction getCopyBufferToTextureViaRenderCode(format: GPUTextureFormat) {\n  const info = kLoadValueFromStorageInfo[format];\n  assert(!!info);\n  const { storageType, texelType, unpackWGSL, useFragDepth, discardWithStencil } = info;\n\n  const [depthDecl, depthCode] = useFragDepth\n    ? ['@builtin(frag_depth) d: f32,', 'fs.d = fs.v[0];']\n    : ['', ''];\n\n  const stencilCode = discardWithStencil ? 'if ((fs.v.r & vin.stencilMask) == 0) { discard; }' : '';\n\n  return `\n    struct Uniforms {\n      numTexelRows: u32,\n      bytesPerRow: u32,\n      bytesPerSample: u32,\n      sampleCount: u32,\n    };\n\n    struct VSOutput {\n      @builtin(position) pos: vec4f,\n      @location(0) @interpolate(flat, either) sampleIndex: u32,\n      @location(1) @interpolate(flat, either) stencilMask: u32,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n      let points = array(\n        vec2f(0, 0), vec2f(1, 0), vec2f(0, 1), vec2f(1, 1),\n      );\n      let sampleRow = vNdx / 4;\n      let numSampleRows = f32(uni.numTexelRows * uni.sampleCount);\n      let rowOffset = f32(sampleRow) / numSampleRows;\n      let rowMult = 1.0 / numSampleRows;\n      let p = (points[vNdx % 4] * vec2f(1, rowMult) + vec2f(0, rowOffset)) * 2.0 - 1.0;\n      return VSOutput(\n        vec4f(p, 0, 1),\n        uni.sampleCount - sampleRow % uni.sampleCount - 1,\n        1u << iNdx);\n    }\n\n    @group(0) @binding(0) var<uniform> uni: Uniforms;\n    @group(0) @binding(1) var<storage> src: array<${storageType}>;\n\n    fn unpack(byteOffset: u32) -> ${texelType} {\n      ${unpackWGSL};\n    }\n\n    struct FSOutput {\n      @location(0) v: ${texelType},\n      ${depthDecl}\n    };\n\n    @fragment fn fs(vin: VSOutput) -> FSOutput {\n      let coord = vec2u(vin.pos.xy);\n      let byteOffset =\n        coord.y * uni.bytesPerRow +\n        (coord.x * uni.sampleCount + vin.sampleIndex) * uni.bytesPerSample;\n      var fs: FSOutput;\n      fs.v = unpack(byteOffset);\n      ${depthCode}\n      ${stencilCode}\n      return fs;\n    }\n    `;\n}\n\nconst s_copyBufferToTextureViaRenderPipelines = new WeakMap<\n  GPUDevice,\n  Map<string, GPURenderPipeline>\n>();\n\nfunction copyBufferToTextureViaRender(\n  t: GPUTest,\n  encoder: GPUCommandEncoder,\n  source: GPUImageCopyBuffer,\n  dest: GPUImageCopyTexture,\n  size: GPUExtent3D\n) {\n  const { format, sampleCount } = dest.texture;\n  const origin = reifyOrigin3D(dest.origin ?? [0]);\n  const copySize = reifyExtent3D(size);\n\n  const msInfo = kLoadValueFromStorageInfo[format];\n  assert(!!msInfo);\n  const { useFragDepth, discardWithStencil } = msInfo;\n\n  const { device } = t;\n  const numBlits = discardWithStencil ? 8 : 1;\n  for (let blitCount = 0; blitCount < numBlits; ++blitCount) {\n    const code = getCopyBufferToTextureViaRenderCode(format);\n    const stencilWriteMask = 1 << blitCount;\n    const id = JSON.stringify({\n      format,\n      useFragDepth,\n      stencilWriteMask,\n      discardWithStencil,\n      sampleCount,\n      code,\n    });\n    const pipelines =\n      s_copyBufferToTextureViaRenderPipelines.get(device) ?? new Map<string, GPURenderPipeline>();\n    s_copyBufferToTextureViaRenderPipelines.set(device, pipelines);\n    let pipeline = pipelines.get(id);\n    if (!pipeline) {\n      const module = device.createShaderModule({ code });\n      pipeline = device.createRenderPipeline({\n        label: `blitCopyFor-${format}`,\n        layout: 'auto',\n        vertex: { module },\n        ...(discardWithStencil\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: false,\n                depthCompare: 'always',\n                format,\n                stencilWriteMask,\n                stencilFront: {\n                  passOp: 'replace',\n                },\n              },\n            }\n          : useFragDepth\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'always',\n                format,\n              },\n            }\n          : {\n              fragment: {\n                module,\n                targets: [{ format }],\n              },\n            }),\n        primitive: {\n          topology: 'triangle-strip',\n        },\n        ...(sampleCount > 1 && { multisample: { count: sampleCount } }),\n      });\n      pipelines.set(id, pipeline);\n    }\n\n    const info = kTextureFormatInfo[format];\n    const uniforms = new Uint32Array([\n      copySize.height, //  numTexelRows: u32,\n      source.bytesPerRow!, //  bytesPerRow: u32,\n      info.bytesPerBlock!, //  bytesPerSample: u32,\n      dest.texture.sampleCount, //  sampleCount: u32,\n    ]);\n    const uniformBuffer = t.makeBufferWithContents(\n      uniforms,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n    );\n    const storageBuffer = t.createBufferTracked({\n      size: source.buffer.size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n    encoder.copyBufferToBuffer(source.buffer, 0, storageBuffer, 0, storageBuffer.size);\n    const baseMipLevel = dest.mipLevel;\n    for (let l = 0; l < copySize.depthOrArrayLayers; ++l) {\n      const baseArrayLayer = origin.z + l;\n      const mipLevelCount = 1;\n      const arrayLayerCount = 1;\n      const pass = encoder.beginRenderPass(\n        discardWithStencil\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                stencilClearValue: 0,\n                stencilLoadOp: 'load',\n                stencilStoreOp: 'store',\n              },\n            }\n          : useFragDepth\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                depthClearValue: 0,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n              },\n            }\n          : {\n              colorAttachments: [\n                {\n                  view: dest.texture.createView({\n                    baseMipLevel,\n                    baseArrayLayer,\n                    mipLevelCount,\n                    arrayLayerCount,\n                  }),\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                },\n              ],\n            }\n      );\n      pass.setViewport(origin.x, origin.y, copySize.width, copySize.height, 0, 1);\n      pass.setPipeline(pipeline);\n\n      const offset =\n        (source.offset ?? 0) + (source.bytesPerRow ?? 0) * (source.rowsPerImage ?? 0) * l;\n      const bindGroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: uniformBuffer } },\n          { binding: 1, resource: { buffer: storageBuffer, offset } },\n        ],\n      });\n\n      pass.setBindGroup(0, bindGroup);\n      pass.setStencilReference(0xff);\n      pass.draw(4 * copySize.height * dest.texture.sampleCount, 1, 0, blitCount);\n      pass.end();\n    }\n  }\n}\n\n/**\n * Creates a mipmapped texture where each mipmap level's (`i`) content is\n * from `texelViews[i]`.\n */\nexport function createTextureFromTexelViews(\n  t: GPUTest,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  // All texel views must be the same format for mipmaps.\n  assert(texelViews.length > 0 && texelViews.every(e => e.format === texelViews[0].format));\n  const format = texelViews[0].format;\n  const { width, height, depthOrArrayLayers } = reifyExtent3D(desc.size);\n\n  // Create the texture and then initialize each mipmap level separately.\n  const texture = t.createTextureTracked({\n    ...desc,\n    format,\n    usage: desc.usage | GPUTextureUsage.COPY_DST,\n    mipLevelCount: texelViews.length,\n  });\n\n  // Copy the texel view into each mip level layer.\n  const commandEncoder = t.device.createCommandEncoder();\n  const stagingBuffers = [];\n  for (let mipLevel = 0; mipLevel < texelViews.length; mipLevel++) {\n    const {\n      bytesPerRow,\n      rowsPerImage,\n      mipSize: [mipWidth, mipHeight, mipDepthOrArray],\n    } = getTextureCopyLayout(format, desc.dimension ?? '2d', [width, height, depthOrArrayLayers], {\n      mipLevel,\n    });\n\n    // Create a staging buffer to upload the texture mip level contents.\n    const stagingBuffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bytesPerRow * mipHeight * mipDepthOrArray,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n    stagingBuffers.push(stagingBuffer);\n\n    // Write the texels into the staging buffer.\n    texelViews[mipLevel].writeTextureData(new Uint8Array(stagingBuffer.getMappedRange()), {\n      bytesPerRow,\n      rowsPerImage: mipHeight,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [mipWidth, mipHeight, mipDepthOrArray],\n      sampleCount: texture.sampleCount,\n    });\n    stagingBuffer.unmap();\n\n    if (texture.sampleCount > 1 || isDepthOrStencilTextureFormat(format)) {\n      copyBufferToTextureViaRender(\n        t,\n        commandEncoder,\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    } else {\n      // Copy from the staging buffer into the texture.\n      commandEncoder.copyBufferToTexture(\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    }\n  }\n  t.device.queue.submit([commandEncoder.finish()]);\n\n  // Cleanup the staging buffers.\n  stagingBuffers.forEach(value => value.destroy());\n\n  return texture;\n}\n"],"mappings":"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"}
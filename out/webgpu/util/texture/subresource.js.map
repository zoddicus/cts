{"version":3,"file":"subresource.js","names":["endOfRange","r","begin","count","end","rangeAsIterator","i","SubresourceRange","constructor","subresources","mipRange","layerRange","each","level","layer","mipLevels","layers"],"sources":["../../../../src/webgpu/util/texture/subresource.ts"],"sourcesContent":["/** A range of indices expressed as `{ begin, count }`. */\nexport interface BeginCountRange {\n  begin: number;\n  count: number;\n}\n\n/* A range of indices, expressed as `{ begin, end }`. */\nexport interface BeginEndRange {\n  begin: number;\n  end: number;\n}\n\nfunction endOfRange(r: BeginEndRange | BeginCountRange): number {\n  return 'count' in r ? r.begin + r.count : r.end;\n}\n\nfunction* rangeAsIterator(r: BeginEndRange | BeginCountRange): Generator<number> {\n  for (let i = r.begin; i < endOfRange(r); ++i) {\n    yield i;\n  }\n}\n\n/**\n * Represents a range of subresources of a single-plane texture:\n * a min/max mip level and min/max array layer.\n */\nexport class SubresourceRange {\n  readonly mipRange: BeginEndRange;\n  readonly layerRange: BeginEndRange;\n\n  constructor(subresources: {\n    mipRange: BeginEndRange | BeginCountRange;\n    layerRange: BeginEndRange | BeginCountRange;\n  }) {\n    this.mipRange = {\n      begin: subresources.mipRange.begin,\n      end: endOfRange(subresources.mipRange),\n    };\n    this.layerRange = {\n      begin: subresources.layerRange.begin,\n      end: endOfRange(subresources.layerRange),\n    };\n  }\n\n  /**\n   * Iterates over the \"rectangle\" of `{ level, layer }` pairs represented by the range.\n   */\n  *each(): Generator<{ level: number; layer: number }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      for (let layer = this.layerRange.begin; layer < this.layerRange.end; ++layer) {\n        yield { level, layer };\n      }\n    }\n  }\n\n  /**\n   * Iterates over the mip levels represented by the range, each level including an iterator\n   * over the array layers at that level.\n   */\n  *mipLevels(): Generator<{ level: number; layers: Generator<number> }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      yield {\n        level,\n        layers: rangeAsIterator(this.layerRange),\n      };\n    }\n  }\n}\n"],"mappings":";;IAAA;;;;AAMA;;;;;;AAMA,SAASA,UAAUA,CAACC,CAAkC,EAAU;EAC9D,OAAO,OAAO,IAAIA,CAAC,GAAGA,CAAC,CAACC,KAAK,GAAGD,CAAC,CAACE,KAAK,GAAGF,CAAC,CAACG,GAAG;AACjD;;AAEA,UAAUC,eAAeA,CAACJ,CAAkC,EAAqB;EAC/E,KAAK,IAAIK,CAAC,GAAGL,CAAC,CAACC,KAAK,EAAEI,CAAC,GAAGN,UAAU,CAACC,CAAC,CAAC,EAAE,EAAEK,CAAC,EAAE;IAC5C,MAAMA,CAAC;EACT;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,CAAC;;;;EAI5BC,WAAWA,CAACC,YAGX;;;EAAE;IACD,IAAI,CAACC,QAAQ,GAAG;MACdR,KAAK,EAAEO,YAAY,CAACC,QAAQ,CAACR,KAAK;MAClCE,GAAG,EAAEJ,UAAU,CAACS,YAAY,CAACC,QAAQ;IACvC,CAAC;IACD,IAAI,CAACC,UAAU,GAAG;MAChBT,KAAK,EAAEO,YAAY,CAACE,UAAU,CAACT,KAAK;MACpCE,GAAG,EAAEJ,UAAU,CAACS,YAAY,CAACE,UAAU;IACzC,CAAC;EACH;;EAEA;AACF;AACA;EACE,CAACC,IAAIA,CAAA,EAAgD;IACnD,KAAK,IAAIC,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACR,KAAK,EAAEW,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACN,GAAG,EAAE,EAAES,KAAK,EAAE;MACxE,KAAK,IAAIC,KAAK,GAAG,IAAI,CAACH,UAAU,CAACT,KAAK,EAAEY,KAAK,GAAG,IAAI,CAACH,UAAU,CAACP,GAAG,EAAE,EAAEU,KAAK,EAAE;QAC5E,MAAM,EAAED,KAAK,EAAEC,KAAK,CAAC,CAAC;MACxB;IACF;EACF;;EAEA;AACF;AACA;AACA;EACE,CAACC,SAASA,CAAA,EAA4D;IACpE,KAAK,IAAIF,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACR,KAAK,EAAEW,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACN,GAAG,EAAE,EAAES,KAAK,EAAE;MACxE,MAAM;QACJA,KAAK;QACLG,MAAM,EAAEX,eAAe,CAAC,IAAI,CAACM,UAAU;MACzC,CAAC;IACH;EACF;AACF"}
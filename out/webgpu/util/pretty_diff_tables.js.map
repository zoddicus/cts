{"version":3,"file":"pretty_diff_tables.js","names":["range","generatePrettyTable","fillToWidth","numberToString","rows","rowStrings","length","totalTableWidth","iters","map","row","Symbol","iterator","cellsForColumn","iter","r","next","done","undefined","value","every","cell","colWidth","Math","max","c","padStart","join"],"sources":["../../../src/webgpu/util/pretty_diff_tables.ts"],"sourcesContent":["import { range } from '../../common/util/util.js';\n\n/**\n * Pretty-prints a \"table\" of cell values (each being `number | string`), right-aligned.\n * Each row may be any iterator, including lazily-generated (potentially infinite) rows.\n *\n * The first argument is the printing options:\n *  - fillToWidth: Keep printing columns (as long as there is data) until this width is passed.\n *    If there is more data, \"...\" is appended.\n *  - numberToString: if a cell value is a number, this is used to stringify it.\n *\n * Each remaining argument provides one row for the table.\n */\nexport function generatePrettyTable(\n  { fillToWidth, numberToString }: { fillToWidth: number; numberToString: (n: number) => string },\n  rows: ReadonlyArray<Iterable<string | number>>\n): string {\n  const rowStrings = range(rows.length, () => '');\n  let totalTableWidth = 0;\n  const iters = rows.map(row => row[Symbol.iterator]());\n\n  // Loop over columns\n  for (;;) {\n    const cellsForColumn = iters.map(iter => {\n      const r = iter.next(); // Advance the iterator for each row, in lock-step.\n      return r.done ? undefined : typeof r.value === 'number' ? numberToString(r.value) : r.value;\n    });\n    if (cellsForColumn.every(cell => cell === undefined)) break;\n\n    // Maximum width of any cell in this column, plus one for space between columns\n    // (also inserts a space at the left of the first column).\n    const colWidth = Math.max(...cellsForColumn.map(c => (c === undefined ? 0 : c.length))) + 1;\n    for (let row = 0; row < rowStrings.length; ++row) {\n      const cell = cellsForColumn[row];\n      if (cell !== undefined) {\n        rowStrings[row] += cell.padStart(colWidth);\n      }\n    }\n\n    totalTableWidth += colWidth;\n    if (totalTableWidth >= fillToWidth) {\n      for (let row = 0; row < rowStrings.length; ++row) {\n        if (cellsForColumn[row] !== undefined) {\n          rowStrings[row] += ' ...';\n        }\n      }\n      break;\n    }\n  }\n  return rowStrings.join('\\n');\n}\n"],"mappings":";;GAAA,SAASA,KAAK,QAAQ,2BAA2B,CAAC,CAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA;AACjC,EAAEC,WAAW,EAAEC,cAAc,CAAiE,CAAC;AAC/FC,IAA8C;AACtC;EACR,MAAMC,UAAU,GAAGL,KAAK,CAACI,IAAI,CAACE,MAAM,EAAE,MAAM,EAAE,CAAC;EAC/C,IAAIC,eAAe,GAAG,CAAC;EACvB,MAAMC,KAAK,GAAGJ,IAAI,CAACK,GAAG,CAAC,CAAAC,GAAG,KAAIA,GAAG,CAACC,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAErD;EACA,SAAS;IACP,MAAMC,cAAc,GAAGL,KAAK,CAACC,GAAG,CAAC,CAAAK,IAAI,KAAI;MACvC,MAAMC,CAAC,GAAGD,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;MACvB,OAAOD,CAAC,CAACE,IAAI,GAAGC,SAAS,GAAG,OAAOH,CAAC,CAACI,KAAK,KAAK,QAAQ,GAAGhB,cAAc,CAACY,CAAC,CAACI,KAAK,CAAC,GAAGJ,CAAC,CAACI,KAAK;IAC7F,CAAC,CAAC;IACF,IAAIN,cAAc,CAACO,KAAK,CAAC,CAAAC,IAAI,KAAIA,IAAI,KAAKH,SAAS,CAAC,EAAE;;IAEtD;IACA;IACA,MAAMI,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGX,cAAc,CAACJ,GAAG,CAAC,CAAAgB,CAAC,KAAKA,CAAC,KAAKP,SAAS,GAAG,CAAC,GAAGO,CAAC,CAACnB,MAAO,CAAC,CAAC,GAAG,CAAC;IAC3F,KAAK,IAAII,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGL,UAAU,CAACC,MAAM,EAAE,EAAEI,GAAG,EAAE;MAChD,MAAMW,IAAI,GAAGR,cAAc,CAACH,GAAG,CAAC;MAChC,IAAIW,IAAI,KAAKH,SAAS,EAAE;QACtBb,UAAU,CAACK,GAAG,CAAC,IAAIW,IAAI,CAACK,QAAQ,CAACJ,QAAQ,CAAC;MAC5C;IACF;;IAEAf,eAAe,IAAIe,QAAQ;IAC3B,IAAIf,eAAe,IAAIL,WAAW,EAAE;MAClC,KAAK,IAAIQ,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGL,UAAU,CAACC,MAAM,EAAE,EAAEI,GAAG,EAAE;QAChD,IAAIG,cAAc,CAACH,GAAG,CAAC,KAAKQ,SAAS,EAAE;UACrCb,UAAU,CAACK,GAAG,CAAC,IAAI,MAAM;QAC3B;MACF;MACA;IACF;EACF;EACA,OAAOL,UAAU,CAACsB,IAAI,CAAC,IAAI,CAAC;AAC9B"}
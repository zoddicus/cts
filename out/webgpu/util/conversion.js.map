{"version":3,"file":"conversion.js","names":["Colors","assert","objectEquals","unreachable","Float16Array","kBit","cartesianProduct","clamp","correctlyRoundedF16","isFiniteF16","isSubnormalNumberF16","isSubnormalNumberF32","isSubnormalNumberF64","floatAsNormalizedInteger","float","bits","signed","max","Math","pow","round","normalizedIntegerAsFloat","integer","Number","isInteger","numbersApproximatelyEqual","a","b","maxDiff","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","abs","workingData","ArrayBuffer","workingDataU32","Uint32Array","workingDataU16","Uint16Array","workingDataU8","Uint8Array","workingDataF32","Float32Array","workingDataF16","workingDataI16","Int16Array","workingDataI32","Int32Array","workingDataI8","Int8Array","workingDataF64","Float64Array","workingDataI64","BigInt64Array","workingDataU64","BigUint64Array","workingDataView","DataView","float32ToFloatBits","n","signBits","exponentBits","mantissaBits","bias","setFloat32","getUint32","sign","isFinite","mantissaBitsToDiscard","exp","newBiasedExp","newMantissa","float32ToFloat16Bits","float16BitsToFloat32","float16Bits","floatBitsToNumber","kFloat16Format","kFloat32Format","kUFloat9e5Format","float32BitsToNumber","numberToFloat32Bits","number","fmt","kNonSignBits","kNonSignBitsMask","exponentAndMantissaBits","exponentMask","infinityOrNaN","mantissaMask","signBit","isNegative","NaN","f32BitsWithWrongBias","numberWithWrongBias","ufloatM9E5BitsToNumber","exponent","mantissa","numberToFloatBits","floatBitsToNormalULPFromZero","mask_sign","mask_expt","mask_mant","mask_rest","rest","subnormal_or_zero","infinity_or_nan","abs_ulp_from_zero","packRGB9E5UFloat","r","g","N","Emax","B","sharedexp_max","red_c","min","green_c","blue_c","max_c","exp_shared_p","floor","log2","max_s","exp_shared","scalar","red_s","green_s","blue_s","unpackRGB9E5UFloat","encoded","R","G","pack2x16float","x","y","generateU16s","contains_subnormals","n_f16s","some","n_u16s","map","f16","contains_poszero","u","positive","zero","contains_negzero","negative","push","undefined","results","Array","p","length","pack2x16snorm","generateI16","pack2x16unorm","generateU16","pack4x8snorm","vals","generateI8","idx","pack4x8unorm","generateU8","assertInIntegerRange","gammaCompress","gammaDecompress","float32ToUint32","f32","uint32ToFloat32","u32","float32ToInt32","uint32ToInt32","float16ToUint16","uint16ToFloat16","u16","float16ToInt16","ScalarType","constructor","kind","size","read","_size","toString","create","value","abstractFloat","f64","u8","i32","i16","i8","bool","abstractInt","VectorType","width","elementType","buf","offset","elements","i","Vector","fill","v","vectorTypes","Map","TypeVec","key","ty","get","set","MatrixType","cols","rows","_","c","Matrix","columns","start","slice","matrixTypes","TypeMat","valueFromBytes","workingDataOut","BYTES_PER_ELEMENT","TypeAbstractInt","TypeI32","TypeU32","TypeAbstractFloat","TypeF64","TypeF32","TypeI16","TypeU16","TypeF16","f16Bits","TypeI8","TypeU8","TypeBool","scalarType","numElementsOf","Error","elementsOf","Scalar","flat","scalarTypeOf","type","bits1","bits0","copyTo","buffer","wgsl","withPoint","str","indexOf","bold","Infinity","hex","padStart","isFloatValue","valueOf","scalarFromValue","workingDataArray","scalarFromBits","workingDataStoreArray","workingDataLoadArray","f32Bits","abstractIntBits","i32Bits","i16Bits","i8Bits","u32Bits","u16Bits","u8Bits","True","False","element","els","join","e","z","w","vec2","vec3","vec4","toVector","op","num_cols","num_rows","every","elem_type","j","flatMap","toMatrix","m","SerializedScalarKind","serializeScalarKind","s","writeU8","AbstractFloat","F64","F32","F16","U32","U16","U8","AbstractInt","I32","I16","I8","Bool","deserializeScalarKind","readU8","SerializedValueKind","serializeValue","serializeScalar","writeF64","writeF32","writeF16","writeU32","writeU16","writeI32","writeI16","writeI8","writeI64","writeBool","column","deserializeValue","deserializeScalar","readF64","readF32","readF16","readU32","readU16","readI64","readI32","readI16","readI8","readBool","valueKind","scalarKind","scalars","numCols","numRows","isFloatType","isAbstractType","kAllFloatScalars","kAllFloatVector2","kAllFloatVector3","kAllFloatVector4","kAllFloatVectors","kAllF16ScalarsAndVectors","kAllFloatScalarsAndVectors","kAbstractIntegerScalar","kAbstractIntegerVector2","kAbstractIntegerVector3","kAbstractIntegerVector4","kAbstractIntegerVectors","kAllAbstractIntegerScalarAndVectors","kAllConcreteIntegerScalarsAndVectors","kAllSignedIntegerScalarsAndVectors","kAllUnsignedIntegerScalarsAndVectors","kAllFloatAndConcreteIntegerScalarsAndVectors","kAllFloatAndSignedIntegerScalarsAndVectors","t"],"sources":["../../../src/webgpu/util/conversion.ts"],"sourcesContent":["import { Colors } from '../../common/util/colors.js';\nimport { ROArrayArray } from '../../common/util/types.js';\nimport { assert, objectEquals, TypedArrayBufferView, unreachable } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport BinaryStream from './binary_stream.js';\nimport { kBit } from './constants.js';\nimport {\n  cartesianProduct,\n  clamp,\n  correctlyRoundedF16,\n  isFiniteF16,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  isSubnormalNumberF64,\n} from './math.js';\n\n/**\n * Encodes a JS `number` into a \"normalized\" (unorm/snorm) integer representation with `bits` bits.\n * Input must be between -1 and 1 if signed, or 0 and 1 if unsigned.\n *\n * MAINTENANCE_TODO: See if performance of texel_data improves if this function is pre-specialized\n * for a particular `bits`/`signed`.\n */\nexport function floatAsNormalizedInteger(float: number, bits: number, signed: boolean): number {\n  if (signed) {\n    assert(float >= -1 && float <= 1, () => `${float} out of bounds of snorm`);\n    const max = Math.pow(2, bits - 1) - 1;\n    return Math.round(float * max);\n  } else {\n    assert(float >= 0 && float <= 1, () => `${float} out of bounds of unorm`);\n    const max = Math.pow(2, bits) - 1;\n    return Math.round(float * max);\n  }\n}\n\n/**\n * Decodes a JS `number` from a \"normalized\" (unorm/snorm) integer representation with `bits` bits.\n * Input must be an integer in the range of the specified unorm/snorm type.\n */\nexport function normalizedIntegerAsFloat(integer: number, bits: number, signed: boolean): number {\n  assert(Number.isInteger(integer));\n  if (signed) {\n    const max = Math.pow(2, bits - 1) - 1;\n    assert(integer >= -max - 1 && integer <= max);\n    if (integer === -max - 1) {\n      integer = -max;\n    }\n    return integer / max;\n  } else {\n    const max = Math.pow(2, bits) - 1;\n    assert(integer >= 0 && integer <= max);\n    return integer / max;\n  }\n}\n\n/**\n * Compares 2 numbers. Returns true if their absolute value is\n * less than or equal to maxDiff or if they are both NaN or the\n * same sign infinity.\n */\nexport function numbersApproximatelyEqual(a: number, b: number, maxDiff: number = 0) {\n  return (\n    (Number.isNaN(a) && Number.isNaN(b)) ||\n    (a === Number.POSITIVE_INFINITY && b === Number.POSITIVE_INFINITY) ||\n    (a === Number.NEGATIVE_INFINITY && b === Number.NEGATIVE_INFINITY) ||\n    Math.abs(a - b) <= maxDiff\n  );\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when converting between numeric formats\n *\n * workingData* is shared between multiple functions in this file, so to avoid re-entrancy problems, make sure in\n * functions that use it that they don't call themselves or other functions that use workingData*.\n */\nconst workingData = new ArrayBuffer(8);\nconst workingDataU32 = new Uint32Array(workingData);\nconst workingDataU16 = new Uint16Array(workingData);\nconst workingDataU8 = new Uint8Array(workingData);\nconst workingDataF32 = new Float32Array(workingData);\nconst workingDataF16 = new Float16Array(workingData);\nconst workingDataI16 = new Int16Array(workingData);\nconst workingDataI32 = new Int32Array(workingData);\nconst workingDataI8 = new Int8Array(workingData);\nconst workingDataF64 = new Float64Array(workingData);\nconst workingDataI64 = new BigInt64Array(workingData);\nconst workingDataU64 = new BigUint64Array(workingData);\nconst workingDataView = new DataView(workingData);\n\n/**\n * Encodes a JS `number` into an IEEE754 floating point number with the specified number of\n * sign, exponent, mantissa bits, and exponent bias.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n *\n * MAINTENANCE_TODO: Replace usages of this with numberToFloatBits.\n */\nexport function float32ToFloatBits(\n  n: number,\n  signBits: 0 | 1,\n  exponentBits: number,\n  mantissaBits: number,\n  bias: number\n): number {\n  assert(exponentBits <= 8);\n  assert(mantissaBits <= 23);\n\n  if (Number.isNaN(n)) {\n    // NaN = all exponent bits true, 1 or more mantissia bits true\n    return (((1 << exponentBits) - 1) << mantissaBits) | ((1 << mantissaBits) - 1);\n  }\n\n  workingDataView.setFloat32(0, n, true);\n  const bits = workingDataView.getUint32(0, true);\n  // bits (32): seeeeeeeefffffffffffffffffffffff\n\n  // 0 or 1\n  const sign = (bits >> 31) & signBits;\n\n  if (n === 0) {\n    if (sign === 1) {\n      // Handle negative zero.\n      return 1 << (exponentBits + mantissaBits);\n    }\n    return 0;\n  }\n\n  if (signBits === 0) {\n    assert(n >= 0);\n  }\n\n  if (!Number.isFinite(n)) {\n    // Infinity = all exponent bits true, no mantissa bits true\n    // plus the sign bit.\n    return (\n      (((1 << exponentBits) - 1) << mantissaBits) | (n < 0 ? 2 ** (exponentBits + mantissaBits) : 0)\n    );\n  }\n\n  const mantissaBitsToDiscard = 23 - mantissaBits;\n\n  // >> to remove mantissa, & to remove sign, - 127 to remove bias.\n  const exp = ((bits >> 23) & 0xff) - 127;\n\n  // Convert to the new biased exponent.\n  const newBiasedExp = bias + exp;\n  assert(newBiasedExp < 1 << exponentBits, () => `input number ${n} overflows target type`);\n\n  if (newBiasedExp <= 0) {\n    // Result is subnormal or zero. Round to (signed) zero.\n    return sign << (exponentBits + mantissaBits);\n  } else {\n    // Mask only the mantissa, and discard the lower bits.\n    const newMantissa = (bits & 0x7fffff) >> mantissaBitsToDiscard;\n    return (sign << (exponentBits + mantissaBits)) | (newBiasedExp << mantissaBits) | newMantissa;\n  }\n}\n\n/**\n * Encodes a JS `number` into an IEEE754 16 bit floating point number.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n */\nexport function float32ToFloat16Bits(n: number) {\n  return float32ToFloatBits(n, 1, 5, 10, 15);\n}\n\n/**\n * Decodes an IEEE754 16 bit floating point number into a JS `number` and returns.\n */\nexport function float16BitsToFloat32(float16Bits: number): number {\n  return floatBitsToNumber(float16Bits, kFloat16Format);\n}\n\ntype FloatFormat = { signed: 0 | 1; exponentBits: number; mantissaBits: number; bias: number };\n\n/** FloatFormat defining IEEE754 32-bit float. */\nexport const kFloat32Format = { signed: 1, exponentBits: 8, mantissaBits: 23, bias: 127 } as const;\n/** FloatFormat defining IEEE754 16-bit float. */\nexport const kFloat16Format = { signed: 1, exponentBits: 5, mantissaBits: 10, bias: 15 } as const;\n/** FloatFormat for 9 bit mantissa, 5 bit exponent unsigned float */\nexport const kUFloat9e5Format = { signed: 0, exponentBits: 5, mantissaBits: 9, bias: 15 } as const;\n\n/** Bitcast u32 (represented as integer Number) to f32 (represented as floating-point Number). */\nexport function float32BitsToNumber(bits: number): number {\n  workingDataU32[0] = bits;\n  return workingDataF32[0];\n}\n/** Bitcast f32 (represented as floating-point Number) to u32 (represented as integer Number). */\nexport function numberToFloat32Bits(number: number): number {\n  workingDataF32[0] = number;\n  return workingDataU32[0];\n}\n\n/**\n * Decodes an IEEE754 float with the supplied format specification into a JS number.\n *\n * The format MUST be no larger than a 32-bit float.\n */\nexport function floatBitsToNumber(bits: number, fmt: FloatFormat): number {\n  // Pad the provided bits out to f32, then convert to a `number` with the wrong bias.\n  // E.g. for f16 to f32:\n  // - f16: S    EEEEE MMMMMMMMMM\n  //        ^ 000^^^^^ ^^^^^^^^^^0000000000000\n  // - f32: S eeeEEEEE MMMMMMMMMMmmmmmmmmmmmmm\n\n  const kNonSignBits = fmt.exponentBits + fmt.mantissaBits;\n  const kNonSignBitsMask = (1 << kNonSignBits) - 1;\n  const exponentAndMantissaBits = bits & kNonSignBitsMask;\n  const exponentMask = ((1 << fmt.exponentBits) - 1) << fmt.mantissaBits;\n  const infinityOrNaN = (bits & exponentMask) === exponentMask;\n  if (infinityOrNaN) {\n    const mantissaMask = (1 << fmt.mantissaBits) - 1;\n    const signBit = 2 ** kNonSignBits;\n    const isNegative = (bits & signBit) !== 0;\n    return bits & mantissaMask\n      ? Number.NaN\n      : isNegative\n      ? Number.NEGATIVE_INFINITY\n      : Number.POSITIVE_INFINITY;\n  }\n  let f32BitsWithWrongBias =\n    exponentAndMantissaBits << (kFloat32Format.mantissaBits - fmt.mantissaBits);\n  f32BitsWithWrongBias |= (bits << (31 - kNonSignBits)) & 0x8000_0000;\n  const numberWithWrongBias = float32BitsToNumber(f32BitsWithWrongBias);\n  return numberWithWrongBias * 2 ** (kFloat32Format.bias - fmt.bias);\n}\n\n/**\n * Convert ufloat9e5 bits from rgb9e5ufloat to a JS number\n *\n * The difference between `floatBitsToNumber` and `ufloatBitsToNumber`\n * is that the latter doesn't use an implicit leading bit:\n *\n * floatBitsToNumber      = 2^(exponent - bias) * (1 + mantissa / 2 ^ numMantissaBits)\n * ufloatM9E5BitsToNumber = 2^(exponent - bias) * (mantissa / 2 ^ numMantissaBits)\n *                        = 2^(exponent - bias - numMantissaBits) * mantissa\n */\nexport function ufloatM9E5BitsToNumber(bits: number, fmt: FloatFormat): number {\n  const exponent = bits >> fmt.mantissaBits;\n  const mantissaMask = (1 << fmt.mantissaBits) - 1;\n  const mantissa = bits & mantissaMask;\n  return mantissa * 2 ** (exponent - fmt.bias - fmt.mantissaBits);\n}\n\n/**\n * Encodes a JS `number` into an IEEE754 floating point number with the specified format.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n */\nexport function numberToFloatBits(number: number, fmt: FloatFormat): number {\n  return float32ToFloatBits(number, fmt.signed, fmt.exponentBits, fmt.mantissaBits, fmt.bias);\n}\n\n/**\n * Given a floating point number (as an integer representing its bits), computes how many ULPs it is\n * from zero.\n *\n * Subnormal numbers are skipped, so that 0 is one ULP from the minimum normal number.\n * Subnormal values are flushed to 0.\n * Positive and negative 0 are both considered to be 0 ULPs from 0.\n */\nexport function floatBitsToNormalULPFromZero(bits: number, fmt: FloatFormat): number {\n  const mask_sign = fmt.signed << (fmt.exponentBits + fmt.mantissaBits);\n  const mask_expt = ((1 << fmt.exponentBits) - 1) << fmt.mantissaBits;\n  const mask_mant = (1 << fmt.mantissaBits) - 1;\n  const mask_rest = mask_expt | mask_mant;\n\n  assert(fmt.exponentBits + fmt.mantissaBits <= 31);\n\n  const sign = bits & mask_sign ? -1 : 1;\n  const rest = bits & mask_rest;\n  const subnormal_or_zero = (bits & mask_expt) === 0;\n  const infinity_or_nan = (bits & mask_expt) === mask_expt;\n  assert(!infinity_or_nan, 'no ulp representation for infinity/nan');\n\n  // The first normal number is mask_mant+1, so subtract mask_mant to make min_normal - zero = 1ULP.\n  const abs_ulp_from_zero = subnormal_or_zero ? 0 : rest - mask_mant;\n  return sign * abs_ulp_from_zero;\n}\n\n/**\n * Encodes three JS `number` values into RGB9E5, returned as an integer-valued JS `number`.\n *\n * RGB9E5 represents three partial-precision floating-point numbers encoded into a single 32-bit\n * value all sharing the same 5-bit exponent.\n * There is no sign bit, and there is a shared 5-bit biased (15) exponent and a 9-bit\n * mantissa for each channel. The mantissa does NOT have an implicit leading \"1.\",\n * and instead has an implicit leading \"0.\".\n *\n * @see https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt\n */\nexport function packRGB9E5UFloat(r: number, g: number, b: number): number {\n  const N = 9; // number of mantissa bits\n  const Emax = 31; // max exponent\n  const B = 15; // exponent bias\n  const sharedexp_max = (((1 << N) - 1) / (1 << N)) * 2 ** (Emax - B);\n  const red_c = clamp(r, { min: 0, max: sharedexp_max });\n  const green_c = clamp(g, { min: 0, max: sharedexp_max });\n  const blue_c = clamp(b, { min: 0, max: sharedexp_max });\n  const max_c = Math.max(red_c, green_c, blue_c);\n  const exp_shared_p = Math.max(-B - 1, Math.floor(Math.log2(max_c))) + 1 + B;\n  const max_s = Math.floor(max_c / 2 ** (exp_shared_p - B - N) + 0.5);\n  const exp_shared = max_s === 1 << N ? exp_shared_p + 1 : exp_shared_p;\n  const scalar = 1 / 2 ** (exp_shared - B - N);\n  const red_s = Math.floor(red_c * scalar + 0.5);\n  const green_s = Math.floor(green_c * scalar + 0.5);\n  const blue_s = Math.floor(blue_c * scalar + 0.5);\n  assert(red_s >= 0 && red_s <= 0b111111111);\n  assert(green_s >= 0 && green_s <= 0b111111111);\n  assert(blue_s >= 0 && blue_s <= 0b111111111);\n  assert(exp_shared >= 0 && exp_shared <= 0b11111);\n  return ((exp_shared << 27) | (blue_s << 18) | (green_s << 9) | red_s) >>> 0;\n}\n\n/**\n * Decodes a RGB9E5 encoded color.\n * @see packRGB9E5UFloat\n */\nexport function unpackRGB9E5UFloat(encoded: number): { R: number; G: number; B: number } {\n  const N = 9; // number of mantissa bits\n  const B = 15; // exponent bias\n  const red_s = (encoded >>> 0) & 0b111111111;\n  const green_s = (encoded >>> 9) & 0b111111111;\n  const blue_s = (encoded >>> 18) & 0b111111111;\n  const exp_shared = (encoded >>> 27) & 0b11111;\n  const exp = Math.pow(2, exp_shared - B - N);\n  return {\n    R: exp * red_s,\n    G: exp * green_s,\n    B: exp * blue_s,\n  };\n}\n\n/**\n * Quantizes two f32s to f16 and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16float` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns an array of possible results for pack2x16float. Elements are either\n *          a number or undefined.\n *          undefined indicates that any value is valid, since the input went\n *          out of bounds.\n */\nexport function pack2x16float(x: number, y: number): (number | undefined)[] {\n  // Generates all possible valid u16 bit fields for a given f32 to f16 conversion.\n  // Assumes FTZ for both the f32 and f16 value is allowed.\n  const generateU16s = (n: number): readonly number[] => {\n    let contains_subnormals = isSubnormalNumberF32(n);\n    const n_f16s = correctlyRoundedF16(n);\n    contains_subnormals ||= n_f16s.some(isSubnormalNumberF16);\n\n    const n_u16s = n_f16s.map(f16 => {\n      workingDataF16[0] = f16;\n      return workingDataU16[0];\n    });\n\n    const contains_poszero = n_u16s.some(u => u === kBit.f16.positive.zero);\n    const contains_negzero = n_u16s.some(u => u === kBit.f16.negative.zero);\n    if (!contains_negzero && (contains_poszero || contains_subnormals)) {\n      n_u16s.push(kBit.f16.negative.zero);\n    }\n\n    if (!contains_poszero && (contains_negzero || contains_subnormals)) {\n      n_u16s.push(kBit.f16.positive.zero);\n    }\n\n    return n_u16s;\n  };\n\n  if (!isFiniteF16(x) || !isFiniteF16(y)) {\n    // This indicates any value is valid, so it isn't worth bothering\n    // calculating the more restrictive possibilities.\n    return [undefined];\n  }\n\n  const results = new Array<number>();\n  for (const p of cartesianProduct(generateU16s(x), generateU16s(y))) {\n    assert(p.length === 2, 'cartesianProduct of 2 arrays returned an entry with not 2 elements');\n    workingDataU16[0] = p[0];\n    workingDataU16[1] = p[1];\n    results.push(workingDataU32[0]);\n  }\n\n  return results;\n}\n\n/**\n * Converts two normalized f32s to i16s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16snorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns a number that is expected result of pack2x16snorm.\n */\nexport function pack2x16snorm(x: number, y: number): number {\n  // Converts f32 to i16 via the pack2x16snorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0 and 1, but significantly away from the edges, so floor goes to 0.\n  const generateI16 = (n: number): number => {\n    return Math.floor(0.5 + 32767 * Math.min(1, Math.max(-1, n)));\n  };\n\n  workingDataI16[0] = generateI16(x);\n  workingDataI16[1] = generateI16(y);\n\n  return workingDataU32[0];\n}\n\n/**\n * Converts two normalized f32s to u16s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16unorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns an number that is expected result of pack2x16unorm.\n */\nexport function pack2x16unorm(x: number, y: number): number {\n  // Converts f32 to u16 via the pack2x16unorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0.5 and much less than 1, so floor goes to 0.\n  const generateU16 = (n: number): number => {\n    return Math.floor(0.5 + 65535 * Math.min(1, Math.max(0, n)));\n  };\n\n  workingDataU16[0] = generateU16(x);\n  workingDataU16[1] = generateU16(y);\n\n  return workingDataU32[0];\n}\n\n/**\n * Converts four normalized f32s to i8s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack4x8snorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param vals four f32s to be packed\n * @returns a number that is expected result of pack4x8usorm.\n */\nexport function pack4x8snorm(...vals: [number, number, number, number]): number {\n  // Converts f32 to u8 via the pack4x8snorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0 and 1, so floor goes to 0.\n  const generateI8 = (n: number): number => {\n    return Math.floor(0.5 + 127 * Math.min(1, Math.max(-1, n)));\n  };\n\n  for (const idx in vals) {\n    workingDataI8[idx] = generateI8(vals[idx]);\n  }\n\n  return workingDataU32[0];\n}\n\n/**\n * Converts four normalized f32s to u8s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack4x8unorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param vals four f32s to be packed\n * @returns a number that is expected result of pack4x8unorm.\n */\nexport function pack4x8unorm(...vals: [number, number, number, number]): number {\n  // Converts f32 to u8 via the pack4x8unorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0.5 and much less than 1, so floor goes to 0.\n  const generateU8 = (n: number): number => {\n    return Math.floor(0.5 + 255 * Math.min(1, Math.max(0, n)));\n  };\n\n  for (const idx in vals) {\n    workingDataU8[idx] = generateU8(vals[idx]);\n  }\n\n  return workingDataU32[0];\n}\n\n/**\n * Asserts that a number is within the representable (inclusive) of the integer type with the\n * specified number of bits and signedness.\n *\n * MAINTENANCE_TODO: Assert isInteger? Then this function \"asserts that a number is representable\"\n * by the type.\n */\nexport function assertInIntegerRange(n: number, bits: number, signed: boolean): void {\n  if (signed) {\n    const min = -Math.pow(2, bits - 1);\n    const max = Math.pow(2, bits - 1) - 1;\n    assert(n >= min && n <= max);\n  } else {\n    const max = Math.pow(2, bits) - 1;\n    assert(n >= 0 && n <= max);\n  }\n}\n\n/**\n * Converts a linear value into a \"gamma\"-encoded value using the sRGB-clamped transfer function.\n */\nexport function gammaCompress(n: number): number {\n  n = n <= 0.0031308 ? (323 * n) / 25 : (211 * Math.pow(n, 5 / 12) - 11) / 200;\n  return clamp(n, { min: 0, max: 1 });\n}\n\n/**\n * Converts a \"gamma\"-encoded value into a linear value using the sRGB-clamped transfer function.\n */\nexport function gammaDecompress(n: number): number {\n  n = n <= 0.04045 ? (n * 25) / 323 : Math.pow((200 * n + 11) / 211, 12 / 5);\n  return clamp(n, { min: 0, max: 1 });\n}\n\n/** Converts a 32-bit float value to a 32-bit unsigned integer value */\nexport function float32ToUint32(f32: number): number {\n  workingDataF32[0] = f32;\n  return workingDataU32[0];\n}\n\n/** Converts a 32-bit unsigned integer value to a 32-bit float value */\nexport function uint32ToFloat32(u32: number): number {\n  workingDataU32[0] = u32;\n  return workingDataF32[0];\n}\n\n/** Converts a 32-bit float value to a 32-bit signed integer value */\nexport function float32ToInt32(f32: number): number {\n  workingDataF32[0] = f32;\n  return workingDataI32[0];\n}\n\n/** Converts a 32-bit unsigned integer value to a 32-bit signed integer value */\nexport function uint32ToInt32(u32: number): number {\n  workingDataU32[0] = u32;\n  return workingDataI32[0];\n}\n\n/** Converts a 16-bit float value to a 16-bit unsigned integer value */\nexport function float16ToUint16(f16: number): number {\n  workingDataF16[0] = f16;\n  return workingDataU16[0];\n}\n\n/** Converts a 16-bit unsigned integer value to a 16-bit float value */\nexport function uint16ToFloat16(u16: number): number {\n  workingDataU16[0] = u16;\n  return workingDataF16[0];\n}\n\n/** Converts a 16-bit float value to a 16-bit signed integer value */\nexport function float16ToInt16(f16: number): number {\n  workingDataF16[0] = f16;\n  return workingDataI16[0];\n}\n\n/** A type of number representable by Scalar. */\nexport type ScalarKind =\n  | 'abstract-float'\n  | 'f64'\n  | 'f32'\n  | 'f16'\n  | 'u32'\n  | 'u16'\n  | 'u8'\n  | 'abstract-int'\n  | 'i32'\n  | 'i16'\n  | 'i8'\n  | 'bool';\n\n/** ScalarType describes the type of WGSL Scalar. */\nexport class ScalarType {\n  readonly kind: ScalarKind; // The named type\n  readonly _size: number; // In bytes\n  readonly read: (buf: Uint8Array, offset: number) => Scalar; // reads a scalar from a buffer\n\n  constructor(kind: ScalarKind, size: number, read: (buf: Uint8Array, offset: number) => Scalar) {\n    this.kind = kind;\n    this._size = size;\n    this.read = read;\n  }\n\n  public toString(): string {\n    return this.kind;\n  }\n\n  public get size(): number {\n    return this._size;\n  }\n\n  /** Constructs a Scalar of this type with `value` */\n  public create(value: number | bigint): Scalar {\n    switch (typeof value) {\n      case 'number':\n        switch (this.kind) {\n          case 'abstract-float':\n            return abstractFloat(value);\n          case 'f64':\n            return f64(value);\n          case 'f32':\n            return f32(value);\n          case 'f16':\n            return f16(value);\n          case 'u32':\n            return u32(value);\n          case 'u16':\n            return u16(value);\n          case 'u8':\n            return u8(value);\n          case 'i32':\n            return i32(value);\n          case 'i16':\n            return i16(value);\n          case 'i8':\n            return i8(value);\n          case 'bool':\n            return bool(value !== 0);\n        }\n        break;\n      case 'bigint':\n        switch (this.kind) {\n          case 'abstract-int':\n            return abstractInt(value);\n          case 'bool':\n            return bool(value !== 0n);\n        }\n        break;\n    }\n    unreachable(`Scalar<${this.kind}>.create() does not support ${typeof value}`);\n  }\n}\n\n/** VectorType describes the type of WGSL Vector. */\nexport class VectorType {\n  readonly width: number; // Number of elements in the vector\n  readonly elementType: ScalarType; // Element type\n\n  constructor(width: number, elementType: ScalarType) {\n    this.width = width;\n    this.elementType = elementType;\n  }\n\n  /**\n   * @returns a vector constructed from the values read from the buffer at the\n   * given byte offset\n   */\n  public read(buf: Uint8Array, offset: number): Vector {\n    const elements: Array<Scalar> = [];\n    for (let i = 0; i < this.width; i++) {\n      elements[i] = this.elementType.read(buf, offset);\n      offset += this.elementType.size;\n    }\n    return new Vector(elements);\n  }\n\n  public toString(): string {\n    return `vec${this.width}<${this.elementType}>`;\n  }\n\n  public get size(): number {\n    return this.elementType.size * this.width;\n  }\n\n  /** Constructs a Vector of this type with the given values */\n  public create(value: (number | bigint) | readonly (number | bigint)[]): Vector {\n    if (value instanceof Array) {\n      assert(value.length === this.width);\n    } else {\n      value = Array(this.width).fill(value);\n    }\n    return new Vector(value.map(v => this.elementType.create(v)));\n  }\n}\n\n// Maps a string representation of a vector type to vector type.\nconst vectorTypes = new Map<string, VectorType>();\n\nexport function TypeVec(width: number, elementType: ScalarType): VectorType {\n  const key = `${elementType.toString()} ${width}}`;\n  let ty = vectorTypes.get(key);\n  if (ty !== undefined) {\n    return ty;\n  }\n  ty = new VectorType(width, elementType);\n  vectorTypes.set(key, ty);\n  return ty;\n}\n\n/** MatrixType describes the type of WGSL Matrix. */\nexport class MatrixType {\n  readonly cols: number; // Number of columns in the Matrix\n  readonly rows: number; // Number of elements per column in the Matrix\n  readonly elementType: ScalarType; // Element type\n\n  constructor(cols: number, rows: number, elementType: ScalarType) {\n    this.cols = cols;\n    this.rows = rows;\n    assert(\n      elementType.kind === 'f32' ||\n        elementType.kind === 'f16' ||\n        elementType.kind === 'abstract-float',\n      \"MatrixType can only have elementType of 'f32' or 'f16' or 'abstract-float'\"\n    );\n    this.elementType = elementType;\n  }\n\n  /**\n   * @returns a Matrix constructed from the values read from the buffer at the\n   * given byte offset\n   */\n  public read(buf: Uint8Array, offset: number): Matrix {\n    const elements: Scalar[][] = [...Array(this.cols)].map(_ => [...Array(this.rows)]);\n    for (let c = 0; c < this.cols; c++) {\n      for (let r = 0; r < this.rows; r++) {\n        elements[c][r] = this.elementType.read(buf, offset);\n        offset += this.elementType.size;\n      }\n\n      // vec3 have one padding element, so need to skip in matrices\n      if (this.rows === 3) {\n        offset += this.elementType.size;\n      }\n    }\n    return new Matrix(elements);\n  }\n\n  public toString(): string {\n    return `mat${this.cols}x${this.rows}<${this.elementType}>`;\n  }\n\n  /** Constructs a Matrix of this type with the given values */\n  public create(value: (number | bigint) | readonly (number | bigint)[]): Matrix {\n    if (value instanceof Array) {\n      assert(value.length === this.cols * this.rows);\n    } else {\n      value = Array(this.cols * this.rows).fill(value);\n    }\n    const columns: (number | bigint)[][] = [];\n    for (let i = 0; i < this.cols; i++) {\n      const start = i * this.rows;\n      columns.push(value.slice(start, start + this.rows));\n    }\n    return new Matrix(columns.map(c => c.map(v => this.elementType.create(v))));\n  }\n}\n\n// Maps a string representation of a Matrix type to Matrix type.\nconst matrixTypes = new Map<string, MatrixType>();\n\nexport function TypeMat(cols: number, rows: number, elementType: ScalarType): MatrixType {\n  const key = `${elementType.toString()} ${cols} ${rows}`;\n  let ty = matrixTypes.get(key);\n  if (ty !== undefined) {\n    return ty;\n  }\n  ty = new MatrixType(cols, rows, elementType);\n  matrixTypes.set(key, ty);\n  return ty;\n}\n\n/** Type is a ScalarType, VectorType, or MatrixType. */\nexport type Type = ScalarType | VectorType | MatrixType;\n\n/** ArrayElementType infers the element type of the indexable type A */\ntype ArrayElementType<A> = A extends { [index: number]: infer T } ? T : never;\n\n/** Copy bytes from `buf` at `offset` into the working data, then read it out using `workingDataOut` */\nfunction valueFromBytes<A extends TypedArrayBufferView>(\n  workingDataOut: A,\n  buf: Uint8Array,\n  offset: number\n): ArrayElementType<A> {\n  for (let i = 0; i < workingDataOut.BYTES_PER_ELEMENT; ++i) {\n    workingDataU8[i] = buf[offset + i];\n  }\n  return workingDataOut[0] as ArrayElementType<A>;\n}\n\nexport const TypeAbstractInt = new ScalarType(\n  'abstract-int',\n  8,\n  (buf: Uint8Array, offset: number) => abstractInt(valueFromBytes(workingDataI64, buf, offset))\n);\nexport const TypeI32 = new ScalarType('i32', 4, (buf: Uint8Array, offset: number) =>\n  i32(valueFromBytes(workingDataI32, buf, offset))\n);\nexport const TypeU32 = new ScalarType('u32', 4, (buf: Uint8Array, offset: number) =>\n  u32(valueFromBytes(workingDataU32, buf, offset))\n);\nexport const TypeAbstractFloat = new ScalarType(\n  'abstract-float',\n  8,\n  (buf: Uint8Array, offset: number) => abstractFloat(valueFromBytes(workingDataF64, buf, offset))\n);\nexport const TypeF64 = new ScalarType('f64', 8, (buf: Uint8Array, offset: number) =>\n  f64(valueFromBytes(workingDataF64, buf, offset))\n);\nexport const TypeF32 = new ScalarType('f32', 4, (buf: Uint8Array, offset: number) =>\n  f32(valueFromBytes(workingDataF32, buf, offset))\n);\nexport const TypeI16 = new ScalarType('i16', 2, (buf: Uint8Array, offset: number) =>\n  i16(valueFromBytes(workingDataI16, buf, offset))\n);\nexport const TypeU16 = new ScalarType('u16', 2, (buf: Uint8Array, offset: number) =>\n  u16(valueFromBytes(workingDataU16, buf, offset))\n);\nexport const TypeF16 = new ScalarType('f16', 2, (buf: Uint8Array, offset: number) =>\n  f16Bits(valueFromBytes(workingDataU16, buf, offset))\n);\nexport const TypeI8 = new ScalarType('i8', 1, (buf: Uint8Array, offset: number) =>\n  i8(valueFromBytes(workingDataI8, buf, offset))\n);\nexport const TypeU8 = new ScalarType('u8', 1, (buf: Uint8Array, offset: number) =>\n  u8(valueFromBytes(workingDataU8, buf, offset))\n);\nexport const TypeBool = new ScalarType('bool', 4, (buf: Uint8Array, offset: number) =>\n  bool(valueFromBytes(workingDataU32, buf, offset) !== 0)\n);\n\n/** @returns the ScalarType from the ScalarKind */\nexport function scalarType(kind: ScalarKind): ScalarType {\n  switch (kind) {\n    case 'abstract-float':\n      return TypeAbstractFloat;\n    case 'f64':\n      return TypeF64;\n    case 'f32':\n      return TypeF32;\n    case 'f16':\n      return TypeF16;\n    case 'u32':\n      return TypeU32;\n    case 'u16':\n      return TypeU16;\n    case 'u8':\n      return TypeU8;\n    case 'abstract-int':\n      return TypeAbstractInt;\n    case 'i32':\n      return TypeI32;\n    case 'i16':\n      return TypeI16;\n    case 'i8':\n      return TypeI8;\n    case 'bool':\n      return TypeBool;\n  }\n}\n\n/** @returns the number of scalar (element) types of the given Type */\nexport function numElementsOf(ty: Type): number {\n  if (ty instanceof ScalarType) {\n    return 1;\n  }\n  if (ty instanceof VectorType) {\n    return ty.width;\n  }\n  if (ty instanceof MatrixType) {\n    return ty.cols * ty.rows;\n  }\n  throw new Error(`unhandled type ${ty}`);\n}\n\n/** @returns the scalar elements of the given Value */\nexport function elementsOf(value: Value): Scalar[] {\n  if (value instanceof Scalar) {\n    return [value];\n  }\n  if (value instanceof Vector) {\n    return value.elements;\n  }\n  if (value instanceof Matrix) {\n    return value.elements.flat();\n  }\n  throw new Error(`unhandled value ${value}`);\n}\n\n/** @returns the scalar (element) type of the given Type */\nexport function scalarTypeOf(ty: Type): ScalarType {\n  if (ty instanceof ScalarType) {\n    return ty;\n  }\n  if (ty instanceof VectorType) {\n    return ty.elementType;\n  }\n  if (ty instanceof MatrixType) {\n    return ty.elementType;\n  }\n  throw new Error(`unhandled type ${ty}`);\n}\n\n/** ScalarValue is the JS type that can be held by a Scalar */\ntype ScalarValue = boolean | number | bigint;\n\n/** Class that encapsulates a single scalar value of various types. */\nexport class Scalar {\n  readonly value: ScalarValue; // The scalar value\n  readonly type: ScalarType; // The type of the scalar\n\n  // The scalar value, packed in one or two 32-bit unsigned integers.\n  // Whether or not the bits1 is used depends on `this.type.size`.\n  readonly bits1: number;\n  readonly bits0: number;\n\n  public constructor(type: ScalarType, value: ScalarValue, bits1: number, bits0: number) {\n    this.value = value;\n    this.type = type;\n    this.bits1 = bits1;\n    this.bits0 = bits0;\n  }\n\n  /**\n   * Copies the scalar value to the buffer at the provided byte offset.\n   * @param buffer the destination buffer\n   * @param offset the offset in buffer, in units of `buffer`\n   */\n  public copyTo(buffer: TypedArrayBufferView, offset: number) {\n    assert(\n      this.type.kind !== 'abstract-int',\n      `Copying 'abstract-int' values to/from buffers is yet implemented`\n    );\n    assert(this.type.kind !== 'f64', `Copying f64 values to/from buffers is not defined`);\n    workingDataU32[1] = this.bits1;\n    workingDataU32[0] = this.bits0;\n    for (let i = 0; i < this.type.size; i++) {\n      buffer[offset + i] = workingDataU8[i];\n    }\n  }\n\n  /**\n   * @returns the WGSL representation of this scalar value\n   */\n  public wgsl(): string {\n    const withPoint = (x: number) => {\n      const str = `${x}`;\n      return str.indexOf('.') > 0 || str.indexOf('e') > 0 ? str : `${str}.0`;\n    };\n\n    switch (typeof this.value) {\n      case 'bigint':\n        if (this.type.kind === 'abstract-int') {\n          // WGSL parses negative numbers as a negated positive.\n          // This means '-9223372036854775808' parses as `-' &\n          // '9223372036854775808', so must be written as\n          // '(-9223372036854775807 - 1)' in WGSL, because '9223372036854775808'\n          // is not a valid AbstractInt.\n          if (this.value === -9223372036854775808n) {\n            return `(-9223372036854775807 - 1)`;\n          }\n          return `${this.value}`;\n        }\n        break;\n      case 'number':\n        if (!isFinite(this.value)) break;\n        switch (this.type.kind) {\n          case 'abstract-float':\n            return `${withPoint(this.value)}`;\n          case 'f64':\n            return `${withPoint(this.value)}`;\n          case 'f32':\n            return `${withPoint(this.value)}f`;\n          case 'f16':\n            return `${withPoint(this.value)}h`;\n          case 'u32':\n            return `${this.value}u`;\n          case 'i32':\n            return `i32(${this.value})`;\n        }\n        break;\n      case 'boolean':\n        return `${this.value}`;\n    }\n\n    throw new Error(\n      `scalar of value ${this.value} and type ${this.type} has no WGSL representation`\n    );\n  }\n\n  public toString(): string {\n    if (this.type.kind === 'bool') {\n      return Colors.bold(this.value.toString());\n    }\n    switch (this.value) {\n      case Infinity:\n      case -Infinity:\n        return Colors.bold(this.value.toString());\n      default: {\n        workingDataU32[1] = this.bits1;\n        workingDataU32[0] = this.bits0;\n        let hex = '';\n        for (let i = 0; i < this.type.size; ++i) {\n          hex = workingDataU8[i].toString(16).padStart(2, '0') + hex;\n        }\n        const n = this.value as Number;\n        if (n !== null && isFloatValue(this)) {\n          let str = this.value.toString();\n          str = str.indexOf('.') > 0 || str.indexOf('e') > 0 ? str : `${str}.0`;\n          switch (this.type.kind) {\n            case 'abstract-float':\n              return isSubnormalNumberF64(n.valueOf())\n                ? `${Colors.bold(str)} (0x${hex} subnormal)`\n                : `${Colors.bold(str)} (0x${hex})`;\n            case 'f64':\n              return isSubnormalNumberF64(n.valueOf())\n                ? `${Colors.bold(str)} (0x${hex} subnormal)`\n                : `${Colors.bold(str)} (0x${hex})`;\n            case 'f32':\n              return isSubnormalNumberF32(n.valueOf())\n                ? `${Colors.bold(str)} (0x${hex} subnormal)`\n                : `${Colors.bold(str)} (0x${hex})`;\n            case 'f16':\n              return isSubnormalNumberF16(n.valueOf())\n                ? `${Colors.bold(str)} (0x${hex} subnormal)`\n                : `${Colors.bold(str)} (0x${hex})`;\n            default:\n              unreachable(\n                `Printing of floating point kind ${this.type.kind} is not implemented...`\n              );\n          }\n        }\n        return `${Colors.bold(this.value.toString())} (0x${hex})`;\n      }\n    }\n  }\n}\n\nexport interface ScalarBuilder<T> {\n  (value: T): Scalar;\n}\n\n/** Create a Scalar of `type` by storing `value` as an element of `workingDataArray` and retrieving it.\n * The working data array *must* be an alias of `workingData`.\n */\nfunction scalarFromValue<A extends TypedArrayBufferView>(\n  type: ScalarType,\n  workingDataArray: A,\n  value: ArrayElementType<A>\n): Scalar {\n  // Clear all bits of the working data since `value` may be smaller; the upper bits should be 0.\n  workingDataU32[1] = 0;\n  workingDataU32[0] = 0;\n  workingDataArray[0] = value;\n  return new Scalar(type, workingDataArray[0], workingDataU32[1], workingDataU32[0]);\n}\n\n/** Create a Scalar of `type` by storing `value` as an element of `workingDataStoreArray` and\n * reinterpreting it as an element of `workingDataLoadArray`.\n * Both working data arrays *must* be aliases of `workingData`.\n */\nfunction scalarFromBits<A extends TypedArrayBufferView>(\n  type: ScalarType,\n  workingDataStoreArray: A,\n  workingDataLoadArray: TypedArrayBufferView,\n  bits: ArrayElementType<A>\n): Scalar {\n  // Clear all bits of the working data since `value` may be smaller; the upper bits should be 0.\n  workingDataU32[1] = 0;\n  workingDataU32[0] = 0;\n  workingDataStoreArray[0] = bits;\n  return new Scalar(type, workingDataLoadArray[0], workingDataU32[1], workingDataU32[0]);\n}\n\n/** Create an AbstractFloat from a numeric value, a JS `number`. */\nexport const abstractFloat = (value: number): Scalar =>\n  scalarFromValue(TypeAbstractFloat, workingDataF64, value);\n\n/** Create an f64 from a numeric value, a JS `number`. */\nexport const f64 = (value: number): Scalar => scalarFromValue(TypeF64, workingDataF64, value);\n\n/** Create an f32 from a numeric value, a JS `number`. */\nexport const f32 = (value: number): Scalar => scalarFromValue(TypeF32, workingDataF32, value);\n\n/** Create an f16 from a numeric value, a JS `number`. */\nexport const f16 = (value: number): Scalar => scalarFromValue(TypeF16, workingDataF16, value);\n\n/** Create an f32 from a bit representation, a uint32 represented as a JS `number`. */\nexport const f32Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeF32, workingDataU32, workingDataF32, bits);\n\n/** Create an f16 from a bit representation, a uint16 represented as a JS `number`. */\nexport const f16Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeF16, workingDataU16, workingDataF16, bits);\n\n/** Create an AbstractInt from a numeric value, a JS `bigint`. */\nexport const abstractInt = (value: bigint): Scalar =>\n  scalarFromValue(TypeAbstractInt, workingDataI64, value);\n\nexport const abstractIntBits = (bits: bigint): Scalar =>\n  scalarFromBits(TypeAbstractInt, workingDataU64, workingDataI64, bits);\n\n/** Create an i32 from a numeric value, a JS `number`. */\nexport const i32 = (value: number): Scalar => scalarFromValue(TypeI32, workingDataI32, value);\n\n/** Create an i16 from a numeric value, a JS `number`. */\nexport const i16 = (value: number): Scalar => scalarFromValue(TypeI16, workingDataI16, value);\n\n/** Create an i8 from a numeric value, a JS `number`. */\nexport const i8 = (value: number): Scalar => scalarFromValue(TypeI8, workingDataI8, value);\n\n/** Create an i32 from a bit representation, a uint32 represented as a JS `number`. */\nexport const i32Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeI32, workingDataU32, workingDataI32, bits);\n\n/** Create an i16 from a bit representation, a uint16 represented as a JS `number`. */\nexport const i16Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeI16, workingDataU16, workingDataI16, bits);\n\n/** Create an i8 from a bit representation, a uint8 represented as a JS `number`. */\nexport const i8Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeI8, workingDataU8, workingDataI8, bits);\n\n/** Create a u32 from a numeric value, a JS `number`. */\nexport const u32 = (value: number): Scalar => scalarFromValue(TypeU32, workingDataU32, value);\n\n/** Create a u16 from a numeric value, a JS `number`. */\nexport const u16 = (value: number): Scalar => scalarFromValue(TypeU16, workingDataU16, value);\n\n/** Create a u8 from a numeric value, a JS `number`. */\nexport const u8 = (value: number): Scalar => scalarFromValue(TypeU8, workingDataU8, value);\n\n/** Create an u32 from a bit representation, a uint32 represented as a JS `number`. */\nexport const u32Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeU32, workingDataU32, workingDataU32, bits);\n\n/** Create an u16 from a bit representation, a uint16 represented as a JS `number`. */\nexport const u16Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeU16, workingDataU16, workingDataU16, bits);\n\n/** Create an u8 from a bit representation, a uint8 represented as a JS `number`. */\nexport const u8Bits = (bits: number): Scalar =>\n  scalarFromBits(TypeU8, workingDataU8, workingDataU8, bits);\n\n/** Create a boolean value. */\nexport function bool(value: boolean): Scalar {\n  // WGSL does not support using 'bool' types directly in storage / uniform\n  // buffers, so instead we pack booleans in a u32, where 'false' is zero and\n  // 'true' is any non-zero value.\n  workingDataU32[0] = value ? 1 : 0;\n  workingDataU32[1] = 0;\n  return new Scalar(TypeBool, value, workingDataU32[1], workingDataU32[0]);\n}\n\n/** A 'true' literal value */\nexport const True = bool(true);\n\n/** A 'false' literal value */\nexport const False = bool(false);\n\n/**\n * Class that encapsulates a vector value.\n */\nexport class Vector {\n  readonly elements: Array<Scalar>;\n  readonly type: VectorType;\n\n  public constructor(elements: Array<Scalar>) {\n    if (elements.length < 2 || elements.length > 4) {\n      throw new Error(`vector element count must be between 2 and 4, got ${elements.length}`);\n    }\n    for (let i = 1; i < elements.length; i++) {\n      const a = elements[0].type;\n      const b = elements[i].type;\n      if (a !== b) {\n        throw new Error(\n          `cannot mix vector element types. Found elements with types '${a}' and '${b}'`\n        );\n      }\n    }\n    this.elements = elements;\n    this.type = TypeVec(elements.length, elements[0].type);\n  }\n\n  /**\n   * Copies the vector value to the Uint8Array buffer at the provided byte offset.\n   * @param buffer the destination buffer\n   * @param offset the byte offset within buffer\n   */\n  public copyTo(buffer: Uint8Array, offset: number) {\n    for (const element of this.elements) {\n      element.copyTo(buffer, offset);\n      offset += this.type.elementType.size;\n    }\n  }\n\n  /**\n   * @returns the WGSL representation of this vector value\n   */\n  public wgsl(): string {\n    const els = this.elements.map(v => v.wgsl()).join(', ');\n    return `vec${this.type.width}(${els})`;\n  }\n\n  public toString(): string {\n    return `${this.type}(${this.elements.map(e => e.toString()).join(', ')})`;\n  }\n\n  public get x() {\n    assert(0 < this.elements.length);\n    return this.elements[0];\n  }\n\n  public get y() {\n    assert(1 < this.elements.length);\n    return this.elements[1];\n  }\n\n  public get z() {\n    assert(2 < this.elements.length);\n    return this.elements[2];\n  }\n\n  public get w() {\n    assert(3 < this.elements.length);\n    return this.elements[3];\n  }\n}\n\n/** Helper for constructing a new two-element vector with the provided values */\nexport function vec2(x: Scalar, y: Scalar) {\n  return new Vector([x, y]);\n}\n\n/** Helper for constructing a new three-element vector with the provided values */\nexport function vec3(x: Scalar, y: Scalar, z: Scalar) {\n  return new Vector([x, y, z]);\n}\n\n/** Helper for constructing a new four-element vector with the provided values */\nexport function vec4(x: Scalar, y: Scalar, z: Scalar, w: Scalar) {\n  return new Vector([x, y, z, w]);\n}\n\n/**\n * Helper for constructing Vectors from arrays of numbers\n *\n * @param v array of numbers to be converted, must contain 2, 3 or 4 elements\n * @param op function to convert from number to Scalar, e.g. 'f32`\n */\nexport function toVector(v: readonly number[], op: (n: number) => Scalar): Vector {\n  switch (v.length) {\n    case 2:\n      return vec2(op(v[0]), op(v[1]));\n    case 3:\n      return vec3(op(v[0]), op(v[1]), op(v[2]));\n    case 4:\n      return vec4(op(v[0]), op(v[1]), op(v[2]), op(v[3]));\n  }\n  unreachable(`input to 'toVector' must contain 2, 3, or 4 elements`);\n}\n\n/**\n * Class that encapsulates a Matrix value.\n */\nexport class Matrix {\n  readonly elements: Scalar[][];\n  readonly type: MatrixType;\n\n  public constructor(elements: Array<Array<Scalar>>) {\n    const num_cols = elements.length;\n    if (num_cols < 2 || num_cols > 4) {\n      throw new Error(`matrix cols count must be between 2 and 4, got ${num_cols}`);\n    }\n\n    const num_rows = elements[0].length;\n    if (!elements.every(c => c.length === num_rows)) {\n      throw new Error(`cannot mix matrix column lengths`);\n    }\n\n    if (num_rows < 2 || num_rows > 4) {\n      throw new Error(`matrix rows count must be between 2 and 4, got ${num_rows}`);\n    }\n\n    const elem_type = elements[0][0].type;\n    if (!elements.every(c => c.every(r => objectEquals(r.type, elem_type)))) {\n      throw new Error(`cannot mix matrix element types`);\n    }\n\n    this.elements = elements;\n    this.type = TypeMat(num_cols, num_rows, elem_type);\n  }\n\n  /**\n   * Copies the matrix value to the Uint8Array buffer at the provided byte offset.\n   * @param buffer the destination buffer\n   * @param offset the byte offset within buffer\n   */\n  public copyTo(buffer: Uint8Array, offset: number) {\n    for (let i = 0; i < this.type.cols; i++) {\n      for (let j = 0; j < this.type.rows; j++) {\n        this.elements[i][j].copyTo(buffer, offset);\n        offset += this.type.elementType.size;\n      }\n\n      // vec3 have one padding element, so need to skip in matrices\n      if (this.type.rows === 3) {\n        offset += this.type.elementType.size;\n      }\n    }\n  }\n\n  /**\n   * @returns the WGSL representation of this matrix value\n   */\n  public wgsl(): string {\n    const els = this.elements.flatMap(c => c.map(r => r.wgsl())).join(', ');\n    return `mat${this.type.cols}x${this.type.rows}(${els})`;\n  }\n\n  public toString(): string {\n    return `${this.type}(${this.elements.map(c => c.join(', ')).join(', ')})`;\n  }\n}\n\n/**\n * Helper for constructing Matrices from arrays of numbers\n *\n * @param m array of array of numbers to be converted, all Array of number must\n *          be of the same length. All Arrays must have 2, 3, or 4 elements.\n * @param op function to convert from number to Scalar, e.g. 'f32`\n */\nexport function toMatrix(m: ROArrayArray<number>, op: (n: number) => Scalar): Matrix {\n  const cols = m.length;\n  const rows = m[0].length;\n  const elements: Scalar[][] = [...Array<Scalar[]>(cols)].map(_ => [...Array<Scalar>(rows)]);\n  for (let i = 0; i < cols; i++) {\n    for (let j = 0; j < rows; j++) {\n      elements[i][j] = op(m[i][j]);\n    }\n  }\n\n  return new Matrix(elements);\n}\n\n/** Value is a Scalar or Vector value. */\nexport type Value = Scalar | Vector | Matrix;\n\nexport type SerializedValueScalar = {\n  kind: 'scalar';\n  type: ScalarKind;\n  value: boolean | number;\n};\n\nexport type SerializedValueVector = {\n  kind: 'vector';\n  type: ScalarKind;\n  value: boolean[] | readonly number[];\n};\n\nexport type SerializedValueMatrix = {\n  kind: 'matrix';\n  type: ScalarKind;\n  value: ROArrayArray<number>;\n};\n\nenum SerializedScalarKind {\n  AbstractFloat,\n  F64,\n  F32,\n  F16,\n  U32,\n  U16,\n  U8,\n  I32,\n  I16,\n  I8,\n  Bool,\n  AbstractInt,\n}\n\n/** serializeScalarKind() serializes a ScalarKind to a BinaryStream */\nfunction serializeScalarKind(s: BinaryStream, v: ScalarKind) {\n  switch (v) {\n    case 'abstract-float':\n      s.writeU8(SerializedScalarKind.AbstractFloat);\n      return;\n    case 'f64':\n      s.writeU8(SerializedScalarKind.F64);\n      return;\n    case 'f32':\n      s.writeU8(SerializedScalarKind.F32);\n      return;\n    case 'f16':\n      s.writeU8(SerializedScalarKind.F16);\n      return;\n    case 'u32':\n      s.writeU8(SerializedScalarKind.U32);\n      return;\n    case 'u16':\n      s.writeU8(SerializedScalarKind.U16);\n      return;\n    case 'u8':\n      s.writeU8(SerializedScalarKind.U8);\n      return;\n    case 'abstract-int':\n      s.writeU8(SerializedScalarKind.AbstractInt);\n      return;\n    case 'i32':\n      s.writeU8(SerializedScalarKind.I32);\n      return;\n    case 'i16':\n      s.writeU8(SerializedScalarKind.I16);\n      return;\n    case 'i8':\n      s.writeU8(SerializedScalarKind.I8);\n      return;\n    case 'bool':\n      s.writeU8(SerializedScalarKind.Bool);\n      return;\n  }\n  unreachable(`Do not know what to write scalar kind = ${v}`);\n}\n\n/** deserializeScalarKind() deserializes a ScalarKind from a BinaryStream */\nfunction deserializeScalarKind(s: BinaryStream): ScalarKind {\n  const kind = s.readU8();\n  switch (kind) {\n    case SerializedScalarKind.AbstractFloat:\n      return 'abstract-float';\n    case SerializedScalarKind.F64:\n      return 'f64';\n    case SerializedScalarKind.F32:\n      return 'f32';\n    case SerializedScalarKind.F16:\n      return 'f16';\n    case SerializedScalarKind.U32:\n      return 'u32';\n    case SerializedScalarKind.U16:\n      return 'u16';\n    case SerializedScalarKind.U8:\n      return 'u8';\n    case SerializedScalarKind.AbstractInt:\n      return 'abstract-int';\n    case SerializedScalarKind.I32:\n      return 'i32';\n    case SerializedScalarKind.I16:\n      return 'i16';\n    case SerializedScalarKind.I8:\n      return 'i8';\n    case SerializedScalarKind.Bool:\n      return 'bool';\n    default:\n      unreachable(`invalid serialized ScalarKind: ${kind}`);\n  }\n}\n\nenum SerializedValueKind {\n  Scalar,\n  Vector,\n  Matrix,\n}\n\n/** serializeValue() serializes a Value to a BinaryStream */\nexport function serializeValue(s: BinaryStream, v: Value) {\n  const serializeScalar = (scalar: Scalar, kind: ScalarKind) => {\n    switch (typeof scalar.value) {\n      case 'number':\n        switch (kind) {\n          case 'abstract-float':\n            s.writeF64(scalar.value);\n            return;\n          case 'f64':\n            s.writeF64(scalar.value);\n            return;\n          case 'f32':\n            s.writeF32(scalar.value);\n            return;\n          case 'f16':\n            s.writeF16(scalar.value);\n            return;\n          case 'u32':\n            s.writeU32(scalar.value);\n            return;\n          case 'u16':\n            s.writeU16(scalar.value);\n            return;\n          case 'u8':\n            s.writeU8(scalar.value);\n            return;\n          case 'i32':\n            s.writeI32(scalar.value);\n            return;\n          case 'i16':\n            s.writeI16(scalar.value);\n            return;\n          case 'i8':\n            s.writeI8(scalar.value);\n            return;\n        }\n        break;\n      case 'bigint':\n        switch (kind) {\n          case 'abstract-int':\n            s.writeI64(scalar.value);\n            return;\n        }\n        break;\n      case 'boolean':\n        switch (kind) {\n          case 'bool':\n            s.writeBool(scalar.value);\n            return;\n        }\n        break;\n    }\n  };\n\n  if (v instanceof Scalar) {\n    s.writeU8(SerializedValueKind.Scalar);\n    serializeScalarKind(s, v.type.kind);\n    serializeScalar(v, v.type.kind);\n    return;\n  }\n  if (v instanceof Vector) {\n    s.writeU8(SerializedValueKind.Vector);\n    serializeScalarKind(s, v.type.elementType.kind);\n    s.writeU8(v.type.width);\n    for (const element of v.elements) {\n      serializeScalar(element, v.type.elementType.kind);\n    }\n    return;\n  }\n  if (v instanceof Matrix) {\n    s.writeU8(SerializedValueKind.Matrix);\n    serializeScalarKind(s, v.type.elementType.kind);\n    s.writeU8(v.type.cols);\n    s.writeU8(v.type.rows);\n    for (const column of v.elements) {\n      for (const element of column) {\n        serializeScalar(element, v.type.elementType.kind);\n      }\n    }\n    return;\n  }\n\n  unreachable(`unhandled value type: ${v}`);\n}\n\n/** deserializeValue() deserializes a Value from a BinaryStream */\nexport function deserializeValue(s: BinaryStream): Value {\n  const deserializeScalar = (kind: ScalarKind) => {\n    switch (kind) {\n      case 'abstract-float':\n        return abstractFloat(s.readF64());\n      case 'f64':\n        return f64(s.readF64());\n      case 'f32':\n        return f32(s.readF32());\n      case 'f16':\n        return f16(s.readF16());\n      case 'u32':\n        return u32(s.readU32());\n      case 'u16':\n        return u16(s.readU16());\n      case 'u8':\n        return u8(s.readU8());\n      case 'abstract-int':\n        return abstractInt(s.readI64());\n      case 'i32':\n        return i32(s.readI32());\n      case 'i16':\n        return i16(s.readI16());\n      case 'i8':\n        return i8(s.readI8());\n      case 'bool':\n        return bool(s.readBool());\n    }\n  };\n  const valueKind = s.readU8();\n  const scalarKind = deserializeScalarKind(s);\n  switch (valueKind) {\n    case SerializedValueKind.Scalar:\n      return deserializeScalar(scalarKind);\n    case SerializedValueKind.Vector: {\n      const width = s.readU8();\n      const scalars = new Array<Scalar>(width);\n      for (let i = 0; i < width; i++) {\n        scalars[i] = deserializeScalar(scalarKind);\n      }\n      return new Vector(scalars);\n    }\n    case SerializedValueKind.Matrix: {\n      const numCols = s.readU8();\n      const numRows = s.readU8();\n      const columns = new Array<Scalar[]>(numCols);\n      for (let c = 0; c < numCols; c++) {\n        columns[c] = new Array<Scalar>(numRows);\n        for (let i = 0; i < numRows; i++) {\n          columns[c][i] = deserializeScalar(scalarKind);\n        }\n      }\n      return new Matrix(columns);\n    }\n    default:\n      unreachable(`invalid serialized value kind: ${valueKind}`);\n  }\n}\n\n/** @returns if the Value is a float scalar type */\nexport function isFloatValue(v: Value): boolean {\n  return isFloatType(v.type);\n}\n\n/**\n * @returns if `ty` is an abstract numeric type.\n * @note this does not consider composite types.\n * Use elementType() if you want to test the element type.\n */\nexport function isAbstractType(ty: Type): boolean {\n  if (ty instanceof ScalarType) {\n    return ty.kind === 'abstract-float' || ty.kind === 'abstract-int';\n  }\n  return false;\n}\n\n/**\n * @returns if `ty` is a floating point type.\n * @note this does not consider composite types.\n * Use elementType() if you want to test the element type.\n */\nexport function isFloatType(ty: Type): boolean {\n  if (ty instanceof ScalarType) {\n    return (\n      ty.kind === 'abstract-float' || ty.kind === 'f64' || ty.kind === 'f32' || ty.kind === 'f16'\n    );\n  }\n  return false;\n}\n\n/// All floating-point scalar types\nexport const kAllFloatScalars = [TypeAbstractFloat, TypeF32, TypeF16] as const;\n\n/// All floating-point vec2 types\nexport const kAllFloatVector2 = [\n  TypeVec(2, TypeAbstractFloat),\n  TypeVec(2, TypeF32),\n  TypeVec(2, TypeF16),\n] as const;\n\n/// All floating-point vec3 types\nexport const kAllFloatVector3 = [\n  TypeVec(3, TypeAbstractFloat),\n  TypeVec(3, TypeF32),\n  TypeVec(3, TypeF16),\n] as const;\n\n/// All floating-point vec4 types\nexport const kAllFloatVector4 = [\n  TypeVec(4, TypeAbstractFloat),\n  TypeVec(4, TypeF32),\n  TypeVec(4, TypeF16),\n] as const;\n\n/// All floating-point vector types\nexport const kAllFloatVectors = [\n  ...kAllFloatVector2,\n  ...kAllFloatVector3,\n  ...kAllFloatVector4,\n] as const;\n\n/// All f16 floating-point scalar and vector types\nexport const kAllF16ScalarsAndVectors = [\n  TypeF16,\n  TypeVec(2, TypeF16),\n  TypeVec(3, TypeF16),\n  TypeVec(4, TypeF16),\n] as const;\n\n/// All floating-point scalar and vector types\nexport const kAllFloatScalarsAndVectors = [...kAllFloatScalars, ...kAllFloatVectors] as const;\n\n/// Abstract integer scalar type\nexport const kAbstractIntegerScalar = [TypeAbstractInt] as const;\n\n/// Abstract integer vec2 type\nexport const kAbstractIntegerVector2 = [TypeVec(2, TypeAbstractInt)] as const;\n\n/// Abstract integer vec3 type\nexport const kAbstractIntegerVector3 = [TypeVec(3, TypeAbstractInt)] as const;\n\n/// Abstract integer vec4 type\nexport const kAbstractIntegerVector4 = [TypeVec(4, TypeAbstractInt)] as const;\n\n/// All abstract integer scalar vector types\nexport const kAbstractIntegerVectors = [\n  ...kAbstractIntegerVector2,\n  ...kAbstractIntegerVector3,\n  ...kAbstractIntegerVector4,\n] as const;\n\n/// Abstract integer scalar and vector types\nexport const kAllAbstractIntegerScalarAndVectors = [\n  ...kAbstractIntegerScalar,\n  ...kAbstractIntegerVectors,\n] as const;\n\n// Abstract and concrete integer types are not grouped into an 'all' type,\n// because for many validation tests there is a valid conversion of\n// AbstractInt -> AbstractFloat, but not one for the concrete integers. Thus, an\n// AbstractInt literal will be a potentially valid input, whereas the concrete\n// integers will not be. For many tests the pattern is to have separate fixtures\n// for the things that might be valid and those that are never valid.\n\n/// All concrete integer scalar and vector types\nexport const kAllConcreteIntegerScalarsAndVectors = [\n  TypeI32,\n  TypeVec(2, TypeI32),\n  TypeVec(3, TypeI32),\n  TypeVec(4, TypeI32),\n  TypeU32,\n  TypeVec(2, TypeU32),\n  TypeVec(3, TypeU32),\n  TypeVec(4, TypeU32),\n] as const;\n\n/// All signed integer scalar and vector types\nexport const kAllSignedIntegerScalarsAndVectors = [\n  TypeI32,\n  TypeVec(2, TypeI32),\n  TypeVec(3, TypeI32),\n  TypeVec(4, TypeI32),\n] as const;\n\n/// All unsigned integer scalar and vector types\nexport const kAllUnsignedIntegerScalarsAndVectors = [\n  TypeU32,\n  TypeVec(2, TypeU32),\n  TypeVec(3, TypeU32),\n  TypeVec(4, TypeU32),\n] as const;\n\n/// All floating-point and integer scalar and vector types\nexport const kAllFloatAndConcreteIntegerScalarsAndVectors = [\n  ...kAllFloatScalarsAndVectors,\n  ...kAllConcreteIntegerScalarsAndVectors,\n] as const;\n\n/// All floating-point and signed integer scalar and vector types\nexport const kAllFloatAndSignedIntegerScalarsAndVectors = [\n  ...kAllFloatScalarsAndVectors,\n  ...kAllSignedIntegerScalarsAndVectors,\n] as const;\n\n/** @returns the inner element type of the given type */\nexport function elementType(t: ScalarType | VectorType | MatrixType) {\n  if (t instanceof ScalarType) {\n    return t;\n  }\n  return t.elementType;\n}\n"],"mappings":"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"}
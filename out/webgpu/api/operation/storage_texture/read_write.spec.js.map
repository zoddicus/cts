{"version":3,"file":"read_write.spec.js","names":["description","makeTestGroup","assert","unreachable","kColorTextureFormats","kTextureFormatInfo","GPUTest","align","kShaderStagesForReadWriteStorageTexture","F","GetInitialData","storageTexture","format","bytesPerBlock","undefined","width","height","arrayLayers","depthOrArrayLayers","initialData","ArrayBuffer","initialTypedData","GetTypedArrayBuffer","z","y","x","index","arrayBuffer","Int32Array","Uint32Array","Float32Array","Uint8Array","GetExpectedData","shaderStage","bytesPerRowAlignment","itemsPerRow","expectedData","expectedTypedData","expectedIndex","initialIndex","RecordCommandsToTransform","device","commandEncoder","rwTexture","isArray","textureDeclaration","vertexShader","fragmentShader","renderPipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","fragment","targets","primitive","topology","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","dummyColorTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","renderPassEncoder","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","setPipeline","setBindGroup","draw","end","computeShader","computePipeline","createComputePipeline","compute","computePassEncoder","beginComputePass","dispatchWorkgroups","test","desc","params","u","combine","filter","p","color","readWriteStorage","fn","t","kWidth","kHeight","kTextureSize","COPY_SRC","COPY_DST","STORAGE_BINDING","queue","writeTexture","texture","bytesPerRow","rowsPerImage","createCommandEncoder","readbackBuffer","createBuffer","byteLength","GPUBufferUsage","copyTextureToBuffer","buffer","submit","finish","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/storage_texture/read_write.spec.ts"],"sourcesContent":["export const description = `\nTests for the behavior of read-write storage textures.\n\nTODO:\n- Test resource usage transitions with read-write storage textures\n- Test 1D and 3D textures\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kColorTextureFormats, kTextureFormatInfo } from '../../../format_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kShaderStagesForReadWriteStorageTexture = ['fragment', 'compute'] as const;\ntype ShaderStageForReadWriteStorageTexture =\n  (typeof kShaderStagesForReadWriteStorageTexture)[number];\n\nclass F extends GPUTest {\n  GetInitialData(storageTexture: GPUTexture): ArrayBuffer {\n    const format = storageTexture.format;\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const arrayLayers = storageTexture.depthOrArrayLayers;\n    const initialData = new ArrayBuffer(bytesPerBlock * width * height * arrayLayers);\n    const initialTypedData = this.GetTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < arrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const index = z * width * height + y * width + x;\n          switch (format) {\n            case 'r32sint':\n              initialTypedData[index] = (index & 1 ? 1 : -1) * (2 * index + 1);\n              break;\n            case 'r32uint':\n              initialTypedData[index] = 2 * index + 1;\n              break;\n            case 'r32float':\n              initialTypedData[index] = (2 * index + 1) / 10.0;\n              break;\n          }\n        }\n      }\n    }\n    return initialData;\n  }\n\n  GetTypedArrayBuffer(arrayBuffer: ArrayBuffer, format: GPUTextureFormat) {\n    switch (format) {\n      case 'r32sint':\n        return new Int32Array(arrayBuffer);\n      case 'r32uint':\n        return new Uint32Array(arrayBuffer);\n      case 'r32float':\n        return new Float32Array(arrayBuffer);\n      default:\n        unreachable();\n        return new Uint8Array(arrayBuffer);\n    }\n  }\n\n  GetExpectedData(\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    storageTexture: GPUTexture,\n    initialData: ArrayBuffer\n  ): ArrayBuffer {\n    const format = storageTexture.format;\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const arrayLayers = storageTexture.depthOrArrayLayers;\n    const bytesPerRowAlignment = align(bytesPerBlock * width, 256);\n    const itemsPerRow = bytesPerRowAlignment / bytesPerBlock;\n\n    const expectedData = new ArrayBuffer(\n      bytesPerRowAlignment * (height * arrayLayers - 1) + bytesPerBlock * width\n    );\n    const expectedTypedData = this.GetTypedArrayBuffer(expectedData, format);\n    const initialTypedData = this.GetTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < arrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const expectedIndex = z * itemsPerRow * height + y * itemsPerRow + x;\n          switch (shaderStage) {\n            case 'compute': {\n              // In the compute shader we flip the texture along the diagonal.\n              const initialIndex =\n                (arrayLayers - 1 - z) * width * height + (height - 1 - y) * width + (width - 1 - x);\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex];\n              break;\n            }\n            case 'fragment': {\n              // In the fragment shader we double the original texel value of the read-write storage\n              // texture.\n              const initialIndex = z * width * height + y * width + x;\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex] * 2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return expectedData;\n  }\n\n  RecordCommandsToTransform(\n    device: GPUDevice,\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    commandEncoder: GPUCommandEncoder,\n    rwTexture: GPUTexture\n  ) {\n    const isArray = rwTexture.depthOrArrayLayers > 1;\n    const textureDeclaration = `\n    @group(0) @binding(0) var rwTexture:\n    texture_storage_2d${isArray ? '_array' : ''}<${rwTexture.format}, read_write>;\n    `;\n\n    switch (shaderStage) {\n      case 'fragment': {\n        const vertexShader = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4f {\n            var pos = array(\n              vec2f(-1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f( 1.0,  1.0));\n            return vec4f(pos[VertexIndex], 0.0, 1.0);\n        }\n        `;\n        const fragmentShader = `\n        ${textureDeclaration}\n        @fragment\n        fn main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {\n          let textureCoord = vec2u(fragCoord.xy);\n\n          for (var z = 0; z < ${rwTexture.depthOrArrayLayers}; z++) {\n            let initialValue = textureLoad(rwTexture, textureCoord${isArray ? ', z' : ''});\n            let outputValue = initialValue * 2;\n            textureStore(rwTexture, textureCoord, ${isArray ? 'z, ' : ''}outputValue);\n          }\n\n          return vec4f(0.0, 1.0, 0.0, 1.0);\n        }\n        `;\n        const renderPipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: {\n            module: device.createShaderModule({\n              code: vertexShader,\n            }),\n          },\n          fragment: {\n            module: device.createShaderModule({\n              code: fragmentShader,\n            }),\n            targets: [\n              {\n                format: 'rgba8unorm',\n              },\n            ],\n          },\n          primitive: {\n            topology: 'triangle-list',\n          },\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n\n        const dummyColorTexture = device.createTexture({\n          size: [rwTexture.width, rwTexture.height, 1],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          format: 'rgba8unorm',\n        });\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: dummyColorTexture.createView(),\n              loadOp: 'clear',\n              clearValue: { r: 0, g: 0, b: 0, a: 0 },\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        renderPassEncoder.draw(6);\n        renderPassEncoder.end();\n        break;\n      }\n      case 'compute': {\n        const computeShader = `\n        ${textureDeclaration}\n        @compute\n        @workgroup_size(${rwTexture.width}, ${rwTexture.height}, ${rwTexture.depthOrArrayLayers})\n        fn main(@builtin(local_invocation_id) invocationID: vec3u) {\n          let dimension = textureDimensions(rwTexture);\n\n          let initialIndex = vec2u(\n            dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y);\n          let initialValue = textureLoad(\n            rwTexture,\n            initialIndex${isArray ? ', textureNumLayers(rwTexture) - 1u - invocationID.z' : ''});\n\n          textureBarrier();\n\n          textureStore(rwTexture, invocationID.xy, ${\n            isArray ? 'invocationID.z, ' : ''\n          }initialValue);\n        }`;\n\n        const computePipeline = device.createComputePipeline({\n          compute: {\n            module: device.createShaderModule({\n              code: computeShader,\n            }),\n          },\n          layout: 'auto',\n        });\n        const bindGroup = device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, bindGroup);\n        computePassEncoder.dispatchWorkgroups(1);\n        computePassEncoder.end();\n        break;\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic')\n  .desc(\n    `The basic functionality tests for read-write storage textures. In the test we read data from\n    the read-write storage texture, do transforms and write the data back to the read-write storage\n    texture. textureBarrier() is also called in the tests using compute pipelines.`\n  )\n  .params(u =>\n    u\n      .combine('format', kColorTextureFormats)\n      .filter(p => kTextureFormatInfo[p.format].color?.readWriteStorage === true)\n      .combine('shaderStage', kShaderStagesForReadWriteStorageTexture)\n      .combine('arrayLayers', [1, 2] as const)\n  )\n  .fn(t => {\n    const { format, shaderStage, arrayLayers } = t.params;\n\n    const kWidth = 16;\n    const kHeight = 8;\n    const kTextureSize = [kWidth, kHeight, arrayLayers] as const;\n    const storageTexture = t.device.createTexture({\n      format,\n      size: kTextureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    const initialData = t.GetInitialData(storageTexture);\n    t.queue.writeTexture(\n      { texture: storageTexture },\n      initialData,\n      {\n        bytesPerRow: bytesPerBlock * kWidth,\n        rowsPerImage: kHeight,\n      },\n      kTextureSize\n    );\n\n    const commandEncoder = t.device.createCommandEncoder();\n\n    t.RecordCommandsToTransform(t.device, shaderStage, commandEncoder, storageTexture);\n\n    const expectedData = t.GetExpectedData(shaderStage, storageTexture, initialData);\n    const readbackBuffer = t.device.createBuffer({\n      size: expectedData.byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const bytesPerRow = align(bytesPerBlock * kWidth, 256);\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: storageTexture,\n      },\n      {\n        buffer: readbackBuffer,\n        bytesPerRow,\n        rowsPerImage: kHeight,\n      },\n      kTextureSize\n    );\n    t.queue.submit([commandEncoder.finish()]);\n\n    switch (format) {\n      case 'r32sint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Int32Array(expectedData));\n        break;\n      case 'r32uint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Uint32Array(expectedData));\n        break;\n      case 'r32float':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Float32Array(expectedData));\n        break;\n    }\n  });\n"],"mappings":"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"}
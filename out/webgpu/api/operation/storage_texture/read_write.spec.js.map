{"version":3,"file":"read_write.spec.js","names":["description","makeTestGroup","assert","unreachable","kTextureDimensions","kColorTextureFormats","kTextureFormatInfo","GPUTest","align","kShaderStagesForReadWriteStorageTexture","F","GetInitialData","storageTexture","format","bytesPerBlock","undefined","width","height","depthOrArrayLayers","initialData","ArrayBuffer","initialTypedData","GetTypedArrayBuffer","z","y","x","index","arrayBuffer","Int32Array","Uint32Array","Float32Array","Uint8Array","GetExpectedData","shaderStage","bytesPerRowAlignment","itemsPerRow","expectedData","expectedTypedData","expectedIndex","initialIndex","RecordCommandsToTransform","device","commandEncoder","rwTexture","declaration","dimension","textureDeclaration","vertexShader","textureLoadStoreCoord","fragmentShader","renderPipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","fragment","targets","primitive","topology","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","placeholderColorTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","trackForCleanup","renderPassEncoder","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","setPipeline","setBindGroup","draw","end","textureLoadCoord","textureStoreCoord","computeShader","computePipeline","createComputePipeline","compute","computePassEncoder","beginComputePass","dispatchWorkgroups","test","desc","params","u","combine","filter","p","color","readWriteStorage","unless","textureDimension","beforeAllSubcases","t","skipIfTextureFormatNotUsableAsStorageTexture","fn","kWidth","isCompatibility","textureSize","COPY_SRC","COPY_DST","STORAGE_BINDING","queue","writeTexture","texture","bytesPerRow","rowsPerImage","createCommandEncoder","readbackBuffer","createBuffer","byteLength","GPUBufferUsage","copyTextureToBuffer","buffer","submit","finish","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/storage_texture/read_write.spec.ts"],"sourcesContent":["export const description = `\nTests for the behavior of read-write storage textures.\n\nTODO:\n- Test resource usage transitions with read-write storage textures\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kTextureDimensions } from '../../../capability_info.js';\nimport { kColorTextureFormats, kTextureFormatInfo } from '../../../format_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kShaderStagesForReadWriteStorageTexture = ['fragment', 'compute'] as const;\ntype ShaderStageForReadWriteStorageTexture =\n  (typeof kShaderStagesForReadWriteStorageTexture)[number];\n\nclass F extends GPUTest {\n  GetInitialData(storageTexture: GPUTexture): ArrayBuffer {\n    const format = storageTexture.format;\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const initialData = new ArrayBuffer(bytesPerBlock * width * height * depthOrArrayLayers);\n    const initialTypedData = this.GetTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const index = z * width * height + y * width + x;\n          switch (format) {\n            case 'r32sint':\n              initialTypedData[index] = (index & 1 ? 1 : -1) * (2 * index + 1);\n              break;\n            case 'r32uint':\n              initialTypedData[index] = 2 * index + 1;\n              break;\n            case 'r32float':\n              initialTypedData[index] = (2 * index + 1) / 10.0;\n              break;\n          }\n        }\n      }\n    }\n    return initialData;\n  }\n\n  GetTypedArrayBuffer(arrayBuffer: ArrayBuffer, format: GPUTextureFormat) {\n    switch (format) {\n      case 'r32sint':\n        return new Int32Array(arrayBuffer);\n      case 'r32uint':\n        return new Uint32Array(arrayBuffer);\n      case 'r32float':\n        return new Float32Array(arrayBuffer);\n      default:\n        unreachable();\n        return new Uint8Array(arrayBuffer);\n    }\n  }\n\n  GetExpectedData(\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    storageTexture: GPUTexture,\n    initialData: ArrayBuffer\n  ): ArrayBuffer {\n    const format = storageTexture.format;\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const bytesPerRowAlignment = align(bytesPerBlock * width, 256);\n    const itemsPerRow = bytesPerRowAlignment / bytesPerBlock;\n\n    const expectedData = new ArrayBuffer(\n      bytesPerRowAlignment * (height * depthOrArrayLayers - 1) + bytesPerBlock * width\n    );\n    const expectedTypedData = this.GetTypedArrayBuffer(expectedData, format);\n    const initialTypedData = this.GetTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const expectedIndex = z * itemsPerRow * height + y * itemsPerRow + x;\n          switch (shaderStage) {\n            case 'compute': {\n              // In the compute shader we flip the texture along the diagonal.\n              const initialIndex =\n                (depthOrArrayLayers - 1 - z) * width * height +\n                (height - 1 - y) * width +\n                (width - 1 - x);\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex];\n              break;\n            }\n            case 'fragment': {\n              // In the fragment shader we double the original texel value of the read-write storage\n              // texture.\n              const initialIndex = z * width * height + y * width + x;\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex] * 2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return expectedData;\n  }\n\n  RecordCommandsToTransform(\n    device: GPUDevice,\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    commandEncoder: GPUCommandEncoder,\n    rwTexture: GPUTexture\n  ) {\n    let declaration = '';\n    switch (rwTexture.dimension) {\n      case '1d':\n        declaration = 'texture_storage_1d';\n        break;\n      case '2d':\n        declaration =\n          rwTexture.depthOrArrayLayers > 1 ? 'texture_storage_2d_array' : 'texture_storage_2d';\n        break;\n      case '3d':\n        declaration = 'texture_storage_3d';\n        break;\n    }\n    const textureDeclaration = `\n    @group(0) @binding(0) var rwTexture: ${declaration}<${rwTexture.format}, read_write>;\n    `;\n\n    switch (shaderStage) {\n      case 'fragment': {\n        const vertexShader = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4f {\n            var pos = array(\n              vec2f(-1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f( 1.0,  1.0));\n            return vec4f(pos[VertexIndex], 0.0, 1.0);\n        }\n        `;\n        let textureLoadStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadStoreCoord = 'textureCoord.x';\n            break;\n          case '2d':\n            textureLoadStoreCoord =\n              rwTexture.depthOrArrayLayers > 1 ? 'textureCoord, z' : 'textureCoord';\n            break;\n          case '3d':\n            textureLoadStoreCoord = 'vec3u(textureCoord, z)';\n            break;\n        }\n        const fragmentShader = `\n        ${textureDeclaration}\n        @fragment\n        fn main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {\n          let textureCoord = vec2u(fragCoord.xy);\n\n          for (var z = 0u; z < ${rwTexture.depthOrArrayLayers}; z++) {\n            let initialValue = textureLoad(rwTexture, ${textureLoadStoreCoord});\n            let outputValue = initialValue * 2;\n            textureStore(rwTexture, ${textureLoadStoreCoord}, outputValue);\n          }\n\n          return vec4f(0.0, 1.0, 0.0, 1.0);\n        }\n        `;\n        const renderPipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: {\n            module: device.createShaderModule({\n              code: vertexShader,\n            }),\n          },\n          fragment: {\n            module: device.createShaderModule({\n              code: fragmentShader,\n            }),\n            targets: [\n              {\n                format: 'rgba8unorm',\n              },\n            ],\n          },\n          primitive: {\n            topology: 'triangle-list',\n          },\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n\n        const placeholderColorTexture = device.createTexture({\n          size: [rwTexture.width, rwTexture.height, 1],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          format: 'rgba8unorm',\n        });\n        this.trackForCleanup(placeholderColorTexture);\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: placeholderColorTexture.createView(),\n              loadOp: 'clear',\n              clearValue: { r: 0, g: 0, b: 0, a: 0 },\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        renderPassEncoder.draw(6);\n        renderPassEncoder.end();\n        break;\n      }\n      case 'compute': {\n        let textureLoadCoord = '';\n        let textureStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadCoord = 'dimension - 1u - invocationID.x';\n            textureStoreCoord = 'invocationID.x';\n            break;\n          case '2d':\n            textureLoadCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y),\n                   textureNumLayers(rwTexture) - 1u - invocationID.z`\n                : `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y)`;\n            textureStoreCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? 'invocationID.xy, invocationID.z'\n                : 'invocationID.xy';\n            break;\n          case '3d':\n            textureLoadCoord = `\n              vec3u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y,\n                    dimension.z - 1u - invocationID.z)`;\n            textureStoreCoord = 'invocationID';\n            break;\n        }\n\n        const computeShader = `\n        ${textureDeclaration}\n        @compute\n        @workgroup_size(${rwTexture.width}, ${rwTexture.height}, ${rwTexture.depthOrArrayLayers})\n        fn main(@builtin(local_invocation_id) invocationID: vec3u) {\n          let dimension = textureDimensions(rwTexture);\n\n          let initialValue = textureLoad(rwTexture, ${textureLoadCoord});\n          textureBarrier();\n\n          textureStore(rwTexture, ${textureStoreCoord}, initialValue);\n        }`;\n\n        const computePipeline = device.createComputePipeline({\n          compute: {\n            module: device.createShaderModule({\n              code: computeShader,\n            }),\n          },\n          layout: 'auto',\n        });\n        const bindGroup = device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, bindGroup);\n        computePassEncoder.dispatchWorkgroups(1);\n        computePassEncoder.end();\n        break;\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic')\n  .desc(\n    `The basic functionality tests for read-write storage textures. In the test we read data from\n    the read-write storage texture, do transforms and write the data back to the read-write storage\n    texture. textureBarrier() is also called in the tests using compute pipelines.`\n  )\n  .params(u =>\n    u\n      .combine('format', kColorTextureFormats)\n      .filter(p => kTextureFormatInfo[p.format].color?.readWriteStorage === true)\n      .combine('shaderStage', kShaderStagesForReadWriteStorageTexture)\n      .combine('textureDimension', kTextureDimensions)\n      .combine('depthOrArrayLayers', [1, 2] as const)\n      .unless(p => p.textureDimension === '1d' && p.depthOrArrayLayers > 1)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotUsableAsStorageTexture(t.params.format);\n  })\n  .fn(t => {\n    const { format, shaderStage, textureDimension, depthOrArrayLayers } = t.params;\n\n    // In compatibility mode the lowest maxComputeInvocationsPerWorkgroup is 128 vs non-compat which is 256\n    // So in non-compat we get 16 * 8 * 2, vs compat where we get 8 * 8 * 2\n    const kWidth = t.isCompatibility ? 8 : 16;\n    const height = textureDimension === '1d' ? 1 : 8;\n    const textureSize = [kWidth, height, depthOrArrayLayers] as const;\n    const storageTexture = t.device.createTexture({\n      format,\n      dimension: textureDimension,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n    });\n    t.trackForCleanup(storageTexture);\n\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    const initialData = t.GetInitialData(storageTexture);\n    t.queue.writeTexture(\n      { texture: storageTexture },\n      initialData,\n      {\n        bytesPerRow: bytesPerBlock * kWidth,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n\n    const commandEncoder = t.device.createCommandEncoder();\n\n    t.RecordCommandsToTransform(t.device, shaderStage, commandEncoder, storageTexture);\n\n    const expectedData = t.GetExpectedData(shaderStage, storageTexture, initialData);\n    const readbackBuffer = t.device.createBuffer({\n      size: expectedData.byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(readbackBuffer);\n    const bytesPerRow = align(bytesPerBlock * kWidth, 256);\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: storageTexture,\n      },\n      {\n        buffer: readbackBuffer,\n        bytesPerRow,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n    t.queue.submit([commandEncoder.finish()]);\n\n    switch (format) {\n      case 'r32sint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Int32Array(expectedData));\n        break;\n      case 'r32uint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Uint32Array(expectedData));\n        break;\n      case 'r32float':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Float32Array(expectedData));\n        break;\n    }\n  });\n"],"mappings":"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"}
{"version":3,"file":"uncapturederror.spec.js","names":["description","Fixture","makeTestGroup","g","test","desc","unimplemented"],"sources":["../../../../src/webgpu/api/operation/uncapturederror.spec.ts"],"sourcesContent":["export const description = `\nTests for GPUDevice.onuncapturederror.\n`;\n\nimport { Fixture } from '../../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\n\nexport const g = makeTestGroup(Fixture);\n\ng.test('constructor')\n  .desc(\n    `GPUUncapturedErrorEvent constructor options (also tests constructing GPUOutOfMemoryError/GPUValidationError)`\n  )\n  .unimplemented();\n\ng.test('iff_uncaptured')\n  .desc(\n    `{validation, out-of-memory} error should fire uncapturederror iff not captured by a scope.`\n  )\n  .unimplemented();\n\ng.test('only_original_device_is_event_target')\n  .desc(\n    `Original GPUDevice objects are EventTargets and have onuncapturederror, but\ndeserialized GPUDevices do not.`\n  )\n  .unimplemented();\n\ng.test('uncapturederror_from_non_originating_thread')\n  .desc(\n    `Uncaptured errors on any thread should always propagate to the original GPUDevice object\n(since deserialized ones don't have EventTarget/onuncapturederror).`\n  )\n  .unimplemented();\n"],"mappings":";AAAA;AAAA,GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,OAAO,QAAQ,sCAAsC;AAC9D,SAASC,aAAa,QAAQ,yCAAyC;;AAEvE,OAAO,MAAMC,CAAC,GAAGD,aAAa,CAACD,OAAO,CAAC;;AAEvCE,CAAC,CAACC,IAAI,CAAC,aAAa,CAAC;AAClBC,IAAI;AACF,8GAA6G,CAC/G;;AACAC,aAAa,EAAE;;AAElBH,CAAC,CAACC,IAAI,CAAC,gBAAgB,CAAC;AACrBC,IAAI;AACF,4FAA2F,CAC7F;;AACAC,aAAa,EAAE;;AAElBH,CAAC,CAACC,IAAI,CAAC,sCAAsC,CAAC;AAC3CC,IAAI;AACF;AACL,gCAAgC,CAC7B;;AACAC,aAAa,EAAE;;AAElBH,CAAC,CAACC,IAAI,CAAC,6CAA6C,CAAC;AAClDC,IAAI;AACF;AACL,oEAAoE,CACjE;;AACAC,aAAa,EAAE"}
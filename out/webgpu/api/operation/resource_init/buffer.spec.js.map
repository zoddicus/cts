{"version":3,"file":"buffer.spec.js","names":["makeTestGroup","unreachable","GPUConst","GPUTest","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mappable","expectGPUBufferValuesEqual","method","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","layout","compute","module","entryPoint","outputTexture","createTexture","format","size","usage","GPUTextureUsage","STORAGE_BINDING","trackForCleanup","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatchWorkgroups","end","queue","submit","finish","CheckBufferAndOutputTexture","CreateRenderPipelineForTest","vertexShaderModule","testVertexBuffer","renderPipelineDescriptor","vertex","fragment","createShaderModule","code","targets","primitive","topology","buffers","arrayStride","attributes","shaderLocation","createRenderPipeline","RecordInitializeTextureColor","texture","color","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","bufferSize","outputTextureSize","outputTextureColor","R","G","B","A","expectSingleColor","exp","expectedBufferData","Uint8Array","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","appliedOffset","createBuffer","copySize","writeData","i","writeBuffer","mapAsync","readData","getMappedRange","expect","unmap","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","baseArrayLayer","baseMipLevel","r","b","a","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","STORAGE","renderPipeline","vertexBuffer","VERTEX","setVertexBuffer","draw","indexBuffer","INDEX","setIndexBuffer","drawIndexed","test_indexed_draw","kDrawIndirectParametersSize","kDrawIndexedIndirectParametersSize","indirectBuffer","INDIRECT","undefined","drawIndexedIndirect","drawIndirect","kDispatchIndirectParametersSize","dispatchWorkgroupsIndirect"],"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { PerTexelComponent } from '../../../util/texture/texel_data.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): void {\n    const mappable = bufferUsage & GPUBufferUsage.MAP_READ;\n    this.expectGPUBufferValuesEqual(buffer, expectedData, 0, { method: mappable ? 'map' : 'copy' });\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING,\n    });\n    this.trackForCleanup(outputTexture);\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchWorkgroups(1);\n    computePass.end();\n    this.queue.submit([encoder.finish()]);\n\n    this.CheckBufferAndOutputTexture(buffer, boundBufferSize + bufferOffset, outputTexture);\n  }\n\n  CreateRenderPipelineForTest(\n    vertexShaderModule: GPUShaderModule,\n    testVertexBuffer: boolean\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: vertexShaderModule,\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        @fragment\n        fn main(@location(0) i_color : vec4<f32>) -> @location(0) vec4<f32> {\n            return i_color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    };\n    if (testVertexBuffer) {\n      renderPipelineDescriptor.vertex.buffers = [\n        {\n          arrayStride: 16,\n          attributes: [{ format: 'float32x4', offset: 0, shaderLocation: 0 }],\n        },\n      ];\n    }\n\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  RecordInitializeTextureColor(\n    encoder: GPUCommandEncoder,\n    texture: GPUTexture,\n    color: GPUColor\n  ): void {\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView(),\n          clearValue: color,\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.end();\n  }\n\n  CheckBufferAndOutputTexture(\n    buffer: GPUBuffer,\n    bufferSize: number,\n    outputTexture: GPUTexture,\n    outputTextureSize: [number, number, number] = [1, 1, 1],\n    outputTextureColor: PerTexelComponent<number> = { R: 0.0, G: 1.0, B: 0.0, A: 1.0 }\n  ): void {\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: outputTextureSize,\n      exp: outputTextureColor,\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    this.expectGPUBufferValuesEqual(buffer, expectedBufferData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(buffer);\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(buffer);\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(buffer);\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(buffer);\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(buffer);\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(buffer);\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const textureSize: [number, number, number] = [8, 8, 1];\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    t.trackForCleanup(dstTexture);\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', textureSize);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n    t.trackForCleanup(srcBuffer);\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(srcBuffer, srcBufferSize, dstTexture, textureSize, {\n      R: 0.0,\n      G: 0.0,\n      B: 0.0,\n      A: 0.0,\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n    t.trackForCleanup(dstBuffer);\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.device.createTexture({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n    t.trackForCleanup(srcTexture);\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.device.createBuffer({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(dstBuffer);\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            clearValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.end();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination buffer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n    t.trackForCleanup(buffer);\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  struct UBO {\n    value : vec4<u32>\n  };\n  @group(0) @binding(0) var<uniform> ubo : UBO;\n  @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  @compute @workgroup_size(1) fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n    t.trackForCleanup(buffer);\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n      value : vec4<u32>\n    };\n    @group(0) @binding(0) var<storage, read> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n    t.trackForCleanup(buffer);\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n      value : vec4<u32>\n    };\n    @group(0) @binding(0) var<storage, read_write> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('vertex_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a vertex buffer just after the creation of that\n  GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n      struct VertexOut {\n        @location(0) color : vec4<f32>,\n        @builtin(position) position : vec4<f32>,\n      };\n\n      @vertex fn main(@location(0) pos : vec4<f32>) -> VertexOut {\n        var output : VertexOut;\n        if (all(pos == vec4<f32>(0.0, 0.0, 0.0, 0.0))) {\n          output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        } else {\n          output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n        output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        return output;\n      }`,\n      }),\n      true\n    );\n\n    const bufferSize = 16 + bufferOffset;\n    const vertexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(vertexBuffer);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    t.trackForCleanup(outputTexture);\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer, bufferOffset);\n    renderPass.setPipeline(renderPipeline);\n    renderPass.draw(1);\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(vertexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('index_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as an index buffer just after the creation of that\nGPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>,\n      @builtin(position) position : vec4<f32>,\n    };\n\n    @vertex\n    fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOut {\n      var output : VertexOut;\n      if (VertexIndex == 0u) {\n        output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      } else {\n        output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    // The size of GPUBuffer must be at least 4.\n    const bufferSize = 4 + bufferOffset;\n    const indexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(indexBuffer);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    t.trackForCleanup(outputTexture);\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', bufferOffset, 4);\n    renderPass.drawIndexed(1);\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(indexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_draw_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for drawIndirect() or\ndrawIndexedIndirect() just after the creation of that GPUBuffer, all the contents in that GPUBuffer\nhave been initialized to 0.`\n  )\n  .params(u =>\n    u.combine('test_indexed_draw', [true, false]).beginSubcases().combine('bufferOffset', [0, 16])\n  )\n  .fn(t => {\n    const { test_indexed_draw, bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>,\n      @builtin(position) position : vec4<f32>,\n    };\n\n    @vertex fn main() -> VertexOut {\n      var output : VertexOut;\n      output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    const kDrawIndirectParametersSize = 16;\n    const kDrawIndexedIndirectParametersSize = 20;\n    const bufferSize =\n      Math.max(kDrawIndirectParametersSize, kDrawIndexedIndirectParametersSize) + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    t.trackForCleanup(indirectBuffer);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    t.trackForCleanup(outputTexture);\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n\n    let indexBuffer = undefined;\n    if (test_indexed_draw) {\n      indexBuffer = t.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.INDEX,\n      });\n      t.trackForCleanup(indexBuffer);\n      renderPass.setIndexBuffer(indexBuffer, 'uint16');\n      renderPass.drawIndexedIndirect(indirectBuffer, bufferOffset);\n    } else {\n      renderPass.drawIndirect(indirectBuffer, bufferOffset);\n    }\n\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the render pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_dispatch_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for dispatchWorkgroupsIndirect() just\n    after the creation of that GPUBuffer, all the contents in that GPUBuffer have been initialized\n    to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const computePipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n        @group(0) @binding(0) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n        @compute @workgroup_size(1) fn main() {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }`,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const kDispatchIndirectParametersSize = 12;\n    const bufferSize = kDispatchIndirectParametersSize + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n    t.trackForCleanup(indirectBuffer);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.STORAGE_BINDING,\n    });\n    t.trackForCleanup(outputTexture);\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    // The indirect buffer should be lazily cleared to 0, so we actually don't execute the compute\n    // shader and the output texture should keep its original color (green).\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchWorkgroupsIndirect(indirectBuffer, bufferOffset);\n    computePass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the compute pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n"],"mappings":";AAAA;AAAA,GAAA,SAASA,aAAa,QAAQ,4CAA4C,CAC1E,SAASC,WAAW,QAAQ,iCAAiC,CAC7D,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,OAAO,QAAQ,sBAAsB;AAC9C,SAASC,oBAAoB,QAAQ,iCAAiC;;;AAGtE,OAAO,MAAMC,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,MAAMC,eAAe,GAAG,CAACJ,QAAQ,CAACK,OAAO,CAACC,IAAI,EAAEN,QAAQ,CAACK,OAAO,CAACE,KAAK,CAAC;AACvE,MAAMC,qCAAqC,GAAG;AAC5CR,QAAQ,CAACS,WAAW,CAACC,QAAQ,GAAGV,QAAQ,CAACS,WAAW,CAACE,QAAQ;AAC7DX,QAAQ,CAACS,WAAW,CAACG,QAAQ,GAAGZ,QAAQ,CAACS,WAAW,CAACI,SAAS;AAC9Db,QAAQ,CAACS,WAAW,CAACG,QAAQ,CAC9B;;;AAED,MAAME,CAAC,SAASb,OAAO,CAAC;EACtBc,yBAAyB,CAACC,OAAwB,EAAU;IAC1D,QAAQA,OAAO;MACb,KAAKC,UAAU,CAACX,IAAI;QAClB,OAAOY,cAAc,CAACR,QAAQ,GAAGQ,cAAc,CAACP,QAAQ;MAC1D,KAAKM,UAAU,CAACV,KAAK;QACnB,OAAOW,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACL,SAAS;MAC3D;QACEd,WAAW,EAAE;QACb,OAAO,CAAC,CAAC;;EAEf;;EAEAoB,qBAAqB;EACnBC,MAAiB;EACjBC,WAAgC;EAChCC,YAAwB;EAClB;IACN,MAAMC,QAAQ,GAAGF,WAAW,GAAGH,cAAc,CAACP,QAAQ;IACtD,IAAI,CAACa,0BAA0B,CAACJ,MAAM,EAAEE,YAAY,EAAE,CAAC,EAAE,EAAEG,MAAM,EAAEF,QAAQ,GAAG,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC;EACjG;;EAEAG,6BAA6B;EAC3BC,mBAAoC;EACpCP,MAAiB;EACjBQ,YAAoB;EACpBC,eAAuB;EACjB;IACN,MAAMC,eAAe,GAAG,IAAI,CAACC,MAAM,CAACC,qBAAqB,CAAC;MACxDC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACPC,MAAM,EAAER,mBAAmB;QAC3BS,UAAU,EAAE;MACd;IACF,CAAC,CAAC;IACF,MAAMC,aAAa,GAAG,IAAI,CAACN,MAAM,CAACO,aAAa,CAAC;MAC9CC,MAAM,EAAE,YAAY;MACpBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACfC,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAACC;IACpD,CAAC,CAAC;IACF,IAAI,CAACC,eAAe,CAACP,aAAa,CAAC;IACnC,MAAMQ,SAAS,GAAG,IAAI,CAACd,MAAM,CAACe,eAAe,CAAC;MAC5Cb,MAAM,EAAEH,eAAe,CAACiB,kBAAkB,CAAC,CAAC,CAAC;MAC7CC,OAAO,EAAE;MACP;QACEC,OAAO,EAAE,CAAC;QACVC,QAAQ,EAAE;UACR9B,MAAM;UACN+B,MAAM,EAAEvB,YAAY;UACpBY,IAAI,EAAEX;QACR;MACF,CAAC;MACD;QACEoB,OAAO,EAAE,CAAC;QACVC,QAAQ,EAAEb,aAAa,CAACe,UAAU;MACpC,CAAC;;IAEL,CAAC,CAAC;;IAEF,MAAMC,OAAO,GAAG,IAAI,CAACtB,MAAM,CAACuB,oBAAoB,EAAE;IAClD,MAAMC,WAAW,GAAGF,OAAO,CAACG,gBAAgB,EAAE;IAC9CD,WAAW,CAACE,YAAY,CAAC,CAAC,EAAEZ,SAAS,CAAC;IACtCU,WAAW,CAACG,WAAW,CAAC5B,eAAe,CAAC;IACxCyB,WAAW,CAACI,kBAAkB,CAAC,CAAC,CAAC;IACjCJ,WAAW,CAACK,GAAG,EAAE;IACjB,IAAI,CAACC,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;IAErC,IAAI,CAACC,2BAA2B,CAAC5C,MAAM,EAAES,eAAe,GAAGD,YAAY,EAAES,aAAa,CAAC;EACzF;;EAEA4B,2BAA2B;EACzBC,kBAAmC;EACnCC,gBAAyB;EACN;IACnB,MAAMC,wBAAqD,GAAG;MAC5DnC,MAAM,EAAE,MAAM;MACdoC,MAAM,EAAE;QACNlC,MAAM,EAAE+B,kBAAkB;QAC1B9B,UAAU,EAAE;MACd,CAAC;MACDkC,QAAQ,EAAE;QACRnC,MAAM,EAAE,IAAI,CAACJ,MAAM,CAACwC,kBAAkB,CAAC;UACrCC,IAAI,EAAG;AACjB;AACA;AACA;AACA;QACQ,CAAC,CAAC;QACFpC,UAAU,EAAE,MAAM;QAClBqC,OAAO,EAAE,CAAC,EAAElC,MAAM,EAAE,YAAY,CAAC,CAAC;MACpC,CAAC;MACDmC,SAAS,EAAE;QACTC,QAAQ,EAAE;MACZ;IACF,CAAC;IACD,IAAIR,gBAAgB,EAAE;MACpBC,wBAAwB,CAACC,MAAM,CAACO,OAAO,GAAG;MACxC;QACEC,WAAW,EAAE,EAAE;QACfC,UAAU,EAAE,CAAC,EAAEvC,MAAM,EAAE,WAAW,EAAEY,MAAM,EAAE,CAAC,EAAE4B,cAAc,EAAE,CAAC,CAAC,CAAC;MACpE,CAAC,CACF;;IACH;;IAEA,OAAO,IAAI,CAAChD,MAAM,CAACiD,oBAAoB,CAACZ,wBAAwB,CAAC;EACnE;;EAEAa,4BAA4B;EAC1B5B,OAA0B;EAC1B6B,OAAmB;EACnBC,KAAe;EACT;IACN,MAAMC,UAAU,GAAG/B,OAAO,CAACgC,eAAe,CAAC;MACzCC,gBAAgB,EAAE;MAChB;QACEC,IAAI,EAAEL,OAAO,CAAC9B,UAAU,EAAE;QAC1BoC,UAAU,EAAEL,KAAK;QACjBM,MAAM,EAAE,OAAO;QACfC,OAAO,EAAE;MACX,CAAC;;IAEL,CAAC,CAAC;IACFN,UAAU,CAACxB,GAAG,EAAE;EAClB;;EAEAI,2BAA2B;EACzB5C,MAAiB;EACjBuE,UAAkB;EAClBtD,aAAyB;EACzBuD,iBAA2C,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACvDC,kBAA6C,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;EAC5E;IACN,IAAI,CAACC,iBAAiB,CAAC7D,aAAa,EAAE,YAAY,EAAE;MAClDG,IAAI,EAAEoD,iBAAiB;MACvBO,GAAG,EAAEN;IACP,CAAC,CAAC;;IAEF,MAAMO,kBAAkB,GAAG,IAAIC,UAAU,CAACV,UAAU,CAAC;IACrD,IAAI,CAACnE,0BAA0B,CAACJ,MAAM,EAAEgF,kBAAkB,CAAC;EAC7D;AACF;;AAEA,OAAO,MAAME,CAAC,GAAGxG,aAAa,CAACgB,CAAC,CAAC;;AAEjCwF,CAAC,CAACC,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI;AACF;AACL,wEAAwE,CACrE;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACzDC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE1D,MAAM,CAAC,CAAC,GAAG0D,CAAC,CAACC,MAAM;EAC3B,MAAMnB,UAAU,GAAG,EAAE;EACrB,MAAMoB,aAAa,GAAG5D,MAAM,IAAI,CAAC,GAAGA,MAAM,GAAGwC,UAAU,GAAGxC,MAAM;;EAEhE,MAAM/B,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACR;EAClD,CAAC,CAAC;EACFmG,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAM6F,QAAQ,GAAG,EAAE;EACnB,MAAMC,SAAS,GAAG,IAAIb,UAAU,CAACY,QAAQ,CAAC;EAC1C,MAAM3F,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/C,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAE,EAAEE,CAAC,EAAE;IACjC7F,YAAY,CAACyF,aAAa,GAAGI,CAAC,CAAC,GAAGD,SAAS,CAACC,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC;EACxD;EACAN,CAAC,CAAChD,KAAK,CAACuD,WAAW,CAAChG,MAAM,EAAE2F,aAAa,EAAEG,SAAS,EAAE,CAAC,CAAC;;EAExDL,CAAC,CAACrF,0BAA0B,CAACJ,MAAM,EAAEE,YAAY,CAAC;AACpD,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,kBAAkB,CAAC;AACvBC,IAAI;AACF;AACL;AACA,oCAAoC,CACjC;;AACAM,MAAM,CAAC,CAAAJ,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,SAAS,EAAEvG,eAAe,CAAC,CAAC;AAClDwG,EAAE,CAAC,OAAMC,CAAC,KAAI;EACb,MAAM,EAAE7F,OAAO,CAAC,CAAC,GAAG6F,CAAC,CAACC,MAAM;;EAE5B,MAAMnB,UAAU,GAAG,EAAE;EACrB,MAAMtE,WAAW,GAAGwF,CAAC,CAAC9F,yBAAyB,CAACC,OAAO,CAAC;EACxD,MAAMI,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAMA,MAAM,CAACiG,QAAQ,CAACrG,OAAO,CAAC;EAC9B,MAAMsG,QAAQ,GAAG,IAAIjB,UAAU,CAACjF,MAAM,CAACmG,cAAc,EAAE,CAAC;EACxD,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,UAAU,EAAE,EAAEwB,CAAC,EAAE;IACnCN,CAAC,CAACW,MAAM,CAACF,QAAQ,CAACH,CAAC,CAAC,KAAK,CAAC,CAAC;EAC7B;EACA/F,MAAM,CAACqG,KAAK,EAAE;;EAEd,MAAMnG,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/CkB,CAAC,CAAC1F,qBAAqB,CAACC,MAAM,EAAEC,WAAW,EAAEC,YAAY,CAAC;AAC5D,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,oBAAoB,CAAC;AACzBC,IAAI;AACF;AACL;AACA,+BAA+B,CAC5B;;AACAM,MAAM,CAAC,CAAAJ,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,SAAS,EAAEvG,eAAe,CAAC,CAACsH,aAAa,EAAE,CAACf,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACjGC,EAAE,CAAC,OAAMC,CAAC,KAAI;EACb,MAAM,EAAE7F,OAAO,EAAEmC,MAAM,CAAC,CAAC,GAAG0D,CAAC,CAACC,MAAM;EACpC,MAAMnB,UAAU,GAAG,EAAE;EACrB,MAAMoB,aAAa,GAAG5D,MAAM,IAAI,CAAC,GAAGA,MAAM,GAAGwC,UAAU,GAAGxC,MAAM;;EAEhE,MAAM9B,WAAW,GAAGwF,CAAC,CAAC9F,yBAAyB,CAACC,OAAO,CAAC;EACxD,MAAMI,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAME,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/C;IACE,MAAMgC,OAAO,GAAG,EAAE;IAClB,MAAMvG,MAAM,CAACiG,QAAQ,CAACrG,OAAO,EAAE+F,aAAa,EAAEY,OAAO,CAAC;IACtD,MAAMC,UAAU,GAAG,IAAIvB,UAAU,CAACjF,MAAM,CAACmG,cAAc,CAACR,aAAa,EAAEY,OAAO,CAAC,CAAC;IAChF,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,OAAO,EAAE,EAAER,CAAC,EAAE;MAChCN,CAAC,CAACW,MAAM,CAACI,UAAU,CAACT,CAAC,CAAC,KAAK,CAAC,CAAC;MAC7B,IAAInG,OAAO,KAAKC,UAAU,CAACV,KAAK,EAAE;QAChCqH,UAAU,CAACT,CAAC,CAAC,GAAG7F,YAAY,CAACyF,aAAa,GAAGI,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC;MACzD;IACF;IACA/F,MAAM,CAACqG,KAAK,EAAE;EAChB;;EAEAZ,CAAC,CAAC1F,qBAAqB,CAACC,MAAM,EAAEC,WAAW,EAAEC,YAAY,CAAC;AAC5D,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,iCAAiC,CAAC;AACtCC,IAAI;AACF;AACL;AACA,0FAA0F,CACvF;;AACAM,MAAM,CAAC,CAAAJ,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,aAAa,EAAEnG,qCAAqC,CAAC,CAAC;AAC5EoG,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAExF,WAAW,CAAC,CAAC,GAAGwF,CAAC,CAACC,MAAM;;EAEhC,MAAMnB,UAAU,GAAG,EAAE;EACrB,MAAMvE,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCa,gBAAgB,EAAE,IAAI;IACtBrF,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAM0G,MAAM,GAAG,IAAIzB,UAAU,CAACjF,MAAM,CAACmG,cAAc,EAAE,CAAC;EACtD,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,UAAU,EAAE,EAAEwB,CAAC,EAAE;IACnCN,CAAC,CAACW,MAAM,CAACM,MAAM,CAACX,CAAC,CAAC,KAAK,CAAC,CAAC;EAC3B;EACA/F,MAAM,CAACqG,KAAK,EAAE;;EAEd,MAAMnG,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/CkB,CAAC,CAAC1F,qBAAqB,CAACC,MAAM,EAAEC,WAAW,EAAEC,YAAY,CAAC;AAC5D,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,mCAAmC,CAAC;AACxCC,IAAI;AACF;AACL;AACA,0FAA0F,CACvF;;AACAM,MAAM,CAAC,CAAAJ,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAEnG,qCAAqC,CAAC;AAC7DkH,aAAa,EAAE;AACff,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAClC;;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAExF,WAAW,EAAE8B,MAAM,CAAC,CAAC,GAAG0D,CAAC,CAACC,MAAM;EACxC,MAAMnB,UAAU,GAAG,EAAE;EACrB,MAAMoB,aAAa,GAAG5D,MAAM,IAAI,CAAC,GAAGA,MAAM,GAAGwC,UAAU,GAAGxC,MAAM;;EAEhE,MAAM/B,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCa,gBAAgB,EAAE,IAAI;IACtBrF,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAME,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/C;IACE,MAAMoC,UAAU,GAAG,EAAE;IACrB,MAAMD,MAAM,GAAG,IAAIzB,UAAU,CAACjF,MAAM,CAACmG,cAAc,CAACR,aAAa,EAAEgB,UAAU,CAAC,CAAC;IAC/E,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,UAAU,EAAE,EAAEZ,CAAC,EAAE;MACnCN,CAAC,CAACW,MAAM,CAACM,MAAM,CAACX,CAAC,CAAC,KAAK,CAAC,CAAC;MACzB,IAAI,EAAE9F,WAAW,GAAGH,cAAc,CAACP,QAAQ,CAAC,EAAE;QAC5CmH,MAAM,CAACX,CAAC,CAAC,GAAG7F,YAAY,CAACyF,aAAa,GAAGI,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC;MACrD;IACF;IACA/F,MAAM,CAACqG,KAAK,EAAE;EAChB;;EAEAZ,CAAC,CAAC1F,qBAAqB,CAACC,MAAM,EAAEC,WAAW,EAAEC,YAAY,CAAC;AAC5D,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,mCAAmC,CAAC;AACxCC,IAAI;AACF;AACL,wFAAwF,CACrF;;AACAI,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMlB,UAAU,GAAG,EAAE;EACrB,MAAMtE,WAAW,GAAGH,cAAc,CAACN,QAAQ;EAC3C,MAAMQ,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAME,YAAY,GAAG,IAAI+E,UAAU,CAACV,UAAU,CAAC;EAC/C;EACAkB,CAAC,CAAC1F,qBAAqB,CAACC,MAAM,EAAEC,WAAW,EAAEC,YAAY,CAAC;AAC5D,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,wBAAwB,CAAC;AAC7BC,IAAI;AACF;AACL,yFAAyF,CACtF;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAC1DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;EACjC,MAAMkB,WAAqC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACvD,MAAMC,gBAAgB,GAAG,YAAY;;EAErC,MAAMC,UAAU,GAAGrB,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IACxCE,IAAI,EAAEwF,WAAW;IACjBzF,MAAM,EAAE0F,gBAAgB;IACxBxF,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAAChC;EACpD,CAAC,CAAC;EACFmG,CAAC,CAACjE,eAAe,CAACsF,UAAU,CAAC;EAC7B,MAAMjG,MAAM,GAAG/B,oBAAoB,CAAC+H,gBAAgB,EAAE,IAAI,EAAED,WAAW,CAAC;EACxE,MAAMG,aAAa,GAAGlG,MAAM,CAACmG,UAAU,GAAGxG,YAAY;EACtD,MAAMyG,cAAc,GAAGnH,cAAc,CAACN,QAAQ;EAC9C,MAAM0H,SAAS,GAAGzB,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACtCxE,IAAI,EAAE2F,aAAa;IACnB1F,KAAK,EAAE4F;EACT,CAAC,CAAC;EACFxB,CAAC,CAACjE,eAAe,CAAC0F,SAAS,CAAC;;EAE5B,MAAMjF,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/CD,OAAO,CAACkF,mBAAmB;EACzB;IACEnH,MAAM,EAAEkH,SAAS;IACjBnF,MAAM,EAAEvB,YAAY;IACpB4G,WAAW,EAAEvG,MAAM,CAACuG,WAAW;IAC/BC,YAAY,EAAExG,MAAM,CAACwG;EACvB,CAAC;EACD,EAAEvD,OAAO,EAAEgD,UAAU,CAAC,CAAC;EACvBF,WAAW,CACZ;;EACDnB,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC8C,CAAC,CAAC7C,2BAA2B,CAACsE,SAAS,EAAEH,aAAa,EAAED,UAAU,EAAEF,WAAW,EAAE;IAC/ElC,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE;EACL,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEJK,CAAC,CAACC,IAAI,CAAC,qCAAqC,CAAC;AAC1CC,IAAI;AACF;AACL,+CAA+C,CAC5C;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AAC5DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;EACjC,MAAMnB,UAAU,GAAG/D,YAAY,GAAG,CAAC;EACnC,MAAMP,WAAW,GAAGH,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACwH,aAAa;EAC1E,MAAMC,SAAS,GAAG9B,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACtCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEpB;EACT,CAAC,CAAC;EACFwF,CAAC,CAACjE,eAAe,CAAC+F,SAAS,CAAC;;EAE5B,MAAMC,QAAQ,GAAG/B,CAAC,CAAC9E,MAAM,CAAC8G,cAAc,CAAC,EAAEC,IAAI,EAAE,WAAW,EAAEC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;EACzE,MAAM1F,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/CD,OAAO,CAAC2F,eAAe,CAACJ,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAED,SAAS,EAAE/G,YAAY,CAAC;EAChEiF,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC,MAAMqC,kBAAkB,GAAG,IAAIC,UAAU,CAACV,UAAU,CAAC;EACrDkB,CAAC,CAAC1F,qBAAqB,CAACwH,SAAS,EAAEtH,WAAW,EAAE+E,kBAAkB,CAAC;AACrE,CAAC,CAAC;;AAEJE,CAAC,CAACC,IAAI,CAAC,gCAAgC,CAAC;AACrCC,IAAI;AACF;AACL,+CAA+C,CAC5C;;AACAC,kBAAkB,CAAC,CAAAC,CAAC;AACnBA,CAAC;AACEC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACpCA,OAAO,CAAC,iBAAiB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAClCA,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/BA,OAAO,CAAC,cAAc,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACjCsC,MAAM,CAAC,CAAApC,CAAC,KAAI;EACX;EACA,OAAO,EAAEA,CAAC,CAACjF,YAAY,KAAK,CAAC,IAAIiF,CAAC,CAAC4B,YAAY,KAAK,EAAE,CAAC;AACzD,CAAC,CAAC,CACL;;AACA7B,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,EAAEsH,eAAe,EAAEC,YAAY,EAAEV,YAAY,CAAC,CAAC,GAAG5B,CAAC,CAACC,MAAM;EAC9E,MAAMsC,gBAAgB,GAAG,QAAQ;EACjC,MAAMpB,WAAW,GAAG,CAAC,EAAE,EAAE,EAAE,EAAEkB,eAAe,CAAU;;EAEtD,MAAMG,UAAU,GAAGxC,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IACxCC,MAAM,EAAE6G,gBAAgB;IACxB3G,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAAC4G,iBAAiB;IACnE9G,IAAI,EAAEwF,WAAW;IACjBuB,aAAa,EAAEJ,YAAY,GAAG;EAChC,CAAC,CAAC;EACFtC,CAAC,CAACjE,eAAe,CAACyG,UAAU,CAAC;;EAE7B,MAAMb,WAAW,GAAG,GAAG;EACvB,MAAMvG,MAAM,GAAG/B,oBAAoB,CAACkJ,gBAAgB,EAAE,IAAI,EAAEpB,WAAW,EAAE;IACvEwB,QAAQ,EAAEL,YAAY;IACtBX,WAAW;IACXC;EACF,CAAC,CAAC;;EAEF,MAAMgB,aAAa,GAAGxH,MAAM,CAACmG,UAAU,GAAGsB,IAAI,CAACC,GAAG,CAAC/H,YAAY,CAAC;EAChE,MAAM+G,SAAS,GAAG9B,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACtCxE,IAAI,EAAEiH,aAAa;IACnBhH,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACR;EAClD,CAAC,CAAC;EACFmG,CAAC,CAACjE,eAAe,CAAC+F,SAAS,CAAC;;EAE5B,MAAMtF,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;;EAE/C;EACA,KAAK,IAAIsG,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGV,eAAe,EAAE,EAAEU,KAAK,EAAE;IACpD,MAAMxE,UAAU,GAAG/B,OAAO,CAACgC,eAAe,CAAC;MACzCC,gBAAgB,EAAE;MAChB;QACEC,IAAI,EAAE8D,UAAU,CAACjG,UAAU,CAAC;UAC1ByG,cAAc,EAAED,KAAK;UACrBV,eAAe,EAAE,CAAC;UAClBY,YAAY,EAAEX;QAChB,CAAC,CAAC;QACF3D,UAAU,EAAE,EAAEuE,CAAC,EAAEH,KAAK,GAAG,CAAC,EAAEtD,CAAC,EAAE,CAAC,EAAE0D,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9CxE,MAAM,EAAE,OAAO;QACfC,OAAO,EAAE;MACX,CAAC;;IAEL,CAAC,CAAC;IACFN,UAAU,CAACxB,GAAG,EAAE;EAClB;;EAEA;EACA,MAAMmD,aAAa,GAAG2C,IAAI,CAACQ,GAAG,CAACtI,YAAY,EAAE,CAAC,CAAC;EAC/CyB,OAAO,CAAC8G,mBAAmB;EACzB,EAAEjF,OAAO,EAAEmE,UAAU,EAAEG,QAAQ,EAAEL,YAAY,CAAC,CAAC;EAC/C,EAAE/H,MAAM,EAAEuH,SAAS,EAAExF,MAAM,EAAE4D,aAAa,EAAEyB,WAAW,EAAEC,YAAY,CAAC,CAAC;EACvExG,MAAM,CAACmI,OAAO,CACf;;EACDvD,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC;EACA,MAAMzC,YAAY,GAAG,IAAI+E,UAAU,CAACoD,aAAa,CAAC;EAClD,KAAK,IAAIG,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGV,eAAe,EAAE,EAAEU,KAAK,EAAE;IACpD,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpI,MAAM,CAACmI,OAAO,CAAC,CAAC,CAAC,EAAE,EAAEC,CAAC,EAAE;MAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrI,MAAM,CAACmI,OAAO,CAAC,CAAC,CAAC,EAAE,EAAEE,CAAC,EAAE;QAC1ChJ,YAAY,CAACyF,aAAa,GAAG6C,KAAK,GAAGpB,WAAW,GAAGC,YAAY,GAAG4B,CAAC,GAAG7B,WAAW,GAAG8B,CAAC,CAAC;QACpFV,KAAK,GAAG,CAAC;MACb;IACF;EACF;EACA/C,CAAC,CAACrF,0BAA0B,CAACmH,SAAS,EAAErH,YAAY,CAAC;AACvD,CAAC,CAAC;;AAEJgF,CAAC,CAACC,IAAI,CAAC,gBAAgB,CAAC;AACrBC,IAAI;AACF;AACL,mEAAmE,CAChE;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AAC5DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;;EAEjC,MAAMjF,eAAe,GAAG,EAAE;EAC1B,MAAMT,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEZ,YAAY,GAAGC,eAAe;IACpCY,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACqJ;EAClD,CAAC,CAAC;EACF1D,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAMO,mBAAmB,GAAGkF,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IACtDC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;;EAEF;EACAqC,CAAC,CAACnF,6BAA6B,CAACC,mBAAmB,EAAEP,MAAM,EAAEQ,YAAY,EAAEC,eAAe,CAAC;AAC7F,CAAC,CAAC;;AAEJyE,CAAC,CAACC,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,IAAI;AACF;AACL,8EAA8E,CAC3E;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AAC5DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;EACjC,MAAMjF,eAAe,GAAG,EAAE;EAC1B,MAAMT,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEZ,YAAY,GAAGC,eAAe;IACpCY,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACsJ;EAClD,CAAC,CAAC;EACF3D,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAMO,mBAAmB,GAAGkF,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IACtDC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;;EAEF;EACAqC,CAAC,CAACnF,6BAA6B,CAACC,mBAAmB,EAAEP,MAAM,EAAEQ,YAAY,EAAEC,eAAe,CAAC;AAC7F,CAAC,CAAC;;AAEJyE,CAAC,CAACC,IAAI,CAAC,gBAAgB,CAAC;AACrBC,IAAI;AACF;AACL,8EAA8E,CAC3E;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AAC5DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;EACjC,MAAMjF,eAAe,GAAG,EAAE;EAC1B,MAAMT,MAAM,GAAGyF,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACnCxE,IAAI,EAAEZ,YAAY,GAAGC,eAAe;IACpCY,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACsJ;EAClD,CAAC,CAAC;EACF3D,CAAC,CAACjE,eAAe,CAACxB,MAAM,CAAC;;EAEzB,MAAMO,mBAAmB,GAAGkF,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IACtDC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;;EAEF;EACAqC,CAAC,CAACnF,6BAA6B,CAACC,mBAAmB,EAAEP,MAAM,EAAEQ,YAAY,EAAEC,eAAe,CAAC;AAC7F,CAAC,CAAC;;AAEJyE,CAAC,CAACC,IAAI,CAAC,eAAe,CAAC;AACpBC,IAAI;AACF;AACL,4EAA4E,CACzE;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;;EAEjC,MAAM2D,cAAc,GAAG5D,CAAC,CAAC5C,2BAA2B;EAClD4C,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IAC1BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACM,CAAC,CAAC;EACF,IAAI,CACL;;;EAED,MAAMmB,UAAU,GAAG,EAAE,GAAG/D,YAAY;EACpC,MAAM8I,YAAY,GAAG7D,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACzCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEvB,cAAc,CAACyJ,MAAM,GAAGzJ,cAAc,CAACN;EAChD,CAAC,CAAC;EACFiG,CAAC,CAACjE,eAAe,CAAC8H,YAAY,CAAC;;EAE/B,MAAMrI,aAAa,GAAGwE,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IAC3CC,MAAM,EAAE,YAAY;IACpBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACfC,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAAC4G;EACpD,CAAC,CAAC;EACFzC,CAAC,CAACjE,eAAe,CAACP,aAAa,CAAC;;EAEhC,MAAMgB,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/C,MAAM8B,UAAU,GAAG/B,OAAO,CAACgC,eAAe,CAAC;IACzCC,gBAAgB,EAAE;IAChB;MACEC,IAAI,EAAElD,aAAa,CAACe,UAAU,EAAE;MAChCoC,UAAU,EAAE,EAAEuE,CAAC,EAAE,GAAG,EAAEzD,CAAC,EAAE,GAAG,EAAE0D,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;MAC9CxE,MAAM,EAAE,OAAO;MACfC,OAAO,EAAE;IACX,CAAC;;EAEL,CAAC,CAAC;EACFN,UAAU,CAACwF,eAAe,CAAC,CAAC,EAAEF,YAAY,EAAE9I,YAAY,CAAC;EACzDwD,UAAU,CAAC1B,WAAW,CAAC+G,cAAc,CAAC;EACtCrF,UAAU,CAACyF,IAAI,CAAC,CAAC,CAAC;EAClBzF,UAAU,CAACxB,GAAG,EAAE;EAChBiD,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC8C,CAAC,CAAC7C,2BAA2B,CAAC0G,YAAY,EAAE/E,UAAU,EAAEtD,aAAa,CAAC;AACxE,CAAC,CAAC;;AAEJiE,CAAC,CAACC,IAAI,CAAC,cAAc,CAAC;AACnBC,IAAI;AACF;AACL,0EAA0E,CACvE;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;;EAEjC,MAAM2D,cAAc,GAAG5D,CAAC,CAAC5C,2BAA2B;EAClD4C,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IAC1BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACM,CAAC,CAAC;EACF,KAAK,CACN;;;EAED;EACA,MAAMmB,UAAU,GAAG,CAAC,GAAG/D,YAAY;EACnC,MAAMkJ,WAAW,GAAGjE,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IACxCxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEvB,cAAc,CAAC6J,KAAK,GAAG7J,cAAc,CAACN;EAC/C,CAAC,CAAC;EACFiG,CAAC,CAACjE,eAAe,CAACkI,WAAW,CAAC;;EAE9B,MAAMzI,aAAa,GAAGwE,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IAC3CC,MAAM,EAAE,YAAY;IACpBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACfC,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAAC4G;EACpD,CAAC,CAAC;EACFzC,CAAC,CAACjE,eAAe,CAACP,aAAa,CAAC;;EAEhC,MAAMgB,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/C,MAAM8B,UAAU,GAAG/B,OAAO,CAACgC,eAAe,CAAC;IACzCC,gBAAgB,EAAE;IAChB;MACEC,IAAI,EAAElD,aAAa,CAACe,UAAU,EAAE;MAChCoC,UAAU,EAAE,EAAEuE,CAAC,EAAE,GAAG,EAAEzD,CAAC,EAAE,GAAG,EAAE0D,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;MAC9CxE,MAAM,EAAE,OAAO;MACfC,OAAO,EAAE;IACX,CAAC;;EAEL,CAAC,CAAC;EACFN,UAAU,CAAC1B,WAAW,CAAC+G,cAAc,CAAC;EACtCrF,UAAU,CAAC4F,cAAc,CAACF,WAAW,EAAE,QAAQ,EAAElJ,YAAY,EAAE,CAAC,CAAC;EACjEwD,UAAU,CAAC6F,WAAW,CAAC,CAAC,CAAC;EACzB7F,UAAU,CAACxB,GAAG,EAAE;EAChBiD,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC8C,CAAC,CAAC7C,2BAA2B,CAAC8G,WAAW,EAAEnF,UAAU,EAAEtD,aAAa,CAAC;AACvE,CAAC,CAAC;;AAEJiE,CAAC,CAACC,IAAI,CAAC,mCAAmC,CAAC;AACxCC,IAAI;AACF;AACL;AACA,4BAA4B,CACzB;;AACAM,MAAM,CAAC,CAAAJ,CAAC;AACPA,CAAC,CAACC,OAAO,CAAC,mBAAmB,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAACe,aAAa,EAAE,CAACf,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAC/F;;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEqE,iBAAiB,EAAEtJ,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;;EAEpD,MAAM2D,cAAc,GAAG5D,CAAC,CAAC5C,2BAA2B;EAClD4C,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;IAC1BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACM,CAAC,CAAC;EACF,KAAK,CACN;;;EAED,MAAM2G,2BAA2B,GAAG,EAAE;EACtC,MAAMC,kCAAkC,GAAG,EAAE;EAC7C,MAAMzF,UAAU;EACd+D,IAAI,CAACQ,GAAG,CAACiB,2BAA2B,EAAEC,kCAAkC,CAAC,GAAGxJ,YAAY;EAC1F,MAAMyJ,cAAc,GAAGxE,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IAC3CxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACoK;EAClD,CAAC,CAAC;EACFzE,CAAC,CAACjE,eAAe,CAACyI,cAAc,CAAC;;EAEjC,MAAMhJ,aAAa,GAAGwE,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IAC3CC,MAAM,EAAE,YAAY;IACpBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACfC,KAAK,EAAEC,eAAe,CAAC9B,QAAQ,GAAG8B,eAAe,CAAC4G;EACpD,CAAC,CAAC;EACFzC,CAAC,CAACjE,eAAe,CAACP,aAAa,CAAC;;EAEhC;EACA,MAAMgB,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/CuD,CAAC,CAAC5B,4BAA4B,CAAC5B,OAAO,EAAEhB,aAAa,EAAE,EAAE0H,CAAC,EAAE,GAAG,EAAEzD,CAAC,EAAE,GAAG,EAAE0D,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;;EAE1F,MAAM7E,UAAU,GAAG/B,OAAO,CAACgC,eAAe,CAAC;IACzCC,gBAAgB,EAAE;IAChB;MACEC,IAAI,EAAElD,aAAa,CAACe,UAAU,EAAE;MAChCqC,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;IACX,CAAC;;EAEL,CAAC,CAAC;EACFN,UAAU,CAAC1B,WAAW,CAAC+G,cAAc,CAAC;;EAEtC,IAAIK,WAAW,GAAGS,SAAS;EAC3B,IAAIL,iBAAiB,EAAE;IACrBJ,WAAW,GAAGjE,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;MAClCxE,IAAI,EAAE,CAAC;MACPC,KAAK,EAAEvB,cAAc,CAAC6J;IACxB,CAAC,CAAC;IACFlE,CAAC,CAACjE,eAAe,CAACkI,WAAW,CAAC;IAC9B1F,UAAU,CAAC4F,cAAc,CAACF,WAAW,EAAE,QAAQ,CAAC;IAChD1F,UAAU,CAACoG,mBAAmB,CAACH,cAAc,EAAEzJ,YAAY,CAAC;EAC9D,CAAC,MAAM;IACLwD,UAAU,CAACqG,YAAY,CAACJ,cAAc,EAAEzJ,YAAY,CAAC;EACvD;;EAEAwD,UAAU,CAACxB,GAAG,EAAE;EAChBiD,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC;EACA;EACA8C,CAAC,CAAC7C,2BAA2B,CAACqH,cAAc,EAAE1F,UAAU,EAAEtD,aAAa,CAAC;AAC1E,CAAC,CAAC;;AAEJiE,CAAC,CAACC,IAAI,CAAC,uCAAuC,CAAC;AAC5CC,IAAI;AACF;AACL;AACA,UAAU,CACP;;AACAC,kBAAkB,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3DC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEjF,YAAY,CAAC,CAAC,GAAGiF,CAAC,CAACC,MAAM;;EAEjC,MAAMhF,eAAe,GAAG+E,CAAC,CAAC9E,MAAM,CAACC,qBAAqB,CAAC;IACrDC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAE0E,CAAC,CAAC9E,MAAM,CAACwC,kBAAkB,CAAC;QAClCC,IAAI,EAAG;AACjB;AACA;AACA;AACA;AACA;MACQ,CAAC,CAAC;MACFpC,UAAU,EAAE;IACd;EACF,CAAC,CAAC;;EAEF,MAAMsJ,+BAA+B,GAAG,EAAE;EAC1C,MAAM/F,UAAU,GAAG+F,+BAA+B,GAAG9J,YAAY;EACjE,MAAMyJ,cAAc,GAAGxE,CAAC,CAAC9E,MAAM,CAACiF,YAAY,CAAC;IAC3CxE,IAAI,EAAEmD,UAAU;IAChBlD,KAAK,EAAEvB,cAAc,CAACN,QAAQ,GAAGM,cAAc,CAACoK;EAClD,CAAC,CAAC;EACFzE,CAAC,CAACjE,eAAe,CAACyI,cAAc,CAAC;;EAEjC,MAAMhJ,aAAa,GAAGwE,CAAC,CAAC9E,MAAM,CAACO,aAAa,CAAC;IAC3CC,MAAM,EAAE,YAAY;IACpBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACfC,KAAK;IACHC,eAAe,CAAC9B,QAAQ;IACxB8B,eAAe,CAAC4G,iBAAiB;IACjC5G,eAAe,CAACC;EACpB,CAAC,CAAC;EACFkE,CAAC,CAACjE,eAAe,CAACP,aAAa,CAAC;;EAEhC;EACA,MAAMgB,OAAO,GAAGwD,CAAC,CAAC9E,MAAM,CAACuB,oBAAoB,EAAE;EAC/CuD,CAAC,CAAC5B,4BAA4B,CAAC5B,OAAO,EAAEhB,aAAa,EAAE,EAAE0H,CAAC,EAAE,GAAG,EAAEzD,CAAC,EAAE,GAAG,EAAE0D,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;;EAE1F,MAAMpH,SAAS,GAAGgE,CAAC,CAAC9E,MAAM,CAACe,eAAe,CAAC;IACzCb,MAAM,EAAEH,eAAe,CAACiB,kBAAkB,CAAC,CAAC,CAAC;IAC7CC,OAAO,EAAE;IACP;MACEC,OAAO,EAAE,CAAC;MACVC,QAAQ,EAAEb,aAAa,CAACe,UAAU;IACpC,CAAC;;EAEL,CAAC,CAAC;;EAEF;EACA;EACA,MAAMG,WAAW,GAAGF,OAAO,CAACG,gBAAgB,EAAE;EAC9CD,WAAW,CAACE,YAAY,CAAC,CAAC,EAAEZ,SAAS,CAAC;EACtCU,WAAW,CAACG,WAAW,CAAC5B,eAAe,CAAC;EACxCyB,WAAW,CAACoI,0BAA0B,CAACN,cAAc,EAAEzJ,YAAY,CAAC;EACpE2B,WAAW,CAACK,GAAG,EAAE;EACjBiD,CAAC,CAAChD,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,EAAE,CAAC,CAAC;;EAElC;EACA;EACA8C,CAAC,CAAC7C,2BAA2B,CAACqH,cAAc,EAAE1F,UAAU,EAAEtD,aAAa,CAAC;AAC1E,CAAC,CAAC"}
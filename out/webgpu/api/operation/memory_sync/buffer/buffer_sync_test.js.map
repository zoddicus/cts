{"version":3,"file":"buffer_sync_test.js","names":["assert","unreachable","GPUTest","checkElementsEqualEither","kAllWriteOps","kAllReadOps","kOpInfo","contexts","storage","checkOpsValidForContext","ops","context","valid","includes","checkImpl","op1","op2","kDummyVertexShader","BufferSyncTest","tmpValueBuffers","undefined","tmpValueTextures","createIntermediateBuffersAndTexturesForWriteOp","writeOp","slot","value","createBufferWithValue","createTextureWithValue","createBuffersForReadOp","readOp","srcValue","opValue","vertexBuffer","createBufferWithValues","indexBuffer","srcBuffer","dstBuffer","createBufferTracked","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","VERTEX","INDEX","INDIRECT","UNIFORM","initValue","buffer","mappedAtCreation","getMappedRange","fill","unmap","queue","onSubmittedWorkDone","initValues","length","bufferView","set","data","texture","createTextureTracked","width","height","depthOrArrayLayers","format","GPUTextureUsage","device","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","wgslCompute","createComputePipeline","compute","module","createShaderModule","code","entryPoint","createTrivialRenderPipeline","wgslShaders","createRenderPipeline","vertex","fragment","targets","primitive","topology","createStorageWriteRenderPipeline","beginSimpleRenderPass","encoder","view","RENDER_ATTACHMENT","createView","beginRenderPass","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","encodeWriteAsStorageBufferInRenderPass","renderer","bindGroup","setBindGroup","setPipeline","draw","encodeWriteAsStorageBufferInComputePass","pass","dispatchWorkgroups","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","helper","operation","writeOpSlot","ensureContext","renderPassEncoder","renderBundleEncoder","computePassEncoder","commandEncoder","createStorageReadComputePipeline","createBindGroupSrcDstBuffer","createVertexReadRenderPipeline","buffers","arrayStride","attributes","shaderLocation","createUniformReadRenderPipeline","createStorageReadRenderPipeline","encodeReadAsStorageBufferInComputePass","encodeReadAsIndirectBufferInComputePass","dispatchWorkgroupsIndirect","encodeReadAsVertexBufferInRenderPass","setVertexBuffer","encodeReadAsIndexBufferInRenderPass","setIndexBuffer","drawIndexed","encodeReadAsIndirectBufferInRenderPass","drawIndirect","encodeReadAsIndexedIndirectBufferInRenderPass","drawIndexedIndirect","encodeReadAsUniformBufferInRenderPass","encodeReadAsStorageBufferInRenderPass","encodeReadByB2BCopy","encodeReadByB2TCopy","copyBufferToTexture","encodeReadOp","computePass","verifyData","expectedValue","bufferData","expectGPUBufferValuesEqual","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectGPUBufferValuesPassCheck","type","typedLength"],"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"sourcesContent":["import { assert, unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { checkElementsEqualEither } from '../../../../util/check_contents.js';\nimport { OperationContext, OperationContextHelper } from '../operation_context_helper.js';\n\nexport const kAllWriteOps = ['storage', 'b2b-copy', 't2b-copy', 'write-buffer'] as const;\n\nexport const kAllReadOps = [\n  'input-vertex',\n  'input-index',\n  'input-indirect',\n  'input-indirect-index',\n  'input-indirect-dispatch',\n\n  'constant-uniform',\n\n  'storage-read',\n\n  'b2b-copy',\n  'b2t-copy',\n] as const;\n\nexport type ReadOp = (typeof kAllReadOps)[number];\nexport type WriteOp = (typeof kAllWriteOps)[number];\n\nexport type Op = ReadOp | WriteOp;\n\ninterface OpInfo {\n  readonly contexts: OperationContext[];\n}\n\nconst kOpInfo: {\n  readonly [k in Op]: OpInfo;\n} = {\n  'write-buffer': {\n    contexts: ['queue'],\n  },\n  'b2t-copy': {\n    contexts: ['command-encoder'],\n  },\n  'b2b-copy': {\n    contexts: ['command-encoder'],\n  },\n  't2b-copy': {\n    contexts: ['command-encoder'],\n  },\n  storage: {\n    contexts: ['compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'storage-read': {\n    contexts: ['compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-vertex': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-index': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect-index': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect-dispatch': {\n    contexts: ['compute-pass-encoder'],\n  },\n  'constant-uniform': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n};\n\nexport function checkOpsValidForContext(\n  ops: [Op, Op],\n  context: [OperationContext, OperationContext]\n) {\n  const valid =\n    kOpInfo[ops[0]].contexts.includes(context[0]) && kOpInfo[ops[1]].contexts.includes(context[1]);\n  if (!valid) return false;\n\n  if (\n    context[0] === 'render-bundle-encoder' ||\n    context[0] === 'render-pass-encoder' ||\n    context[1] === 'render-bundle-encoder' ||\n    context[1] === 'render-pass-encoder'\n  ) {\n    // In a render pass, it is invalid to use a resource as both writable and another usage.\n    // Also, for storage+storage usage, the application is opting into racy behavior.\n    // The storage+storage case is also skipped as the results cannot be reliably tested.\n    const checkImpl = (op1: Op, op2: Op) => {\n      switch (op1) {\n        case 'storage':\n          switch (op2) {\n            case 'storage':\n            case 'storage-read':\n            case 'input-vertex':\n            case 'input-index':\n            case 'input-indirect':\n            case 'input-indirect-index':\n            case 'constant-uniform':\n              // Write+other, or racy.\n              return false;\n            case 'b2t-copy':\n            case 't2b-copy':\n            case 'b2b-copy':\n            case 'write-buffer':\n              // These don't occur in a render pass.\n              return true;\n          }\n          break;\n        case 'input-vertex':\n        case 'input-index':\n        case 'input-indirect':\n        case 'input-indirect-index':\n        case 'constant-uniform':\n        case 'b2t-copy':\n        case 't2b-copy':\n        case 'b2b-copy':\n        case 'write-buffer':\n          // These are not write usages, or don't occur in a render pass.\n          break;\n      }\n      return true;\n    };\n    return checkImpl(ops[0], ops[1]) && checkImpl(ops[1], ops[0]);\n  }\n  return true;\n}\n\nconst kDummyVertexShader = `\n@vertex fn vert_main() -> @builtin(position) vec4<f32> {\n  return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n}\n`;\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Vertex and index buffers used in read render pass\n  vertexBuffer?: GPUBuffer;\n  indexBuffer?: GPUBuffer;\n\n  // Temp buffer and texture with values for buffer/texture copy write op\n  // There can be at most 2 write op\n  tmpValueBuffers: (GPUBuffer | undefined)[] = [undefined, undefined];\n  tmpValueTextures: (GPUTexture | undefined)[] = [undefined, undefined];\n\n  // These intermediate buffers/textures are created before any read/write op\n  // to avoid extra memory synchronization between ops introduced by await on buffer/texture creations.\n  // Create extra buffers/textures needed by write operation\n  async createIntermediateBuffersAndTexturesForWriteOp(\n    writeOp: WriteOp,\n    slot: number,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'b2b-copy':\n        this.tmpValueBuffers[slot] = await this.createBufferWithValue(value);\n        break;\n      case 't2b-copy':\n        this.tmpValueTextures[slot] = await this.createTextureWithValue(value);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Create extra buffers/textures needed by read operation\n  async createBuffersForReadOp(readOp: ReadOp, srcValue: number, opValue: number) {\n    // This helps create values that will be written into dst buffer by the readop\n    switch (readOp) {\n      case 'input-index':\n        // The index buffer will be the src buffer of the read op.\n        // The src value for readOp will be 0\n        // If the index buffer value is 0, the src value is written into the dst buffer.\n        // If the index buffer value is 1, the op value is written into the dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([srcValue, opValue]);\n        break;\n      case 'input-indirect':\n        // The indirect buffer for the draw cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the op value in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        break;\n      case 'input-indirect-index':\n        // The indirect buffer for draw indexed cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the opValue in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        this.indexBuffer = await this.createBufferWithValues([0]);\n        break;\n      default:\n        break;\n    }\n\n    let srcBuffer: GPUBuffer;\n    switch (readOp) {\n      case 'input-indirect':\n        // vertexCount = {0, 1}\n        // instanceCount = 1\n        // firstVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0]);\n        break;\n      case 'input-indirect-index':\n        // indexCount = {0, 1}\n        // instanceCount = 1\n        // firstIndex = 0\n        // baseVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0, 0]);\n        break;\n      case 'input-indirect-dispatch':\n        // workgroupCountX = {0, 1}\n        // workgroupCountY = 1\n        // workgroupCountZ = 1\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 1]);\n        break;\n      default:\n        srcBuffer = await this.createBufferWithValue(srcValue);\n        break;\n    }\n\n    const dstBuffer = this.createBufferTracked({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n\n    return { srcBuffer, dstBuffer };\n  }\n\n  // Create a buffer with 1 uint32 element, and initialize it to a specified value.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a buffer, and initialize it to the specified values.\n  async createBufferWithValues(initValues: number[]): Promise<GPUBuffer> {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: Uint32Array.BYTES_PER_ELEMENT * initValues.length,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n    const bufferView = new Uint32Array(buffer.getMappedRange());\n    bufferView.set(initValues);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a 1x1 texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const data = new Uint32Array(1).fill(initValue);\n    const texture = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    this.device.queue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: 256, rowsPerImage: 1 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    await this.queue.onSubmittedWorkDone();\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @compute @workgroup_size(1) fn main() {\n        data.a = ${value}u;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createTrivialRenderPipeline(wgslShaders: { vertex: string; fragment: string }) {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = ${value}u;\n        return vec4<f32>();  // result does't matter\n      }\n    `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    }).createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view,\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via BufferToBuffer copy.\n  encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpBuffer = this.tmpValueBuffers[slot];\n    assert(tmpBuffer !== undefined);\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpTexture = this.tmpValueTextures[slot];\n    assert(tmpTexture !== undefined);\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const data = new Uint32Array(1).fill(value);\n    this.device.queue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  encodeWriteOp(\n    helper: OperationContextHelper,\n    operation: WriteOp,\n    context: OperationContext,\n    buffer: GPUBuffer,\n    writeOpSlot: number,\n    value: number\n  ) {\n    helper.ensureContext(context);\n\n    switch (operation) {\n      case 'write-buffer':\n        this.writeByWriteBuffer(buffer, value);\n        break;\n      case 'storage':\n        switch (context) {\n          case 'render-pass-encoder':\n            assert(helper.renderPassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderPassEncoder, buffer, value);\n            break;\n          case 'render-bundle-encoder':\n            assert(helper.renderBundleEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderBundleEncoder, buffer, value);\n            break;\n          case 'compute-pass-encoder':\n            assert(helper.computePassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInComputePass(helper.computePassEncoder, buffer, value);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByB2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      case 't2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByT2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  // Create a compute pipeline: read from src buffer and write it into the storage buffer.\n  createStorageReadComputePipeline(): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read> srcData : Data;\n      @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n      @compute @workgroup_size(1) fn main() {\n        dstData.a = srcData.a;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createBindGroupSrcDstBuffer(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n  }\n\n  // Create a render pipeline: read from vertex/index buffer and write it into the storage dst buffer at fragment stage.\n  createVertexReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      struct VertexOutput {\n        @builtin(position) position : vec4<f32>,\n        @location(0) @interpolate(flat, either) data : u32,\n      };\n\n      @vertex fn vert_main(@location(0) input: u32) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4<f32>(0.5, 0.5, 0.0, 1.0);\n        output.data = input;\n        return output;\n      }\n      `,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main(@location(0) @interpolate(flat, either) input : u32) -> @location(0) vec4<f32> {\n        data.a = input;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: 0,\n                format: 'uint32',\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline: read from uniform buffer and write it into the storage dst buffer at fragment stage.\n  createUniformReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<uniform> constant: Data;\n      @group(0) @binding(1) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = constant.a;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  // Create a render pipeline: read from storage src buffer and write it into the storage dst buffer at fragment stage.\n  createStorageReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n        struct Data {\n          a : u32\n        };\n\n        @group(0) @binding(0) var<storage, read> srcData : Data;\n        @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n        @fragment fn frag_main() -> @location(0) vec4<f32> {\n          dstData.a = srcData.a;\n          return vec4<f32>();  // result does't matter\n        }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeReadAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadComputePipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via dispatchWorkgroupsIndirect call in compute pass.\n  encodeReadAsIndirectBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroupsIndirect(srcBuffer, 0);\n  }\n\n  // Read as vertex input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsVertexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, srcBuffer);\n    renderer.draw(1);\n  }\n\n  // Read as index input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(srcBuffer, 'uint32');\n    renderer.drawIndexed(1);\n  }\n\n  // Read as indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.drawIndirect(srcBuffer, 0);\n  }\n\n  // Read as indexed indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexedIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer,\n    indexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(indexBuffer, 'uint32');\n    renderer.drawIndexedIndirect(srcBuffer, 0);\n  }\n\n  // Read as uniform buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsUniformBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createUniformReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1);\n  }\n\n  // Read as storage buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadRenderPipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Read and write via BufferToBuffer copy.\n  encodeReadByB2BCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    // The b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Read and Write texture via BufferToTexture copy.\n  encodeReadByB2TCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    const tmpTexture = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    // The b2t copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToTexture(\n      { buffer: srcBuffer, bytesPerRow: 256 },\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    // The t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: dstBuffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  encodeReadOp(\n    helper: OperationContextHelper,\n    operation: ReadOp,\n    context: OperationContext,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    helper.ensureContext(context);\n\n    const renderer =\n      context === 'render-bundle-encoder' ? helper.renderBundleEncoder : helper.renderPassEncoder;\n    const computePass = context === 'compute-pass-encoder' ? helper.computePassEncoder : undefined;\n\n    switch (operation) {\n      case 'input-vertex':\n        // The srcBuffer is used as vertexBuffer.\n        // draw writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        this.encodeReadAsVertexBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'input-index':\n        // The srcBuffer is used as indexBuffer.\n        // With this vertexBuffer, drawIndexed writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndexBufferInRenderPass(renderer, srcBuffer, dstBuffer, this.vertexBuffer);\n        break;\n      case 'input-indirect':\n        // The srcBuffer is used as indirectBuffer for drawIndirect.\n        // srcBuffer[0] = 0 or 1 (vertexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer\n        );\n        break;\n      case 'input-indirect-index':\n        // The srcBuffer is used as indirectBuffer for drawIndexedIndirect.\n        // srcBuffer[0] = 0 or 1 (indexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        assert(this.indexBuffer !== undefined);\n        this.encodeReadAsIndexedIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer,\n          this.indexBuffer\n        );\n        break;\n      case 'input-indirect-dispatch':\n        // The srcBuffer is used as indirectBuffer for dispatch.\n        // srcBuffer[0] = 0 or 1 (workgroupCountX), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(computePass !== undefined);\n        this.encodeReadAsIndirectBufferInComputePass(computePass, srcBuffer, dstBuffer, 1);\n        break;\n      case 'constant-uniform':\n        // The srcBuffer is used as uniform buffer.\n        assert(renderer !== undefined);\n        this.encodeReadAsUniformBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'storage-read':\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder':\n            assert(renderer !== undefined);\n            this.encodeReadAsStorageBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n            break;\n          case 'compute-pass-encoder':\n            assert(computePass !== undefined);\n            this.encodeReadAsStorageBufferInComputePass(computePass, srcBuffer, dstBuffer);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2BCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      case 'b2t-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2TCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectGPUBufferValuesPassCheck(\n      buffer,\n      a => checkElementsEqualEither(a, [bufferData1, bufferData2]),\n      { type: Uint32Array, typedLength: 1 }\n    );\n  }\n}\n"],"mappings":";;GAAA,SAASA,MAAM,EAAEC,WAAW,QAAQ,oCAAoC,CACxE,SAASC,OAAO,QAAQ,yBAAyB,CACjD,SAASC,wBAAwB,QAAQ,oCAAoC;;;AAG7E,OAAO,MAAMC,YAAY,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,cAAc,CAAU;;AAExF,OAAO,MAAMC,WAAW,GAAG;AACzB,cAAc;AACd,aAAa;AACb,gBAAgB;AAChB,sBAAsB;AACtB,yBAAyB;;AAEzB,kBAAkB;;AAElB,cAAc;;AAEd,UAAU;AACV,UAAU,CACF;;;;;;;;;;;;AAWV,MAAMC,OAEL;;AAAG;EACF,cAAc,EAAE;IACdC,QAAQ,EAAE,CAAC,OAAO;EACpB,CAAC;EACD,UAAU,EAAE;IACVA,QAAQ,EAAE,CAAC,iBAAiB;EAC9B,CAAC;EACD,UAAU,EAAE;IACVA,QAAQ,EAAE,CAAC,iBAAiB;EAC9B,CAAC;EACD,UAAU,EAAE;IACVA,QAAQ,EAAE,CAAC,iBAAiB;EAC9B,CAAC;EACDC,OAAO,EAAE;IACPD,QAAQ,EAAE,CAAC,sBAAsB,EAAE,qBAAqB,EAAE,uBAAuB;EACnF,CAAC;EACD,cAAc,EAAE;IACdA,QAAQ,EAAE,CAAC,sBAAsB,EAAE,qBAAqB,EAAE,uBAAuB;EACnF,CAAC;EACD,cAAc,EAAE;IACdA,QAAQ,EAAE,CAAC,qBAAqB,EAAE,uBAAuB;EAC3D,CAAC;EACD,aAAa,EAAE;IACbA,QAAQ,EAAE,CAAC,qBAAqB,EAAE,uBAAuB;EAC3D,CAAC;EACD,gBAAgB,EAAE;IAChBA,QAAQ,EAAE,CAAC,qBAAqB,EAAE,uBAAuB;EAC3D,CAAC;EACD,sBAAsB,EAAE;IACtBA,QAAQ,EAAE,CAAC,qBAAqB,EAAE,uBAAuB;EAC3D,CAAC;EACD,yBAAyB,EAAE;IACzBA,QAAQ,EAAE,CAAC,sBAAsB;EACnC,CAAC;EACD,kBAAkB,EAAE;IAClBA,QAAQ,EAAE,CAAC,qBAAqB,EAAE,uBAAuB;EAC3D;AACF,CAAC;;AAED,OAAO,SAASE,uBAAuBA;AACrCC,GAAa;AACbC,OAA6C;AAC7C;EACA,MAAMC,KAAK;EACTN,OAAO,CAACI,GAAG,CAAC,CAAC,CAAC,CAAC,CAACH,QAAQ,CAACM,QAAQ,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC,IAAIL,OAAO,CAACI,GAAG,CAAC,CAAC,CAAC,CAAC,CAACH,QAAQ,CAACM,QAAQ,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;EAChG,IAAI,CAACC,KAAK,EAAE,OAAO,KAAK;;EAExB;EACED,OAAO,CAAC,CAAC,CAAC,KAAK,uBAAuB;EACtCA,OAAO,CAAC,CAAC,CAAC,KAAK,qBAAqB;EACpCA,OAAO,CAAC,CAAC,CAAC,KAAK,uBAAuB;EACtCA,OAAO,CAAC,CAAC,CAAC,KAAK,qBAAqB;EACpC;IACA;IACA;IACA;IACA,MAAMG,SAAS,GAAGA,CAACC,GAAO,EAAEC,GAAO,KAAK;MACtC,QAAQD,GAAG;QACT,KAAK,SAAS;UACZ,QAAQC,GAAG;YACT,KAAK,SAAS;YACd,KAAK,cAAc;YACnB,KAAK,cAAc;YACnB,KAAK,aAAa;YAClB,KAAK,gBAAgB;YACrB,KAAK,sBAAsB;YAC3B,KAAK,kBAAkB;cACrB;cACA,OAAO,KAAK;YACd,KAAK,UAAU;YACf,KAAK,UAAU;YACf,KAAK,UAAU;YACf,KAAK,cAAc;cACjB;cACA,OAAO,IAAI;UACf;UACA;QACF,KAAK,cAAc;QACnB,KAAK,aAAa;QAClB,KAAK,gBAAgB;QACrB,KAAK,sBAAsB;QAC3B,KAAK,kBAAkB;QACvB,KAAK,UAAU;QACf,KAAK,UAAU;QACf,KAAK,UAAU;QACf,KAAK,cAAc;UACjB;UACA;MACJ;MACA,OAAO,IAAI;IACb,CAAC;IACD,OAAOF,SAAS,CAACJ,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC,IAAII,SAAS,CAACJ,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;EAC/D;EACA,OAAO,IAAI;AACb;;AAEA,MAAMO,kBAAkB,GAAI;AAC5B;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,OAAO,MAAMC,cAAc,SAAShB,OAAO,CAAC;EAC1C;;;;EAIA;EACA;EACAiB,eAAe,GAA8B,CAACC,SAAS,EAAEA,SAAS,CAAC;EACnEC,gBAAgB,GAA+B,CAACD,SAAS,EAAEA,SAAS,CAAC;;EAErE;EACA;EACA;EACA,MAAME,8CAA8CA;EAClDC,OAAgB;EAChBC,IAAY;EACZC,KAAa;EACb;IACA,QAAQF,OAAO;MACb,KAAK,UAAU;QACb,IAAI,CAACJ,eAAe,CAACK,IAAI,CAAC,GAAG,MAAM,IAAI,CAACE,qBAAqB,CAACD,KAAK,CAAC;QACpE;MACF,KAAK,UAAU;QACb,IAAI,CAACJ,gBAAgB,CAACG,IAAI,CAAC,GAAG,MAAM,IAAI,CAACG,sBAAsB,CAACF,KAAK,CAAC;QACtE;MACF;QACE;IACJ;EACF;;EAEA;EACA,MAAMG,sBAAsBA,CAACC,MAAc,EAAEC,QAAgB,EAAEC,OAAe,EAAE;IAC9E;IACA,QAAQF,MAAM;MACZ,KAAK,aAAa;QAChB;QACA;QACA;QACA;QACA,IAAI,CAACG,YAAY,GAAG,MAAM,IAAI,CAACC,sBAAsB,CAAC,CAACH,QAAQ,EAAEC,OAAO,CAAC,CAAC;QAC1E;MACF,KAAK,gBAAgB;QACnB;QACA;QACA;QACA,IAAI,CAACC,YAAY,GAAG,MAAM,IAAI,CAACC,sBAAsB,CAAC,CAACF,OAAO,CAAC,CAAC;QAChE;MACF,KAAK,sBAAsB;QACzB;QACA;QACA;QACA,IAAI,CAACC,YAAY,GAAG,MAAM,IAAI,CAACC,sBAAsB,CAAC,CAACF,OAAO,CAAC,CAAC;QAChE,IAAI,CAACG,WAAW,GAAG,MAAM,IAAI,CAACD,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC;QACzD;MACF;QACE;IACJ;;IAEA,IAAIE,SAAoB;IACxB,QAAQN,MAAM;MACZ,KAAK,gBAAgB;QACnB;QACA;QACA;QACA;QACAM,SAAS,GAAG,MAAM,IAAI,CAACF,sBAAsB,CAAC,CAACH,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAClE;MACF,KAAK,sBAAsB;QACzB;QACA;QACA;QACA;QACA;QACAK,SAAS,GAAG,MAAM,IAAI,CAACF,sBAAsB,CAAC,CAACH,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACrE;MACF,KAAK,yBAAyB;QAC5B;QACA;QACA;QACAK,SAAS,GAAG,MAAM,IAAI,CAACF,sBAAsB,CAAC,CAACH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/D;MACF;QACEK,SAAS,GAAG,MAAM,IAAI,CAACT,qBAAqB,CAACI,QAAQ,CAAC;QACtD;IACJ;;IAEA,MAAMM,SAAS,GAAG,IAAI,CAACC,mBAAmB,CAAC;MACzCC,IAAI,EAAEC,WAAW,CAACC,iBAAiB;MACnCC,KAAK;MACHC,cAAc,CAACC,QAAQ;MACvBD,cAAc,CAACE,QAAQ;MACvBF,cAAc,CAACG,OAAO;MACtBH,cAAc,CAACI,MAAM;MACrBJ,cAAc,CAACK,KAAK;MACpBL,cAAc,CAACM,QAAQ;MACvBN,cAAc,CAACO;IACnB,CAAC,CAAC;;IAEF,OAAO,EAAEd,SAAS,EAAEC,SAAS,CAAC,CAAC;EACjC;;EAEA;EACA,MAAMV,qBAAqBA,CAACwB,SAAiB,EAAsB;IACjE,MAAMC,MAAM,GAAG,IAAI,CAACd,mBAAmB,CAAC;MACtCe,gBAAgB,EAAE,IAAI;MACtBd,IAAI,EAAEC,WAAW,CAACC,iBAAiB;MACnCC,KAAK;MACHC,cAAc,CAACC,QAAQ;MACvBD,cAAc,CAACE,QAAQ;MACvBF,cAAc,CAACG,OAAO;MACtBH,cAAc,CAACI,MAAM;MACrBJ,cAAc,CAACK,KAAK;MACpBL,cAAc,CAACM,QAAQ;MACvBN,cAAc,CAACO;IACnB,CAAC,CAAC;IACF,IAAIV,WAAW,CAACY,MAAM,CAACE,cAAc,CAAC,CAAC,CAAC,CAACC,IAAI,CAACJ,SAAS,CAAC;IACxDC,MAAM,CAACI,KAAK,CAAC,CAAC;IACd,MAAM,IAAI,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC;IACtC,OAAON,MAAM;EACf;;EAEA;EACA,MAAMlB,sBAAsBA,CAACyB,UAAoB,EAAsB;IACrE,MAAMP,MAAM,GAAG,IAAI,CAACd,mBAAmB,CAAC;MACtCe,gBAAgB,EAAE,IAAI;MACtBd,IAAI,EAAEC,WAAW,CAACC,iBAAiB,GAAGkB,UAAU,CAACC,MAAM;MACvDlB,KAAK;MACHC,cAAc,CAACC,QAAQ;MACvBD,cAAc,CAACE,QAAQ;MACvBF,cAAc,CAACG,OAAO;MACtBH,cAAc,CAACI,MAAM;MACrBJ,cAAc,CAACK,KAAK;MACpBL,cAAc,CAACM,QAAQ;MACvBN,cAAc,CAACO;IACnB,CAAC,CAAC;IACF,MAAMW,UAAU,GAAG,IAAIrB,WAAW,CAACY,MAAM,CAACE,cAAc,CAAC,CAAC,CAAC;IAC3DO,UAAU,CAACC,GAAG,CAACH,UAAU,CAAC;IAC1BP,MAAM,CAACI,KAAK,CAAC,CAAC;IACd,MAAM,IAAI,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC;IACtC,OAAON,MAAM;EACf;;EAEA;EACA,MAAMxB,sBAAsBA,CAACuB,SAAiB,EAAuB;IACnE;IACA,MAAMY,IAAI,GAAG,IAAIvB,WAAW,CAAC,CAAC,CAAC,CAACe,IAAI,CAACJ,SAAS,CAAC;IAC/C,MAAMa,OAAO,GAAG,IAAI,CAACC,oBAAoB,CAAC;MACxC1B,IAAI,EAAE,EAAE2B,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACpDC,MAAM,EAAE,SAAS;MACjB3B,KAAK,EAAE4B,eAAe,CAAC1B,QAAQ,GAAG0B,eAAe,CAACzB;IACpD,CAAC,CAAC;IACF,IAAI,CAAC0B,MAAM,CAACd,KAAK,CAACe,YAAY;MAC5B,EAAER,OAAO,EAAES,QAAQ,EAAE,CAAC,EAAEC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MACtDd,IAAI;MACJ,EAAEe,MAAM,EAAE,CAAC,EAAEC,WAAW,EAAE,GAAG,EAAEC,YAAY,EAAE,CAAC,CAAC,CAAC;MAChD,EAAEd,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;IAC/C,CAAC;IACD,MAAM,IAAI,CAACX,KAAK,CAACC,mBAAmB,CAAC,CAAC;IACtC,OAAOM,OAAO;EAChB;;EAEAiB,eAAeA;EACbC,QAAgD;EAChD9B,MAAiB;EACH;IACd,OAAO,IAAI,CAACmB,MAAM,CAACU,eAAe,CAAC;MACjCE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC;EACJ;;EAEA;EACAoC,iCAAiCA,CAAC9D,KAAa,EAAsB;IACnE,MAAM+D,WAAW,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB/D,KAAM;AACzB;AACA,KAAK;;IAED,OAAO,IAAI,CAAC6C,MAAM,CAACmB,qBAAqB,CAAC;MACvCP,MAAM,EAAE,MAAM;MACdQ,OAAO,EAAE;QACPC,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEL;QACR,CAAC,CAAC;QACFM,UAAU,EAAE;MACd;IACF,CAAC,CAAC;EACJ;;EAEAC,2BAA2BA,CAACC,WAAiD,EAAE;IAC7E,OAAO,IAAI,CAAC1B,MAAM,CAAC2B,oBAAoB,CAAC;MACtCf,MAAM,EAAE,MAAM;MACdgB,MAAM,EAAE;QACNP,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACE;QACpB,CAAC,CAAC;QACFJ,UAAU,EAAE;MACd,CAAC;MACDK,QAAQ,EAAE;QACRR,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACG;QACpB,CAAC,CAAC;QACFL,UAAU,EAAE,WAAW;QACvBM,OAAO,EAAE,CAAC,EAAEhC,MAAM,EAAE,YAAY,CAAC,CAAC;MACpC,CAAC;MACDiC,SAAS,EAAE,EAAEC,QAAQ,EAAE,YAAY,CAAC;IACtC,CAAC,CAAC;EACJ;;EAEA;EACAC,gCAAgCA,CAAC9E,KAAa,EAAqB;IACjE,MAAMuE,WAAW,GAAG;MAClBE,MAAM,EAAEjF,kBAAkB;MAC1BkF,QAAQ,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB1E,KAAM;AACzB;AACA;AACA;IACI,CAAC;;IAED,OAAO,IAAI,CAACsE,2BAA2B,CAACC,WAAW,CAAC;EACtD;;EAEAQ,qBAAqBA,CAACC,OAA0B,EAAwB;IACtE,MAAMC,IAAI,GAAG,IAAI,CAAC1C,oBAAoB,CAAC;MACrC1B,IAAI,EAAE,EAAE2B,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACpDC,MAAM,EAAE,YAAY;MACpB3B,KAAK,EAAE4B,eAAe,CAACsC;IACzB,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC;IACf,OAAOH,OAAO,CAACI,eAAe,CAAC;MAC7BC,gBAAgB,EAAE;MAChB;QACEJ,IAAI;QACJK,UAAU,EAAE,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;QAC9CC,MAAM,EAAE,OAAO;QACfC,OAAO,EAAE;MACX,CAAC;;IAEL,CAAC,CAAC;EACJ;;EAEA;EACAC,sCAAsCA;EACpCC,QAAuD;EACvDpE,MAAiB;EACjB1B,KAAa;EACb;IACA,MAAMwD,QAAQ,GAAG,IAAI,CAACsB,gCAAgC,CAAC9E,KAAK,CAAC;IAC7D,MAAM+F,SAAS,GAAG,IAAI,CAACxC,eAAe,CAACC,QAAQ,EAAE9B,MAAM,CAAC;;IAExDoE,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACI,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC3B;;EAEA;EACAC,uCAAuCA;EACrCC,IAA2B;EAC3B1E,MAAiB;EACjB1B,KAAa;EACb;IACA,MAAMwD,QAAQ,GAAG,IAAI,CAACM,iCAAiC,CAAC9D,KAAK,CAAC;IAC9D,MAAM+F,SAAS,GAAG,IAAI,CAACxC,eAAe,CAACC,QAAQ,EAAE9B,MAAM,CAAC;IACxD0E,IAAI,CAACH,WAAW,CAACzC,QAAQ,CAAC;IAC1B4C,IAAI,CAACJ,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IAC/BK,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAAC;EAC5B;;EAEA;EACAC,oBAAoBA,CAACtB,OAA0B,EAAEtD,MAAiB,EAAE3B,IAAY,EAAE;IAChF,MAAMwG,SAAS,GAAG,IAAI,CAAC7G,eAAe,CAACK,IAAI,CAAC;IAC5CxB,MAAM,CAACgI,SAAS,KAAK5G,SAAS,CAAC;IAC/B;IACAqF,OAAO,CAACwB,kBAAkB,CAACD,SAAS,EAAE,CAAC,EAAE7E,MAAM,EAAE,CAAC,EAAEZ,WAAW,CAACC,iBAAiB,CAAC;EACpF;;EAEA;EACA0F,oBAAoBA,CAACzB,OAA0B,EAAEtD,MAAiB,EAAE3B,IAAY,EAAE;IAChF,MAAM2G,UAAU,GAAG,IAAI,CAAC9G,gBAAgB,CAACG,IAAI,CAAC;IAC9CxB,MAAM,CAACmI,UAAU,KAAK/G,SAAS,CAAC;IAChC;IACAqF,OAAO,CAAC2B,mBAAmB;MACzB,EAAErE,OAAO,EAAEoE,UAAU,EAAE3D,QAAQ,EAAE,CAAC,EAAEC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MAClE,EAAEzB,MAAM,EAAE2B,WAAW,EAAE,GAAG,CAAC,CAAC;MAC5B,EAAEb,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;IAC/C,CAAC;EACH;;EAEA;EACAkE,kBAAkBA,CAAClF,MAAiB,EAAE1B,KAAa,EAAE;IACnD;IACA,MAAMqC,IAAI,GAAG,IAAIvB,WAAW,CAAC,CAAC,CAAC,CAACe,IAAI,CAAC7B,KAAK,CAAC;IAC3C,IAAI,CAAC6C,MAAM,CAACd,KAAK,CAAC8E,WAAW,CAACnF,MAAM,EAAE,CAAC,EAAEW,IAAI,CAAC;EAChD;;EAEA;EACAyE,aAAaA;EACXC,MAA8B;EAC9BC,SAAkB;EAClB9H,OAAyB;EACzBwC,MAAiB;EACjBuF,WAAmB;EACnBjH,KAAa;EACb;IACA+G,MAAM,CAACG,aAAa,CAAChI,OAAO,CAAC;;IAE7B,QAAQ8H,SAAS;MACf,KAAK,cAAc;QACjB,IAAI,CAACJ,kBAAkB,CAAClF,MAAM,EAAE1B,KAAK,CAAC;QACtC;MACF,KAAK,SAAS;QACZ,QAAQd,OAAO;UACb,KAAK,qBAAqB;YACxBX,MAAM,CAACwI,MAAM,CAACI,iBAAiB,KAAKxH,SAAS,CAAC;YAC9C,IAAI,CAACkG,sCAAsC,CAACkB,MAAM,CAACI,iBAAiB,EAAEzF,MAAM,EAAE1B,KAAK,CAAC;YACpF;UACF,KAAK,uBAAuB;YAC1BzB,MAAM,CAACwI,MAAM,CAACK,mBAAmB,KAAKzH,SAAS,CAAC;YAChD,IAAI,CAACkG,sCAAsC,CAACkB,MAAM,CAACK,mBAAmB,EAAE1F,MAAM,EAAE1B,KAAK,CAAC;YACtF;UACF,KAAK,sBAAsB;YACzBzB,MAAM,CAACwI,MAAM,CAACM,kBAAkB,KAAK1H,SAAS,CAAC;YAC/C,IAAI,CAACwG,uCAAuC,CAACY,MAAM,CAACM,kBAAkB,EAAE3F,MAAM,EAAE1B,KAAK,CAAC;YACtF;UACF;YACExB,WAAW,CAAC,CAAC;QACjB;QACA;MACF,KAAK,UAAU;QACbD,MAAM,CAACwI,MAAM,CAACO,cAAc,KAAK3H,SAAS,CAAC;QAC3C,IAAI,CAAC2G,oBAAoB,CAACS,MAAM,CAACO,cAAc,EAAE5F,MAAM,EAAEuF,WAAW,CAAC;QACrE;MACF,KAAK,UAAU;QACb1I,MAAM,CAACwI,MAAM,CAACO,cAAc,KAAK3H,SAAS,CAAC;QAC3C,IAAI,CAAC8G,oBAAoB,CAACM,MAAM,CAACO,cAAc,EAAE5F,MAAM,EAAEuF,WAAW,CAAC;QACrE;MACF;QACEzI,WAAW,CAAC,CAAC;IACjB;EACF;;EAEA;EACA+I,gCAAgCA,CAAA,EAAuB;IACrD,MAAMxD,WAAW,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;IAED,OAAO,IAAI,CAAClB,MAAM,CAACmB,qBAAqB,CAAC;MACvCP,MAAM,EAAE,MAAM;MACdQ,OAAO,EAAE;QACPC,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEL;QACR,CAAC,CAAC;QACFM,UAAU,EAAE;MACd;IACF,CAAC,CAAC;EACJ;;EAEAmD,2BAA2BA;EACzBhE,QAAgD;EAChD9C,SAAoB;EACpBC,SAAoB;EACN;IACd,OAAO,IAAI,CAACkC,MAAM,CAACU,eAAe,CAAC;MACjCE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEhB,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/C,EAAEkD,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;;IAEnD,CAAC,CAAC;EACJ;;EAEA;EACA8G,8BAA8BA,CAAA,EAAsB;IAClD,MAAMlD,WAAW,GAAG;MAClBE,MAAM,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;MACDC,QAAQ,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,CAAC;;IAED,OAAO,IAAI,CAAC7B,MAAM,CAAC2B,oBAAoB,CAAC;MACtCf,MAAM,EAAE,MAAM;MACdgB,MAAM,EAAE;QACNP,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACE;QACpB,CAAC,CAAC;QACFJ,UAAU,EAAE,WAAW;QACvBqD,OAAO,EAAE;QACP;UACEC,WAAW,EAAE7G,WAAW,CAACC,iBAAiB;UAC1C6G,UAAU,EAAE;UACV;YACEC,cAAc,EAAE,CAAC;YACjBzE,MAAM,EAAE,CAAC;YACTT,MAAM,EAAE;UACV,CAAC;;QAEL,CAAC;;MAEL,CAAC;MACD+B,QAAQ,EAAE;QACRR,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACG;QACpB,CAAC,CAAC;QACFL,UAAU,EAAE,WAAW;QACvBM,OAAO,EAAE,CAAC,EAAEhC,MAAM,EAAE,YAAY,CAAC,CAAC;MACpC,CAAC;MACDiC,SAAS,EAAE,EAAEC,QAAQ,EAAE,YAAY,CAAC;IACtC,CAAC,CAAC;EACJ;;EAEA;EACAiD,+BAA+BA,CAAA,EAAsB;IACnD,MAAMvD,WAAW,GAAG;MAClBE,MAAM,EAAEjF,kBAAkB;MAC1BkF,QAAQ,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,CAAC;;IAED,OAAO,IAAI,CAACJ,2BAA2B,CAACC,WAAW,CAAC;EACtD;;EAEA;EACAwD,+BAA+BA,CAAA,EAAsB;IACnD,MAAMxD,WAAW,GAAG;MAClBE,MAAM,EAAEjF,kBAAkB;MAC1BkF,QAAQ,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,CAAC;;IAED,OAAO,IAAI,CAAC7B,MAAM,CAAC2B,oBAAoB,CAAC;MACtCf,MAAM,EAAE,MAAM;MACdgB,MAAM,EAAE;QACNP,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACE;QACpB,CAAC,CAAC;QACFJ,UAAU,EAAE;MACd,CAAC;MACDK,QAAQ,EAAE;QACRR,MAAM,EAAE,IAAI,CAACrB,MAAM,CAACsB,kBAAkB,CAAC;UACrCC,IAAI,EAAEG,WAAW,CAACG;QACpB,CAAC,CAAC;QACFL,UAAU,EAAE,WAAW;QACvBM,OAAO,EAAE,CAAC,EAAEhC,MAAM,EAAE,YAAY,CAAC,CAAC;MACpC,CAAC;MACDiC,SAAS,EAAE,EAAEC,QAAQ,EAAE,YAAY,CAAC;IACtC,CAAC,CAAC;EACJ;;EAEA;EACAmD,sCAAsCA;EACpC5B,IAA2B;EAC3B1F,SAAoB;EACpBC,SAAoB;EACpB;IACA,MAAM6C,QAAQ,GAAG,IAAI,CAAC+D,gCAAgC,CAAC,CAAC;IACxD,MAAMxB,SAAS,GAAG,IAAI,CAACyB,2BAA2B,CAAChE,QAAQ,EAAE9C,SAAS,EAAEC,SAAS,CAAC;IAClFyF,IAAI,CAACH,WAAW,CAACzC,QAAQ,CAAC;IAC1B4C,IAAI,CAACJ,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IAC/BK,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAAC;EAC5B;;EAEA;EACA4B,uCAAuCA;EACrC7B,IAA2B;EAC3B1F,SAAoB;EACpBC,SAAoB;EACpBX,KAAa;EACb;IACA,MAAMwD,QAAQ,GAAG,IAAI,CAACM,iCAAiC,CAAC9D,KAAK,CAAC;IAC9D,MAAM+F,SAAS,GAAG,IAAI,CAACxC,eAAe,CAACC,QAAQ,EAAE7C,SAAS,CAAC;IAC3DyF,IAAI,CAACH,WAAW,CAACzC,QAAQ,CAAC;IAC1B4C,IAAI,CAACJ,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IAC/BK,IAAI,CAAC8B,0BAA0B,CAACxH,SAAS,EAAE,CAAC,CAAC;EAC/C;;EAEA;EACAyH,oCAAoCA;EAClCrC,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpB;IACA,MAAM6C,QAAQ,GAAG,IAAI,CAACiE,8BAA8B,CAAC,CAAC;IACtD,MAAM1B,SAAS,GAAG,IAAI,CAAClD,MAAM,CAACU,eAAe,CAAC;MAC5CE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;;IAEFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACsC,eAAe,CAAC,CAAC,EAAE1H,SAAS,CAAC;IACtCoF,QAAQ,CAACI,IAAI,CAAC,CAAC,CAAC;EAClB;;EAEA;EACAmC,mCAAmCA;EACjCvC,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpBJ,YAAuB;EACvB;IACA,MAAMiD,QAAQ,GAAG,IAAI,CAACiE,8BAA8B,CAAC,CAAC;IACtD,MAAM1B,SAAS,GAAG,IAAI,CAAClD,MAAM,CAACU,eAAe,CAAC;MAC5CE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;;IAEFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACsC,eAAe,CAAC,CAAC,EAAE7H,YAAY,CAAC;IACzCuF,QAAQ,CAACwC,cAAc,CAAC5H,SAAS,EAAE,QAAQ,CAAC;IAC5CoF,QAAQ,CAACyC,WAAW,CAAC,CAAC,CAAC;EACzB;;EAEA;EACAC,sCAAsCA;EACpC1C,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpBJ,YAAuB;EACvB;IACA,MAAMiD,QAAQ,GAAG,IAAI,CAACiE,8BAA8B,CAAC,CAAC;IACtD,MAAM1B,SAAS,GAAG,IAAI,CAAClD,MAAM,CAACU,eAAe,CAAC;MAC5CE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;;IAEFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACsC,eAAe,CAAC,CAAC,EAAE7H,YAAY,CAAC;IACzCuF,QAAQ,CAAC2C,YAAY,CAAC/H,SAAS,EAAE,CAAC,CAAC;EACrC;;EAEA;EACAgI,6CAA6CA;EAC3C5C,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpBJ,YAAuB;EACvBE,WAAsB;EACtB;IACA,MAAM+C,QAAQ,GAAG,IAAI,CAACiE,8BAA8B,CAAC,CAAC;IACtD,MAAM1B,SAAS,GAAG,IAAI,CAAClD,MAAM,CAACU,eAAe,CAAC;MAC5CE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;;IAEFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACsC,eAAe,CAAC,CAAC,EAAE7H,YAAY,CAAC;IACzCuF,QAAQ,CAACwC,cAAc,CAAC7H,WAAW,EAAE,QAAQ,CAAC;IAC9CqF,QAAQ,CAAC6C,mBAAmB,CAACjI,SAAS,EAAE,CAAC,CAAC;EAC5C;;EAEA;EACAkI,qCAAqCA;EACnC9C,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpB;IACA,MAAM6C,QAAQ,GAAG,IAAI,CAACsE,+BAA+B,CAAC,CAAC;IACvD,MAAM/B,SAAS,GAAG,IAAI,CAAClD,MAAM,CAACU,eAAe,CAAC;MAC5CE,MAAM,EAAED,QAAQ,CAACE,kBAAkB,CAAC,CAAC,CAAC;MACtCC,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEhB,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/C,EAAEkD,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEnC,MAAM,EAAEf,SAAS,CAAC,CAAC,CAAC,CAAC;;IAEnD,CAAC,CAAC;;IAEFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACI,IAAI,CAAC,CAAC,CAAC;EAClB;;EAEA;EACA2C,qCAAqCA;EACnC/C,QAAuD;EACvDpF,SAAoB;EACpBC,SAAoB;EACpB;IACA,MAAM6C,QAAQ,GAAG,IAAI,CAACuE,+BAA+B,CAAC,CAAC;IACvD,MAAMhC,SAAS,GAAG,IAAI,CAACyB,2BAA2B,CAAChE,QAAQ,EAAE9C,SAAS,EAAEC,SAAS,CAAC;;IAElFmF,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAED,SAAS,CAAC;IACnCD,QAAQ,CAACG,WAAW,CAACzC,QAAQ,CAAC;IAC9BsC,QAAQ,CAACI,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC3B;;EAEA;EACA4C,mBAAmBA,CAAC9D,OAA0B,EAAEtE,SAAoB,EAAEC,SAAoB,EAAE;IAC1F;IACAqE,OAAO,CAACwB,kBAAkB,CAAC9F,SAAS,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEG,WAAW,CAACC,iBAAiB,CAAC;EACvF;;EAEA;EACAgI,mBAAmBA,CAAC/D,OAA0B,EAAEtE,SAAoB,EAAEC,SAAoB,EAAE;IAC1F,MAAM+F,UAAU,GAAG,IAAI,CAACnE,oBAAoB,CAAC;MAC3C1B,IAAI,EAAE,EAAE2B,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACpDC,MAAM,EAAE,SAAS;MACjB3B,KAAK,EAAE4B,eAAe,CAAC1B,QAAQ,GAAG0B,eAAe,CAACzB;IACpD,CAAC,CAAC;;IAEF;IACA6D,OAAO,CAACgE,mBAAmB;MACzB,EAAEtH,MAAM,EAAEhB,SAAS,EAAE2C,WAAW,EAAE,GAAG,CAAC,CAAC;MACvC,EAAEf,OAAO,EAAEoE,UAAU,EAAE3D,QAAQ,EAAE,CAAC,EAAEC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MAClE,EAAEX,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;IAC/C,CAAC;IACD;IACAsC,OAAO,CAAC2B,mBAAmB;MACzB,EAAErE,OAAO,EAAEoE,UAAU,EAAE3D,QAAQ,EAAE,CAAC,EAAEC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MAClE,EAAEzB,MAAM,EAAEf,SAAS,EAAE0C,WAAW,EAAE,GAAG,CAAC,CAAC;MACvC,EAAEb,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;IAC/C,CAAC;EACH;;EAEAuG,YAAYA;EACVlC,MAA8B;EAC9BC,SAAiB;EACjB9H,OAAyB;EACzBwB,SAAoB;EACpBC,SAAoB;EACpB;IACAoG,MAAM,CAACG,aAAa,CAAChI,OAAO,CAAC;;IAE7B,MAAM4G,QAAQ;IACZ5G,OAAO,KAAK,uBAAuB,GAAG6H,MAAM,CAACK,mBAAmB,GAAGL,MAAM,CAACI,iBAAiB;IAC7F,MAAM+B,WAAW,GAAGhK,OAAO,KAAK,sBAAsB,GAAG6H,MAAM,CAACM,kBAAkB,GAAG1H,SAAS;;IAE9F,QAAQqH,SAAS;MACf,KAAK,cAAc;QACjB;QACA;QACAzI,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;QAC9B,IAAI,CAACwI,oCAAoC,CAACrC,QAAQ,EAAEpF,SAAS,EAAEC,SAAS,CAAC;QACzE;MACF,KAAK,aAAa;QAChB;QACA;QACApC,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;QAC9BpB,MAAM,CAAC,IAAI,CAACgC,YAAY,KAAKZ,SAAS,CAAC;QACvC,IAAI,CAAC0I,mCAAmC,CAACvC,QAAQ,EAAEpF,SAAS,EAAEC,SAAS,EAAE,IAAI,CAACJ,YAAY,CAAC;QAC3F;MACF,KAAK,gBAAgB;QACnB;QACA;QACAhC,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;QAC9BpB,MAAM,CAAC,IAAI,CAACgC,YAAY,KAAKZ,SAAS,CAAC;QACvC,IAAI,CAAC6I,sCAAsC;UACzC1C,QAAQ;UACRpF,SAAS;UACTC,SAAS;UACT,IAAI,CAACJ;QACP,CAAC;QACD;MACF,KAAK,sBAAsB;QACzB;QACA;QACAhC,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;QAC9BpB,MAAM,CAAC,IAAI,CAACgC,YAAY,KAAKZ,SAAS,CAAC;QACvCpB,MAAM,CAAC,IAAI,CAACkC,WAAW,KAAKd,SAAS,CAAC;QACtC,IAAI,CAAC+I,6CAA6C;UAChD5C,QAAQ;UACRpF,SAAS;UACTC,SAAS;UACT,IAAI,CAACJ,YAAY;UACjB,IAAI,CAACE;QACP,CAAC;QACD;MACF,KAAK,yBAAyB;QAC5B;QACA;QACAlC,MAAM,CAAC2K,WAAW,KAAKvJ,SAAS,CAAC;QACjC,IAAI,CAACsI,uCAAuC,CAACiB,WAAW,EAAExI,SAAS,EAAEC,SAAS,EAAE,CAAC,CAAC;QAClF;MACF,KAAK,kBAAkB;QACrB;QACApC,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;QAC9B,IAAI,CAACiJ,qCAAqC,CAAC9C,QAAQ,EAAEpF,SAAS,EAAEC,SAAS,CAAC;QAC1E;MACF,KAAK,cAAc;QACjB,QAAQzB,OAAO;UACb,KAAK,qBAAqB;UAC1B,KAAK,uBAAuB;YAC1BX,MAAM,CAACuH,QAAQ,KAAKnG,SAAS,CAAC;YAC9B,IAAI,CAACkJ,qCAAqC,CAAC/C,QAAQ,EAAEpF,SAAS,EAAEC,SAAS,CAAC;YAC1E;UACF,KAAK,sBAAsB;YACzBpC,MAAM,CAAC2K,WAAW,KAAKvJ,SAAS,CAAC;YACjC,IAAI,CAACqI,sCAAsC,CAACkB,WAAW,EAAExI,SAAS,EAAEC,SAAS,CAAC;YAC9E;UACF;YACEnC,WAAW,CAAC,CAAC;QACjB;QACA;MACF,KAAK,UAAU;QACbD,MAAM,CAACwI,MAAM,CAACO,cAAc,KAAK3H,SAAS,CAAC;QAC3C,IAAI,CAACmJ,mBAAmB,CAAC/B,MAAM,CAACO,cAAc,EAAE5G,SAAS,EAAEC,SAAS,CAAC;QACrE;MACF,KAAK,UAAU;QACbpC,MAAM,CAACwI,MAAM,CAACO,cAAc,KAAK3H,SAAS,CAAC;QAC3C,IAAI,CAACoJ,mBAAmB,CAAChC,MAAM,CAACO,cAAc,EAAE5G,SAAS,EAAEC,SAAS,CAAC;QACrE;MACF;QACEnC,WAAW,CAAC,CAAC;IACjB;EACF;;EAEA2K,UAAUA,CAACzH,MAAiB,EAAE0H,aAAqB,EAAE;IACnD;IACA,MAAMC,UAAU,GAAG,IAAIvI,WAAW,CAAC,CAAC,CAAC;IACrCuI,UAAU,CAAC,CAAC,CAAC,GAAGD,aAAa;IAC7B,IAAI,CAACE,0BAA0B,CAAC5H,MAAM,EAAE2H,UAAU,CAAC;EACrD;;EAEAE,wBAAwBA,CAAC7H,MAAiB,EAAE8H,cAAsB,EAAEC,cAAsB,EAAE;IAC1F;IACA,MAAMC,WAAW,GAAG,IAAI5I,WAAW,CAAC,CAAC,CAAC;IACtC4I,WAAW,CAAC,CAAC,CAAC,GAAGF,cAAc;IAC/B,MAAMG,WAAW,GAAG,IAAI7I,WAAW,CAAC,CAAC,CAAC;IACtC6I,WAAW,CAAC,CAAC,CAAC,GAAGF,cAAc;IAC/B,IAAI,CAACG,8BAA8B;MACjClI,MAAM;MACN,CAAAgE,CAAC,KAAIhH,wBAAwB,CAACgH,CAAC,EAAE,CAACgE,WAAW,EAAEC,WAAW,CAAC,CAAC;MAC5D,EAAEE,IAAI,EAAE/I,WAAW,EAAEgJ,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;EACH;AACF"}
{"version":3,"file":"buffer_sync_test.js","names":["assert","unreachable","GPUTest","checkElementsEqualEither","kAllWriteOps","kAllReadOps","kOpInfo","contexts","checkOpsValidForContext","ops","context","valid","includes","checkImpl","op1","op2","kDummyVertexShader","BufferSyncTest","tmpValueBuffers","undefined","tmpValueTextures","createIntermediateBuffersAndTexturesForWriteOp","writeOp","slot","value","createBufferWithValue","createTextureWithValue","createBuffersForReadOp","readOp","srcValue","opValue","vertexBuffer","createBufferWithValues","indexBuffer","srcBuffer","dstBuffer","trackForCleanup","device","createBuffer","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","VERTEX","INDEX","INDIRECT","UNIFORM","initValue","buffer","mappedAtCreation","getMappedRange","fill","unmap","queue","onSubmittedWorkDone","initValues","length","bufferView","set","data","texture","createTexture","width","height","depthOrArrayLayers","format","GPUTextureUsage","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","wgslCompute","createComputePipeline","compute","module","createShaderModule","code","entryPoint","createTrivialRenderPipeline","wgslShaders","createRenderPipeline","vertex","fragment","targets","primitive","topology","createStorageWriteRenderPipeline","beginSimpleRenderPass","encoder","view","RENDER_ATTACHMENT","createView","beginRenderPass","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","encodeWriteAsStorageBufferInRenderPass","renderer","bindGroup","setBindGroup","setPipeline","draw","encodeWriteAsStorageBufferInComputePass","pass","dispatchWorkgroups","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","helper","operation","writeOpSlot","ensureContext","renderPassEncoder","renderBundleEncoder","computePassEncoder","commandEncoder","createStorageReadComputePipeline","createBindGroupSrcDstBuffer","createVertexReadRenderPipeline","buffers","arrayStride","attributes","shaderLocation","createUniformReadRenderPipeline","createStorageReadRenderPipeline","encodeReadAsStorageBufferInComputePass","encodeReadAsIndirectBufferInComputePass","dispatchWorkgroupsIndirect","encodeReadAsVertexBufferInRenderPass","setVertexBuffer","encodeReadAsIndexBufferInRenderPass","setIndexBuffer","drawIndexed","encodeReadAsIndirectBufferInRenderPass","drawIndirect","encodeReadAsIndexedIndirectBufferInRenderPass","drawIndexedIndirect","encodeReadAsUniformBufferInRenderPass","encodeReadAsStorageBufferInRenderPass","encodeReadByB2BCopy","encodeReadByB2TCopy","copyBufferToTexture","encodeReadOp","computePass","verifyData","expectedValue","bufferData","expectGPUBufferValuesEqual","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectGPUBufferValuesPassCheck","type","typedLength"],"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"sourcesContent":["import { assert, unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { checkElementsEqualEither } from '../../../../util/check_contents.js';\nimport { OperationContext, OperationContextHelper } from '../operation_context_helper.js';\n\nexport const kAllWriteOps = ['storage', 'b2b-copy', 't2b-copy', 'write-buffer'] as const;\n\nexport const kAllReadOps = [\n  'input-vertex',\n  'input-index',\n  'input-indirect',\n  'input-indirect-index',\n  'input-indirect-dispatch',\n\n  'constant-uniform',\n\n  'storage-read',\n\n  'b2b-copy',\n  'b2t-copy',\n] as const;\n\nexport type ReadOp = typeof kAllReadOps[number];\nexport type WriteOp = typeof kAllWriteOps[number];\n\nexport type Op = ReadOp | WriteOp;\n\ninterface OpInfo {\n  readonly contexts: OperationContext[];\n}\n\nconst kOpInfo: {\n  readonly [k in Op]: OpInfo;\n} = /* prettier-ignore */ {\n  'write-buffer': {\n    contexts: [ 'queue' ],\n  },\n  'b2t-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  'b2b-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  't2b-copy': {\n    contexts: [ 'command-encoder' ],\n  },\n  'storage': {\n    contexts: [ 'compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'storage-read': {\n    contexts: [ 'compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-vertex': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-index': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect-index': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n  'input-indirect-dispatch': {\n    contexts: [ 'compute-pass-encoder' ],\n  },\n  'constant-uniform': {\n    contexts: [ 'render-pass-encoder', 'render-bundle-encoder' ],\n  },\n};\n\nexport function checkOpsValidForContext(\n  ops: [Op, Op],\n  context: [OperationContext, OperationContext]\n) {\n  const valid =\n    kOpInfo[ops[0]].contexts.includes(context[0]) && kOpInfo[ops[1]].contexts.includes(context[1]);\n  if (!valid) return false;\n\n  if (\n    context[0] === 'render-bundle-encoder' ||\n    context[0] === 'render-pass-encoder' ||\n    context[1] === 'render-bundle-encoder' ||\n    context[1] === 'render-pass-encoder'\n  ) {\n    // In a render pass, it is invalid to use a resource as both writable and another usage.\n    // Also, for storage+storage usage, the application is opting into racy behavior.\n    // The storage+storage case is also skipped as the results cannot be reliably tested.\n    const checkImpl = (op1: Op, op2: Op) => {\n      switch (op1) {\n        case 'storage':\n          switch (op2) {\n            case 'storage':\n            case 'storage-read':\n            case 'input-vertex':\n            case 'input-index':\n            case 'input-indirect':\n            case 'input-indirect-index':\n            case 'constant-uniform':\n              // Write+other, or racy.\n              return false;\n            case 'b2t-copy':\n            case 't2b-copy':\n            case 'b2b-copy':\n            case 'write-buffer':\n              // These don't occur in a render pass.\n              return true;\n          }\n          break;\n        case 'input-vertex':\n        case 'input-index':\n        case 'input-indirect':\n        case 'input-indirect-index':\n        case 'constant-uniform':\n        case 'b2t-copy':\n        case 't2b-copy':\n        case 'b2b-copy':\n        case 'write-buffer':\n          // These are not write usages, or don't occur in a render pass.\n          break;\n      }\n      return true;\n    };\n    return checkImpl(ops[0], ops[1]) && checkImpl(ops[1], ops[0]);\n  }\n  return true;\n}\n\nconst kDummyVertexShader = `\n@vertex fn vert_main() -> @builtin(position) vec4<f32> {\n  return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n}\n`;\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Vertex and index buffers used in read render pass\n  vertexBuffer?: GPUBuffer;\n  indexBuffer?: GPUBuffer;\n\n  // Temp buffer and texture with values for buffer/texture copy write op\n  // There can be at most 2 write op\n  tmpValueBuffers: (GPUBuffer | undefined)[] = [undefined, undefined];\n  tmpValueTextures: (GPUTexture | undefined)[] = [undefined, undefined];\n\n  // These intermediate buffers/textures are created before any read/write op\n  // to avoid extra memory synchronization between ops introduced by await on buffer/texture creations.\n  // Create extra buffers/textures needed by write operation\n  async createIntermediateBuffersAndTexturesForWriteOp(\n    writeOp: WriteOp,\n    slot: number,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'b2b-copy':\n        this.tmpValueBuffers[slot] = await this.createBufferWithValue(value);\n        break;\n      case 't2b-copy':\n        this.tmpValueTextures[slot] = await this.createTextureWithValue(value);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Create extra buffers/textures needed by read operation\n  async createBuffersForReadOp(readOp: ReadOp, srcValue: number, opValue: number) {\n    // This helps create values that will be written into dst buffer by the readop\n    switch (readOp) {\n      case 'input-index':\n        // The index buffer will be the src buffer of the read op.\n        // The src value for readOp will be 0\n        // If the index buffer value is 0, the src value is written into the dst buffer.\n        // If the index buffer value is 1, the op value is written into the dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([srcValue, opValue]);\n        break;\n      case 'input-indirect':\n        // The indirect buffer for the draw cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the op value in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        break;\n      case 'input-indirect-index':\n        // The indirect buffer for draw indexed cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the opValue in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        this.indexBuffer = await this.createBufferWithValues([0]);\n        break;\n      default:\n        break;\n    }\n\n    let srcBuffer: GPUBuffer;\n    switch (readOp) {\n      case 'input-indirect':\n        // vertexCount = {0, 1}\n        // instanceCount = 1\n        // firstVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0]);\n        break;\n      case 'input-indirect-index':\n        // indexCount = {0, 1}\n        // instanceCount = 1\n        // firstIndex = 0\n        // baseVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0, 0]);\n        break;\n      case 'input-indirect-dispatch':\n        // workgroupCountX = {0, 1}\n        // workgroupCountY = 1\n        // workgroupCountZ = 1\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 1]);\n        break;\n      default:\n        srcBuffer = await this.createBufferWithValue(srcValue);\n        break;\n    }\n\n    const dstBuffer = this.trackForCleanup(\n      this.device.createBuffer({\n        size: Uint32Array.BYTES_PER_ELEMENT,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n\n    return { srcBuffer, dstBuffer };\n  }\n\n  // Create a buffer with 1 uint32 element, and initialize it to a specified value.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const buffer = this.trackForCleanup(\n      this.device.createBuffer({\n        mappedAtCreation: true,\n        size: Uint32Array.BYTES_PER_ELEMENT,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a buffer, and initialize it to the specified values.\n  async createBufferWithValues(initValues: number[]): Promise<GPUBuffer> {\n    const buffer = this.trackForCleanup(\n      this.device.createBuffer({\n        mappedAtCreation: true,\n        size: Uint32Array.BYTES_PER_ELEMENT * initValues.length,\n        usage:\n          GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.COPY_DST |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.VERTEX |\n          GPUBufferUsage.INDEX |\n          GPUBufferUsage.INDIRECT |\n          GPUBufferUsage.UNIFORM,\n      })\n    );\n    const bufferView = new Uint32Array(buffer.getMappedRange());\n    bufferView.set(initValues);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a 1x1 texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    const data = new Uint32Array(1).fill(initValue);\n    const texture = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'r32uint',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n    this.device.queue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: 256, rowsPerImage: 1 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    await this.queue.onSubmittedWorkDone();\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @compute @workgroup_size(1) fn main() {\n        data.a = ${value}u;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createTrivialRenderPipeline(wgslShaders: { vertex: string; fragment: string }) {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = ${value}u;\n        return vec4<f32>();  // result does't matter\n      }\n    `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n    ).createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view,\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via BufferToBuffer copy.\n  encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpBuffer = this.tmpValueBuffers[slot];\n    assert(tmpBuffer !== undefined);\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpTexture = this.tmpValueTextures[slot];\n    assert(tmpTexture !== undefined);\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    const data = new Uint32Array(1).fill(value);\n    this.device.queue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  encodeWriteOp(\n    helper: OperationContextHelper,\n    operation: WriteOp,\n    context: OperationContext,\n    buffer: GPUBuffer,\n    writeOpSlot: number,\n    value: number\n  ) {\n    helper.ensureContext(context);\n\n    switch (operation) {\n      case 'write-buffer':\n        this.writeByWriteBuffer(buffer, value);\n        break;\n      case 'storage':\n        switch (context) {\n          case 'render-pass-encoder':\n            assert(helper.renderPassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderPassEncoder, buffer, value);\n            break;\n          case 'render-bundle-encoder':\n            assert(helper.renderBundleEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderBundleEncoder, buffer, value);\n            break;\n          case 'compute-pass-encoder':\n            assert(helper.computePassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInComputePass(helper.computePassEncoder, buffer, value);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByB2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      case 't2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByT2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  // Create a compute pipeline: read from src buffer and write it into the storage buffer.\n  createStorageReadComputePipeline(): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read> srcData : Data;\n      @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n      @compute @workgroup_size(1) fn main() {\n        dstData.a = srcData.a;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createBindGroupSrcDstBuffer(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n  }\n\n  // Create a render pipeline: read from vertex/index buffer and write it into the storage dst buffer at fragment stage.\n  createVertexReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      struct VertexOutput {\n        @builtin(position) position : vec4<f32>,\n        @location(0) @interpolate(flat) data : u32,\n      };\n\n      @vertex fn vert_main(@location(0) input: u32) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4<f32>(0.5, 0.5, 0.0, 1.0);\n        output.data = input;\n        return output;\n      }\n      `,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main(@location(0) @interpolate(flat) input : u32) -> @location(0) vec4<f32> {\n        data.a = input;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: 0,\n                format: 'uint32',\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline: read from uniform buffer and write it into the storage dst buffer at fragment stage.\n  createUniformReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<uniform> constant: Data;\n      @group(0) @binding(1) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = constant.a;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  // Create a render pipeline: read from storage src buffer and write it into the storage dst buffer at fragment stage.\n  createStorageReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n        struct Data {\n          a : u32\n        };\n\n        @group(0) @binding(0) var<storage, read> srcData : Data;\n        @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n        @fragment fn frag_main() -> @location(0) vec4<f32> {\n          dstData.a = srcData.a;\n          return vec4<f32>();  // result does't matter\n        }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeReadAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadComputePipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via dispatchWorkgroupsIndirect call in compute pass.\n  encodeReadAsIndirectBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroupsIndirect(srcBuffer, 0);\n  }\n\n  // Read as vertex input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsVertexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, srcBuffer);\n    renderer.draw(1);\n  }\n\n  // Read as index input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(srcBuffer, 'uint32');\n    renderer.drawIndexed(1);\n  }\n\n  // Read as indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.drawIndirect(srcBuffer, 0);\n  }\n\n  // Read as indexed indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexedIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer,\n    indexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(indexBuffer, 'uint32');\n    renderer.drawIndexedIndirect(srcBuffer, 0);\n  }\n\n  // Read as uniform buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsUniformBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createUniformReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1);\n  }\n\n  // Read as storage buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadRenderPipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Read and write via BufferToBuffer copy.\n  encodeReadByB2BCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    // The b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Read and Write texture via BufferToTexture copy.\n  encodeReadByB2TCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    const tmpTexture = this.trackForCleanup(\n      this.device.createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'r32uint',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n\n    // The b2t copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToTexture(\n      { buffer: srcBuffer, bytesPerRow: 256 },\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    // The t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: dstBuffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  encodeReadOp(\n    helper: OperationContextHelper,\n    operation: ReadOp,\n    context: OperationContext,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    helper.ensureContext(context);\n\n    const renderer =\n      context === 'render-bundle-encoder' ? helper.renderBundleEncoder : helper.renderPassEncoder;\n    const computePass = context === 'compute-pass-encoder' ? helper.computePassEncoder : undefined;\n\n    switch (operation) {\n      case 'input-vertex':\n        // The srcBuffer is used as vertexBuffer.\n        // draw writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        this.encodeReadAsVertexBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'input-index':\n        // The srcBuffer is used as indexBuffer.\n        // With this vertexBuffer, drawIndexed writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndexBufferInRenderPass(renderer, srcBuffer, dstBuffer, this.vertexBuffer);\n        break;\n      case 'input-indirect':\n        // The srcBuffer is used as indirectBuffer for drawIndirect.\n        // srcBuffer[0] = 0 or 1 (vertexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer\n        );\n        break;\n      case 'input-indirect-index':\n        // The srcBuffer is used as indirectBuffer for drawIndexedIndirect.\n        // srcBuffer[0] = 0 or 1 (indexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        assert(this.indexBuffer !== undefined);\n        this.encodeReadAsIndexedIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer,\n          this.indexBuffer\n        );\n        break;\n      case 'input-indirect-dispatch':\n        // The srcBuffer is used as indirectBuffer for dispatch.\n        // srcBuffer[0] = 0 or 1 (workgroupCountX), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(computePass !== undefined);\n        this.encodeReadAsIndirectBufferInComputePass(computePass, srcBuffer, dstBuffer, 1);\n        break;\n      case 'constant-uniform':\n        // The srcBuffer is used as uniform buffer.\n        assert(renderer !== undefined);\n        this.encodeReadAsUniformBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'storage-read':\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder':\n            assert(renderer !== undefined);\n            this.encodeReadAsStorageBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n            break;\n          case 'compute-pass-encoder':\n            assert(computePass !== undefined);\n            this.encodeReadAsStorageBufferInComputePass(computePass, srcBuffer, dstBuffer);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2BCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      case 'b2t-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2TCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectGPUBufferValuesPassCheck(\n      buffer,\n      a => checkElementsEqualEither(a, [bufferData1, bufferData2]),\n      { type: Uint32Array, typedLength: 1 }\n    );\n  }\n}\n"],"mappings":"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"}
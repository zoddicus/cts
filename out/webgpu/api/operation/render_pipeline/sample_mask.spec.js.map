{"version":3,"file":"sample_mask.spec.js","names":["description","makeTestGroup","assert","range","GPUTest","TextureTestMixin","checkElementsPassPredicate","checkElementsEqual","TypeF32","TypeU32","TexelView","kColors","Uint8Array","kDepthClearValue","kDepthWriteValue","kStencilClearValue","kStencilReferenceValue","format","depthStencilFormat","kRenderTargetSize","hasSample","rasterizationMask","sampleMask","fragmentShaderOutputMask","sampleIndex","getExpectedColorData","sampleCount","fragmentShaderOutputMaskOrAlphaToCoverageMask","expectedData","Float32Array","i","o","getExpectedDepthData","s","getExpectedStencilData","Uint32Array","kSampleMaskTestShader","F","init","isCompatibility","skip","kSampleTextureSize","sampleTexture","createTextureFromTexelView","fromTexelsAsBytes","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","sampler","device","createSampler","magFilter","minFilter","GetTargetTexture","pipeline","uniformBuffer","colorTargetsCount","undefined","uniformBindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","renderTargetTextures","resolveTargetTextures","renderTargetTexture","createTexture","width","height","depthOrArrayLayers","mipLevelCount","push","resolveTargetTexture","COPY_SRC","depthStencilTexture","renderPassDescriptor","colorAttachments","map","index","view","resolveTarget","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","commandEncoder","createCommandEncoder","passEncoder","beginRenderPass","setPipeline","setBindGroup","setStencilReference","draw","end","queue","submit","finish","color","depthStencil","CheckColorAttachmentResult","texture","copySinglePixelTextureToBufferUsingComputePass","expected","expectGPUBufferValuesEqual","CheckDepthStencilResult","aspect","test","desc","params","u","combine","expand","p","maxMask","beginSubcases","fn","t","fragmentMaskUniformBuffer","createBuffer","GPUBufferUsage","UNIFORM","trackForCleanup","writeBuffer","module","createShaderModule","code","createRenderPipeline","vertex","entryPoint","fragment","interpolated","targets","primitive","topology","multisample","count","mask","alphaToCoverageEnabled","depthWriteEnabled","depthCompare","stencilFront","compare","passOp","stencilBack","alpha1","alphaValues","alphaValueUniformBuffer","byteLength","alpha0ParamsArray","colorResultPromises","depthResultPromises","stencilResultPromises","alpha0","colorBuffer","colorResult","readGPUBufferRangeTyped","type","typedLength","BYTES_PER_ELEMENT","depthBuffer","depthResult","stencilBuffer","stencilResult","resultsArray","Promise","all","checkResults","results","getExpectedDataFn","positiveCorrelation","length","result","check","data","expectOK","prevResult","value","cleanup"],"sources":["../../../../../src/webgpu/api/operation/render_pipeline/sample_mask.spec.ts"],"sourcesContent":["export const description = `\nTests that the final sample mask is the logical AND of all the relevant masks, including\nthe rasterization mask, sample mask, fragment output mask, and alpha to coverage mask (when alphaToCoverageEnabled === true).\n\nAlso tested:\n- The positions of samples in the standard sample patterns.\n- Per-sample interpolation sampling: @interpolate(perspective, sample).\n\nTODO: add a test without a 0th color attachment (sparse color attachment), with different color attachments and alpha value output.\nThe cross-platform behavior is unknown. could be any of:\n- coverage is always 100%\n- coverage is always 0%\n- it uses the first non-null attachment\n- it's an error\nDetails could be found at: https://github.com/gpuweb/cts/issues/2201\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\nimport { checkElementsPassPredicate, checkElementsEqual } from '../../../util/check_contents.js';\nimport { TypeF32, TypeU32 } from '../../../util/conversion.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nconst kColors = [\n  // Red\n  new Uint8Array([0xff, 0, 0, 0xff]),\n  // Green\n  new Uint8Array([0, 0xff, 0, 0xff]),\n  // Blue\n  new Uint8Array([0, 0, 0xff, 0xff]),\n  // Yellow\n  new Uint8Array([0xff, 0xff, 0, 0xff]),\n];\n\nconst kDepthClearValue = 1.0;\nconst kDepthWriteValue = 0.0;\nconst kStencilClearValue = 0;\nconst kStencilReferenceValue = 0xff;\n\n// Format of the render target and resolve target\nconst format = 'rgba8unorm';\n\n// Format of depth stencil attachment\nconst depthStencilFormat = 'depth24plus-stencil8';\n\nconst kRenderTargetSize = 1;\n\nfunction hasSample(\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMask: number,\n  sampleIndex: number = 0\n): boolean {\n  return (rasterizationMask & sampleMask & fragmentShaderOutputMask & (1 << sampleIndex)) > 0;\n}\n\nfunction getExpectedColorData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Float32Array(sampleCount * 4);\n  if (sampleCount === 1) {\n    if (hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask)) {\n      // Texel 3 is sampled at the pixel center\n      expectedData[0] = kColors[3][0] / 0xff;\n      expectedData[1] = kColors[3][1] / 0xff;\n      expectedData[2] = kColors[3][2] / 0xff;\n      expectedData[3] = kColors[3][3] / 0xff;\n    }\n  } else {\n    for (let i = 0; i < sampleCount; i++) {\n      if (\n        hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask, i)\n      ) {\n        const o = i * 4;\n        expectedData[o + 0] = kColors[i][0] / 0xff;\n        expectedData[o + 1] = kColors[i][1] / 0xff;\n        expectedData[o + 2] = kColors[i][2] / 0xff;\n        expectedData[o + 3] = kColors[i][3] / 0xff;\n      }\n    }\n  }\n  return expectedData;\n}\n\nfunction getExpectedDepthData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Float32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kDepthWriteValue : kDepthClearValue;\n  }\n  return expectedData;\n}\n\nfunction getExpectedStencilData(\n  sampleCount: number,\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMaskOrAlphaToCoverageMask: number\n) {\n  const expectedData = new Uint32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kStencilReferenceValue : kStencilClearValue;\n  }\n  return expectedData;\n}\n\nconst kSampleMaskTestShader = `\nstruct Varyings {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) @interpolate(flat) uvFlat : vec2<f32>,\n  @location(1) @interpolate(perspective, sample) uvInterpolated : vec2<f32>,\n}\n\n//\n// Vertex shader\n//\n\n@vertex\nfn vmain(@builtin(vertex_index) VertexIndex : u32,\n    @builtin(instance_index) InstanceIndex : u32) -> Varyings {\n  // Standard sample locations within a pixel, where the pixel ranges from (-1,-1) to (1,1), and is\n  // centered at (0,0) (NDC - the test uses a 1x1 render target).\n  // https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\n  var sampleCenters = array(\n      // sampleCount = 1\n      vec2f(0, 0),\n      // sampleCount = 4\n      vec2f(-2,  6) / 8,\n      vec2f( 6,  2) / 8,\n      vec2f(-6, -2) / 8,\n      vec2f( 2, -6) / 8,\n    );\n  // A tiny quad to draw around the sample center to ensure we hit only the expected point.\n  let kTinyQuadRadius = 1.0 / 32;\n  var tinyQuad = array(\n    vec2f( kTinyQuadRadius,  kTinyQuadRadius),\n    vec2f( kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f( kTinyQuadRadius,  kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius,  kTinyQuadRadius),\n    );\n\n  var uvsFlat = array(\n      // sampleCount = 1\n      // Note: avoids hitting the point between the 4 texels.\n      vec2f(0.51, 0.51),\n      // sampleCount = 4\n      vec2f(0.25, 0.25),\n      vec2f(0.75, 0.25),\n      vec2f(0.25, 0.75),\n      vec2f(0.75, 0.75),\n    );\n  var uvsInterpolated = array(\n      // center quad\n      // Note: the interpolated point will be exactly in the middle of the 4 texels.\n      // The test expects to get texel 1,1 (the 3rd texel) in this case.\n      vec2f(1.0, 0.0),\n      vec2f(1.0, 1.0),\n      vec2f(0.0, 1.0),\n      vec2f(1.0, 0.0),\n      vec2f(0.0, 1.0),\n      vec2f(0.0, 0.0),\n\n      // top-left quad (texel 0)\n      vec2f(0.5, 0.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.0, 0.5),\n      vec2f(0.5, 0.0),\n      vec2f(0.0, 0.5),\n      vec2f(0.0, 0.0),\n\n      // top-right quad (texel 1)\n      vec2f(1.0, 0.0),\n      vec2f(1.0, 0.5),\n      vec2f(0.5, 0.5),\n      vec2f(1.0, 0.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.5, 0.0),\n\n      // bottom-left quad (texel 2)\n      vec2f(0.5, 0.5),\n      vec2f(0.5, 1.0),\n      vec2f(0.0, 1.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.0, 1.0),\n      vec2f(0.0, 0.5),\n\n      // bottom-right quad (texel 3)\n      vec2f(1.0, 0.5),\n      vec2f(1.0, 1.0),\n      vec2f(0.5, 1.0),\n      vec2f(1.0, 0.5),\n      vec2f(0.5, 1.0),\n      vec2f(0.5, 0.5)\n    );\n\n  var output : Varyings;\n  let pos = sampleCenters[InstanceIndex] + tinyQuad[VertexIndex];\n  output.Position = vec4(pos, ${kDepthWriteValue}, 1.0);\n  output.uvFlat = uvsFlat[InstanceIndex];\n  output.uvInterpolated = uvsInterpolated[InstanceIndex * 6 + VertexIndex];\n  return output;\n}\n\n//\n// Fragment shaders\n//\n\n@group(0) @binding(0) var mySampler: sampler;\n@group(0) @binding(1) var myTexture: texture_2d<f32>;\n\n// For test named 'fragment_output_mask'\n\n@group(0) @binding(2) var<uniform> fragMask: u32;\nstruct FragmentOutput1 {\n  @builtin(sample_mask) mask : u32,\n  @location(0) color : vec4<f32>,\n}\n@fragment fn fmain__fragment_output_mask__flat(varyings: Varyings) -> FragmentOutput1 {\n  return FragmentOutput1(fragMask, textureSample(myTexture, mySampler, varyings.uvFlat));\n}\n@fragment fn fmain__fragment_output_mask__interp(varyings: Varyings) -> FragmentOutput1 {\n  return FragmentOutput1(fragMask, textureSample(myTexture, mySampler, varyings.uvInterpolated));\n}\n\n// For test named 'alpha_to_coverage_mask'\n\nstruct FragmentOutput2 {\n  @location(0) color0 : vec4<f32>,\n  @location(1) color1 : vec4<f32>,\n}\n@group(0) @binding(2) var<uniform> alpha: vec2<f32>;\n@fragment fn fmain__alpha_to_coverage_mask__flat(varyings: Varyings) -> FragmentOutput2 {\n  var c = textureSample(myTexture, mySampler, varyings.uvFlat);\n  return FragmentOutput2(vec4(c.xyz, alpha[0]), vec4(c.xyz, alpha[1]));\n}\n@fragment fn fmain__alpha_to_coverage_mask__interp(varyings: Varyings) -> FragmentOutput2 {\n  var c = textureSample(myTexture, mySampler, varyings.uvInterpolated);\n  return FragmentOutput2(vec4(c.xyz, alpha[0]), vec4(c.xyz, alpha[1]));\n}\n`;\n\nclass F extends TextureTestMixin(GPUTest) {\n  private sampleTexture: GPUTexture | undefined;\n  private sampler: GPUSampler | undefined;\n\n  override async init() {\n    await super.init();\n    if (this.isCompatibility) {\n      this.skip('WGSL sample_mask is not supported in compatibility mode');\n    }\n    // Create a 2x2 color texture to sample from\n    // texel 0 - Red\n    // texel 1 - Green\n    // texel 2 - Blue\n    // texel 3 - Yellow\n    const kSampleTextureSize = 2;\n    this.sampleTexture = this.createTextureFromTexelView(\n      TexelView.fromTexelsAsBytes(format, coord => {\n        const id = coord.x + coord.y * kSampleTextureSize;\n        return kColors[id];\n      }),\n      {\n        size: [kSampleTextureSize, kSampleTextureSize, 1],\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }\n    );\n\n    this.sampler = this.device.createSampler({\n      magFilter: 'nearest',\n      minFilter: 'nearest',\n    });\n  }\n\n  GetTargetTexture(\n    sampleCount: number,\n    rasterizationMask: number,\n    pipeline: GPURenderPipeline,\n    uniformBuffer: GPUBuffer,\n    colorTargetsCount: number = 1\n  ): { color: GPUTexture; depthStencil: GPUTexture } {\n    assert(this.sampleTexture !== undefined);\n    assert(this.sampler !== undefined);\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: this.sampler,\n        },\n        {\n          binding: 1,\n          resource: this.sampleTexture.createView(),\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n    });\n\n    const renderTargetTextures = [];\n    const resolveTargetTextures: (GPUTexture | null)[] = [];\n    for (let i = 0; i < colorTargetsCount; i++) {\n      const renderTargetTexture = this.device.createTexture({\n        format,\n        size: {\n          width: kRenderTargetSize,\n          height: kRenderTargetSize,\n          depthOrArrayLayers: 1,\n        },\n        sampleCount,\n        mipLevelCount: 1,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n      });\n      renderTargetTextures.push(renderTargetTexture);\n\n      const resolveTargetTexture =\n        sampleCount === 1\n          ? null\n          : this.device.createTexture({\n              format,\n              size: {\n                width: kRenderTargetSize,\n                height: kRenderTargetSize,\n                depthOrArrayLayers: 1,\n              },\n              sampleCount: 1,\n              mipLevelCount: 1,\n              usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n      resolveTargetTextures.push(resolveTargetTexture);\n    }\n\n    const depthStencilTexture = this.device.createTexture({\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize,\n      },\n      format: depthStencilFormat,\n      sampleCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: renderTargetTextures.map((renderTargetTexture, index) => {\n        return {\n          view: renderTargetTexture.createView(),\n          resolveTarget: resolveTargetTextures[index]?.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        };\n      }),\n      depthStencilAttachment: {\n        view: depthStencilTexture.createView(),\n        depthClearValue: kDepthClearValue,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: kStencilClearValue,\n        stencilLoadOp: 'clear',\n        stencilStoreOp: 'store',\n      },\n    };\n    const commandEncoder = this.device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, uniformBindGroup);\n    passEncoder.setStencilReference(kStencilReferenceValue);\n\n    if (sampleCount === 1) {\n      if ((rasterizationMask & 1) !== 0) {\n        // draw center quad\n        passEncoder.draw(6, 1, 0, 0);\n      }\n    } else {\n      assert(sampleCount === 4);\n      if ((rasterizationMask & 1) !== 0) {\n        // draw top-left quad\n        passEncoder.draw(6, 1, 0, 1);\n      }\n      if ((rasterizationMask & 2) !== 0) {\n        // draw top-right quad\n        passEncoder.draw(6, 1, 0, 2);\n      }\n      if ((rasterizationMask & 4) !== 0) {\n        // draw bottom-left quad\n        passEncoder.draw(6, 1, 0, 3);\n      }\n      if ((rasterizationMask & 8) !== 0) {\n        // draw bottom-right quad\n        passEncoder.draw(6, 1, 0, 4);\n      }\n    }\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    return {\n      color: renderTargetTextures[0],\n      depthStencil: depthStencilTexture,\n    };\n  }\n\n  CheckColorAttachmentResult(\n    texture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      TypeF32, // correspond to 'rgba8unorm' format\n      4,\n      texture.createView(),\n      sampleCount\n    );\n\n    const expected = getExpectedColorData(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n\n  CheckDepthStencilResult(\n    aspect: 'depth-only' | 'stencil-only',\n    depthStencilTexture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      // Use f32 as the scalar type for depth (depth24plus, depth32float)\n      // Use u32 as the scalar type for stencil (stencil8)\n      aspect === 'depth-only' ? TypeF32 : TypeU32,\n      1,\n      depthStencilTexture.createView({ aspect }),\n      sampleCount\n    );\n\n    const expected =\n      aspect === 'depth-only'\n        ? getExpectedDepthData(sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask)\n        : getExpectedStencilData(\n            sampleCount,\n            rasterizationMask,\n            sampleMask,\n            fragmentShaderOutputMask\n          );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('fragment_output_mask')\n  .desc(\n    `\nTests that the final sample mask is the logical AND of all the relevant masks -- meaning that the samples\nnot included in the final mask are discarded on any attachments including\n- color outputs\n- depth tests\n- stencil operations\n\nThe test draws 0/1/1+ textured quads of which each sample in the standard 4-sample pattern results in a different color:\n- Sample 0, Texel 0, top-left: Red\n- Sample 1, Texel 1, top-left: Green\n- Sample 2, Texel 2, top-left: Blue\n- Sample 3, Texel 3, top-left: Yellow\n\nThe test checks each sample value of the render target texture and depth stencil texture using a compute pass to\ntextureLoad each sample index from the texture and write to a storage buffer to compare with expected values.\n\n- for sampleCount = { 1, 4 } and various combinations of:\n    - rasterization mask = { 0, ..., 2 ** sampleCount - 1 }\n    - sample mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n    - fragment shader output @builtin(sample_mask) = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n- [choosing 0b11110 because the 5th bit should be ignored]\n`\n  )\n  .params(u =>\n    u\n      .combine('interpolated', [false, true])\n      .combine('sampleCount', [1, 4] as const)\n      .expand('rasterizationMask', function* (p) {\n        const maxMask = 2 ** p.sampleCount - 1;\n        for (let i = 0; i <= maxMask; i++) {\n          yield i;\n        }\n      })\n      .beginSubcases()\n      .combine('sampleMask', [\n        0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110,\n      ] as const)\n      .combine('fragmentShaderOutputMask', [\n        0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110,\n      ] as const)\n  )\n  .fn(t => {\n    const { sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask } = t.params;\n\n    const fragmentMaskUniformBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(fragmentMaskUniformBuffer);\n    t.device.queue.writeBuffer(\n      fragmentMaskUniformBuffer,\n      0,\n      new Uint32Array([fragmentShaderOutputMask])\n    );\n\n    const module = t.device.createShaderModule({ code: kSampleMaskTestShader });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      fragment: {\n        module,\n        entryPoint: `fmain__fragment_output_mask__${t.params.interpolated ? 'interp' : 'flat'}`,\n        targets: [{ format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: false,\n      },\n      depthStencil: {\n        format: depthStencilFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n\n        stencilFront: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n        stencilBack: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n      },\n    });\n\n    const { color, depthStencil } = t.GetTargetTexture(\n      sampleCount,\n      rasterizationMask,\n      pipeline,\n      fragmentMaskUniformBuffer\n    );\n\n    t.CheckColorAttachmentResult(\n      color,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'depth-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'stencil-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n  });\n\ng.test('alpha_to_coverage_mask')\n  .desc(\n    `\nTest that alpha_to_coverage_mask is working properly with the alpha output of color target[0].\n\n- for sampleCount = 4, alphaToCoverageEnabled = true and various combinations of:\n  - rasterization masks\n  - increasing alpha0 values of the color0 output including { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n  - alpha1 values of the color1 output = { 0, 0.5, 1.0 }.\n- test that for a single pixel in { color0, color1 } { color0, depth, stencil } output the final sample mask is applied to it, moreover:\n  - if alpha0 is 0.0 or less then alpha to coverage mask is 0x0,\n  - if alpha0 is 1.0 or greater then alpha to coverage mask is 0xFFFFFFFF,\n  - that the number of bits in the alpha to coverage mask is non-decreasing,\n  - that the computation of alpha to coverage mask doesn't depend on any other color output than color0,\n  - (not included in the spec): that once a sample is included in the alpha to coverage sample mask\n    it will be included for any alpha greater than or equal to the current value.\n\nThe algorithm of producing the alpha-to-coverage mask is platform-dependent. The test draws a different color\nat each sample point. for any two alpha values (alpha and alpha') where 0 < alpha' < alpha < 1, the color values (color and color') must satisfy\ncolor' <= color.\n`\n  )\n  .params(u =>\n    u\n      .combine('interpolated', [false, true])\n      .combine('sampleCount', [4] as const)\n      .expand('rasterizationMask', function* (p) {\n        const maxMask = 2 ** p.sampleCount - 1;\n        for (let i = 0; i <= maxMask; i++) {\n          yield i;\n        }\n      })\n      .beginSubcases()\n      .combine('alpha1', [0.0, 0.5, 1.0] as const)\n  )\n  .fn(async t => {\n    const { sampleCount, rasterizationMask, alpha1 } = t.params;\n    const sampleMask = 0xffffffff;\n\n    const alphaValues = new Float32Array(4); // [alpha0, alpha1, 0, 0]\n    const alphaValueUniformBuffer = t.device.createBuffer({\n      size: alphaValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(alphaValueUniformBuffer);\n\n    const module = t.device.createShaderModule({ code: kSampleMaskTestShader });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      fragment: {\n        module,\n        entryPoint: `fmain__alpha_to_coverage_mask__${t.params.interpolated ? 'interp' : 'flat'}`,\n        targets: [{ format }, { format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: true,\n      },\n      depthStencil: {\n        format: depthStencilFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n\n        stencilFront: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n        stencilBack: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n      },\n    });\n\n    // { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n    const alpha0ParamsArray = [-0.1, ...range(16, i => i / 16), 1.0, 1.1];\n\n    const colorResultPromises = [];\n    const depthResultPromises = [];\n    const stencilResultPromises = [];\n\n    for (const alpha0 of alpha0ParamsArray) {\n      alphaValues[0] = alpha0;\n      alphaValues[1] = alpha1;\n      t.device.queue.writeBuffer(alphaValueUniformBuffer, 0, alphaValues);\n\n      const { color, depthStencil } = t.GetTargetTexture(\n        sampleCount,\n        rasterizationMask,\n        pipeline,\n        alphaValueUniformBuffer,\n        2\n      );\n\n      const colorBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeF32, // correspond to 'rgba8unorm' format\n        4,\n        color.createView(),\n        sampleCount\n      );\n      const colorResult = t.readGPUBufferRangeTyped(colorBuffer, {\n        type: Float32Array,\n        typedLength: colorBuffer.size / Float32Array.BYTES_PER_ELEMENT,\n      });\n      colorResultPromises.push(colorResult);\n\n      const depthBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeF32, // correspond to 'depth24plus-stencil8' format\n        1,\n        depthStencil.createView({ aspect: 'depth-only' }),\n        sampleCount\n      );\n      const depthResult = t.readGPUBufferRangeTyped(depthBuffer, {\n        type: Float32Array,\n        typedLength: depthBuffer.size / Float32Array.BYTES_PER_ELEMENT,\n      });\n      depthResultPromises.push(depthResult);\n\n      const stencilBuffer = t.copySinglePixelTextureToBufferUsingComputePass(\n        TypeU32, // correspond to 'depth24plus-stencil8' format\n        1,\n        depthStencil.createView({ aspect: 'stencil-only' }),\n        sampleCount\n      );\n      const stencilResult = t.readGPUBufferRangeTyped(stencilBuffer, {\n        type: Uint32Array,\n        typedLength: stencilBuffer.size / Uint32Array.BYTES_PER_ELEMENT,\n      });\n      stencilResultPromises.push(stencilResult);\n    }\n\n    const resultsArray = await Promise.all([\n      Promise.all(colorResultPromises),\n      Promise.all(depthResultPromises),\n      Promise.all(stencilResultPromises),\n    ]);\n\n    const checkResults = (\n      results: { data: Float32Array | Uint32Array; cleanup(): void }[],\n      getExpectedDataFn: (\n        sampleCount: number,\n        rasterizationMask: number,\n        sampleMask: number,\n        alphaToCoverageMask: number\n      ) => Float32Array | Uint32Array,\n      // Alpha to coverage mask should be non-decreasing as the alpha value goes up\n      // Result value of color and stencil is in positive correlation to alpha\n      // Result value of depth is in negative correlation to alpha\n      positiveCorrelation: boolean\n    ) => {\n      for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n        const alpha0 = alpha0ParamsArray[i];\n\n        if (alpha0 <= 0) {\n          const expected = getExpectedDataFn(sampleCount, rasterizationMask, sampleMask, 0x0);\n          const check = checkElementsEqual(result.data, expected);\n          t.expectOK(check);\n        } else if (alpha0 >= 1) {\n          const expected = getExpectedDataFn(\n            sampleCount,\n            rasterizationMask,\n            sampleMask,\n            0xffffffff\n          );\n          const check = checkElementsEqual(result.data, expected);\n          t.expectOK(check);\n        } else {\n          assert(i > 0);\n          const prevResult = results[i - 1];\n          const check = checkElementsPassPredicate(\n            result.data,\n            (index, value) =>\n              positiveCorrelation\n                ? value >= prevResult.data[index]\n                : value <= prevResult.data[index],\n            {}\n          );\n          t.expectOK(check);\n        }\n      }\n\n      for (const result of results) {\n        result.cleanup();\n      }\n    };\n\n    // Check color results\n    checkResults(resultsArray[0], getExpectedColorData, true);\n\n    // Check depth results\n    checkResults(resultsArray[1], getExpectedDepthData, false);\n\n    // Check stencil results\n    checkResults(resultsArray[2], getExpectedStencilData, true);\n  });\n"],"mappings":"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GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;MACjBC,iBAAiB;MACjBC,UAAU;MACVK,6CAA6C;MAC7CG;IACF,CAAC;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGnB,gBAAgB,GAAGD,gBAAgB;EAC3D;EACA,OAAOe,YAAY;AACrB;;AAEA,SAASM,sBAAsBA;AAC7BR,WAAmB;AACnBL,iBAAyB;AACzBC,UAAkB;AAClBK,6CAAqD;AACrD;EACA,MAAMC,YAAY,GAAG,IAAIO,WAAW,CAACT,WAAW,CAAC;EACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;MACjBC,iBAAiB;MACjBC,UAAU;MACVK,6CAA6C;MAC7CG;IACF,CAAC;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGjB,sBAAsB,GAAGD,kBAAkB;EACnE;EACA,OAAOa,YAAY;AACrB;;AAEA,MAAMQ,qBAAqB,GAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgCtB,gBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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"}
{"version":3,"file":"mapping.spec.js","names":["description","makeTestGroup","attemptGarbageCollection","assert","unreachable","kBufferUsages","GPUConst","ValidationTest","F","testMapAsyncCall","expectation","buffer","mode","offset","size","p","mapAsync","expectValidationError","validationError","caught","rejectedEarly","catch","queueMicrotask","rejectName","ex","Error","stack","name","earlyRejection","testGetMappedRangeCall","success","data","getMappedRange","expect","ArrayBuffer","undefined","byteLength","shouldThrow","createMappableBuffer","type","GPUMapMode","READ","device","createBuffer","usage","GPUBufferUsage","MAP_READ","WRITE","MAP_WRITE","g","kMapModeOptions","MapMode","kOffsetAlignment","kSizeAlignment","test","desc","paramsSubcasesOnly","u","combineWithParams","mapMode","validUsage","BufferUsage","combine","fn","t","params","successParam","getErrorBuffer","pending","destroy","mappedAtCreation","unmap","pending0","pending1","bufferSize","offset2","mapSize","offset1","p1","unmapBeforeResolve","bufferUsage","expectGPUError","subrangeSize","data0","data1","COPY_DST","mapping0","mapping1","beginSubcases","mapOffset","actualOffset","actualSize","actualMapOffset","actualMapSize","size1","size2","remapBetweenCalls","range1StartsAfter2","range2StartsAfter1","disjoint","kStride","kNumStrides","stride","contents","Uint32Array","i","length"],"sources":["../../../../../src/webgpu/api/validation/buffer/mapping.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for GPUBuffer.mapAsync, GPUBuffer.unmap and GPUBuffer.getMappedRange.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../../../common/util/collect_garbage.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass F extends ValidationTest {\n  async testMapAsyncCall(\n    expectation:\n      | 'success'\n      | { validationError: boolean; earlyRejection: boolean; rejectName: string },\n    buffer: GPUBuffer,\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number\n  ) {\n    if (expectation === 'success') {\n      const p = buffer.mapAsync(mode, offset, size);\n      await p;\n    } else {\n      let p: Promise<void>;\n      this.expectValidationError(() => {\n        p = buffer.mapAsync(mode, offset, size);\n      }, expectation.validationError);\n      let caught = false;\n      let rejectedEarly = false;\n      // If mapAsync rejected early, microtask A will run before B.\n      // If not, B will run before A.\n      p!.catch(() => {\n        // Microtask A\n        caught = true;\n      });\n      queueMicrotask(() => {\n        // Microtask B\n        rejectedEarly = caught;\n      });\n      try {\n        // This await will always complete after microtasks A and B are both done.\n        await p!;\n        assert(expectation.rejectName === null, 'mapAsync unexpectedly passed');\n      } catch (ex) {\n        assert(ex instanceof Error, 'mapAsync rejected with non-error');\n        assert(typeof ex.stack === 'string', 'mapAsync rejected without a stack');\n        assert(expectation.rejectName === ex.name, `mapAsync rejected unexpectedly with: ${ex}`);\n        assert(\n          expectation.earlyRejection === rejectedEarly,\n          'mapAsync rejected at an unexpected timing'\n        );\n      }\n    }\n  }\n\n  testGetMappedRangeCall(success: boolean, buffer: GPUBuffer, offset?: number, size?: number) {\n    if (success) {\n      const data = buffer.getMappedRange(offset, size);\n      this.expect(data instanceof ArrayBuffer);\n      if (size !== undefined) {\n        this.expect(data.byteLength === size);\n      }\n    } else {\n      this.shouldThrow('OperationError', () => {\n        buffer.getMappedRange(offset, size);\n      });\n    }\n  }\n\n  createMappableBuffer(type: GPUMapModeFlags, size: number): GPUBuffer {\n    switch (type) {\n      case GPUMapMode.READ:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_READ,\n        });\n      case GPUMapMode.WRITE:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_WRITE,\n        });\n      default:\n        unreachable();\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kOffsetAlignment = 8;\nconst kSizeAlignment = 4;\n\ng.test('mapAsync,usage')\n  .desc(\n    `Test the usage validation for mapAsync.\n\n  For each buffer usage:\n  For GPUMapMode.READ, GPUMapMode.WRITE, and 0:\n    Test that the mapAsync call is valid iff the mapping usage is not 0 and the buffer usage\n    the mapMode flag.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combineWithParams([\n        { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n        { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n        // Using mapMode 0 is never valid, so there is no validUsage.\n        { mapMode: 0, validUsage: null },\n      ])\n      .combine('usage', kBufferUsages)\n  )\n  .fn(async t => {\n    const { mapMode, validUsage, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const successParam =\n      usage === validUsage\n        ? 'success'\n        : {\n            validationError: true,\n            earlyRejection: false,\n            rejectName: 'OperationError',\n          };\n    await t.testMapAsyncCall(successParam, buffer, mapMode);\n  });\n\ng.test('mapAsync,invalidBuffer')\n  .desc('Test that mapAsync is an error when called on an invalid buffer.')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.getErrorBuffer();\n    await t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n  });\n\ng.test('mapAsync,state,destroyed')\n  .desc('Test that mapAsync is an error when called on a destroyed buffer.')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    // Start mapping the buffer, we are going to destroy it before it resolves so it will reject\n    // the mapping promise with an AbortError.\n    const pending = t.testMapAsyncCall(\n      { validationError: false, earlyRejection: false, rejectName: 'AbortError' },\n      buffer,\n      mapMode\n    );\n\n    buffer.destroy();\n    await t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    await pending;\n  });\n\ng.test('mapAsync,state,mappedAtCreation')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer mapped at creation,\n    but succeeds after unmapping it.`\n  )\n  .paramsSubcasesOnly([\n    { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n    { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n  ])\n  .fn(async t => {\n    const { mapMode, validUsage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: validUsage,\n      mappedAtCreation: true,\n    });\n    await t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    buffer.unmap();\n    await t.testMapAsyncCall('success', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mapped')\n  .desc(\n    `Test that mapAsync is an error when called on a mapped buffer, but succeeds\n    after unmapping it.`\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await t.testMapAsyncCall('success', buffer, mapMode);\n    await t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    buffer.unmap();\n    await t.testMapAsyncCall('success', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappingPending')\n  .desc(\n    `Test that mapAsync is rejected when called on a buffer that is being mapped,\n    but succeeds after the previous mapping request is cancelled.`\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    // Start mapping the buffer, we are going to unmap it before it resolves so it will reject\n    // the mapping promise with an AbortError.\n    const pending0 = t.testMapAsyncCall(\n      { validationError: false, earlyRejection: false, rejectName: 'AbortError' },\n      buffer,\n      mapMode\n    );\n\n    // Do the test of mapAsync while [[pending_map]] is non-null. It has to be synchronous so\n    // that we can unmap the previous mapping in the same stack frame and testing this one doesn't\n    // get canceled, but instead is rejected.\n    const pending1 = t.testMapAsyncCall(\n      { validationError: false, earlyRejection: true, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    // Unmap the first mapping. It should now be possible to successfully call mapAsync\n    // This unmap should cause the first mapAsync rejection.\n    buffer.unmap();\n    await t.testMapAsyncCall('success', buffer, mapMode);\n\n    await pending0;\n    await pending1;\n  });\n\ng.test('mapAsync,sizeUnspecifiedOOB')\n  .desc(\n    `Test that mapAsync with size unspecified rejects if offset > buffer.[[size]],\n    with various cases at the limits of the buffer size or with a misaligned offset.\n    Also test for an empty buffer.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // 0 size buffer.\n        { bufferSize: 0, offset: 0 },\n        { bufferSize: 0, offset: 1 },\n        { bufferSize: 0, offset: kOffsetAlignment },\n\n        // Test with a buffer that's not empty.\n        { bufferSize: 16, offset: 0 },\n        { bufferSize: 16, offset: kOffsetAlignment },\n        { bufferSize: 16, offset: 16 },\n        { bufferSize: 16, offset: 17 },\n        { bufferSize: 16, offset: 16 + kOffsetAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const successParam =\n      offset <= bufferSize\n        ? 'success'\n        : {\n            validationError: true,\n            earlyRejection: false,\n            rejectName: 'OperationError',\n          };\n    await t.testMapAsyncCall(successParam, buffer, mapMode, offset);\n  });\n\ng.test('mapAsync,offsetAndSizeAlignment')\n  .desc(\"Test that mapAsync fails if the alignment of offset and size isn't correct.\")\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('mapMode', kMapModeOptions)\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const successParam =\n      offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0\n        ? 'success'\n        : {\n            validationError: true,\n            earlyRejection: false,\n            rejectName: 'OperationError',\n          };\n    await t.testMapAsyncCall(successParam, buffer, mapMode, offset, size);\n  });\n\ng.test('mapAsync,offsetAndSizeOOB')\n  .desc('Test that mapAsync fails if offset + size is larger than the buffer size.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // For a 0 size buffer\n        { bufferSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, offset: 0, size: 4 },\n        { bufferSize: 0, offset: 8, size: 0 },\n\n        // For a small buffer\n        { bufferSize: 16, offset: 0, size: 16 },\n        { bufferSize: 16, offset: kOffsetAlignment, size: 16 },\n\n        { bufferSize: 16, offset: 16, size: 0 },\n        { bufferSize: 16, offset: 16, size: kSizeAlignment },\n\n        { bufferSize: 16, offset: 8, size: 0 },\n        { bufferSize: 16, offset: 8, size: 8 },\n        { bufferSize: 16, offset: 8, size: 8 + kSizeAlignment },\n\n        // For a larger buffer\n        { bufferSize: 1024, offset: 0, size: 1024 },\n        { bufferSize: 1024, offset: kOffsetAlignment, size: 1024 },\n\n        { bufferSize: 1024, offset: 1024, size: 0 },\n        { bufferSize: 1024, offset: 1024, size: kSizeAlignment },\n\n        { bufferSize: 1024, offset: 512, size: 0 },\n        { bufferSize: 1024, offset: 512, size: 512 },\n        { bufferSize: 1024, offset: 512, size: 512 + kSizeAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, size, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const successParam =\n      offset + size <= bufferSize\n        ? 'success'\n        : {\n            validationError: true,\n            earlyRejection: false,\n            rejectName: 'OperationError',\n          };\n    await t.testMapAsyncCall(successParam, buffer, mapMode, offset, size);\n  });\n\ng.test('mapAsync,earlyRejection')\n  .desc(\"Test that mapAsync fails immediately if it's pending map.\")\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions).combine('offset2', [0, 8]))\n  .fn(async t => {\n    const { mapMode, offset2 } = t.params;\n\n    const bufferSize = 16;\n    const mapSize = 8;\n    const offset1 = 0;\n\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    const p1 = buffer.mapAsync(mapMode, offset1, mapSize); // succeeds\n    await t.testMapAsyncCall(\n      {\n        validationError: false,\n        earlyRejection: true,\n        rejectName: 'OperationError',\n      },\n      buffer,\n      mapMode,\n      offset2,\n      mapSize\n    );\n    await p1; // ensure the original map still succeeds\n  });\n\ng.test('mapAsync,abort_over_invalid_error')\n  .desc(\n    `Test that unmap abort error should have precedence over validation error\nTODO\n  - Add other validation error test (eg. offset is not a multiple of 8)\n  `\n  )\n  .paramsSubcasesOnly(u =>\n    u.combine('mapMode', kMapModeOptions).combine('unmapBeforeResolve', [true, false])\n  )\n  .fn(async t => {\n    const { mapMode, unmapBeforeResolve } = t.params;\n    const bufferSize = 8;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode);\n\n    if (unmapBeforeResolve) {\n      // unmap abort error should have precedence over validation error\n      const pending = t.testMapAsyncCall(\n        { validationError: true, earlyRejection: false, rejectName: 'AbortError' },\n        buffer,\n        mapMode\n      );\n      buffer.unmap();\n      await pending;\n    } else {\n      // map on already mapped buffer should cause validation error\n      await t.testMapAsyncCall(\n        { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n        buffer,\n        mapMode\n      );\n      buffer.unmap();\n    }\n  });\n\ng.test('getMappedRange,state,mapped')\n  .desc('Test that it is valid to call getMappedRange in the mapped state')\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const bufferSize = 16;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode);\n\n    const data = buffer.getMappedRange();\n    t.expect(data instanceof ArrayBuffer);\n    t.expect(data.byteLength === bufferSize);\n\n    // map on already mapped buffer should be rejected\n    const pending = t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n    t.expect(data.byteLength === bufferSize);\n    await pending;\n\n    buffer.unmap();\n\n    t.expect(data.byteLength === 0);\n  });\n\ng.test('getMappedRange,state,mappedAtCreation')\n  .desc(\n    `Test that, in the mapped-at-creation state, it is valid to call getMappedRange, for all buffer usages,\n    and invalid to call mapAsync, for all map modes.`\n  )\n  .paramsSubcasesOnly(u =>\n    u.combine('bufferUsage', kBufferUsages).combine('mapMode', kMapModeOptions)\n  )\n  .fn(async t => {\n    const { bufferUsage, mapMode } = t.params;\n    const bufferSize = 16;\n    const buffer = t.device.createBuffer({\n      usage: bufferUsage,\n      size: bufferSize,\n      mappedAtCreation: true,\n    });\n\n    const data = buffer.getMappedRange();\n    t.expect(data instanceof ArrayBuffer);\n    t.expect(data.byteLength === bufferSize);\n\n    // map on already mapped buffer should be rejected\n    const pending = t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n    t.expect(data.byteLength === bufferSize);\n    await pending;\n\n    buffer.unmap();\n\n    t.expect(data.byteLength === 0);\n  });\n\ng.test('getMappedRange,state,invalid_mappedAtCreation')\n  .desc(\n    `mappedAtCreation should return a mapped buffer, even if the buffer is invalid.\nLike VRAM allocation (see map_oom), validation can be performed asynchronously (in the GPU process)\nso the Content process doesn't necessarily know the buffer is invalid.`\n  )\n  .fn(t => {\n    const buffer = t.expectGPUError('validation', () =>\n      t.device.createBuffer({\n        mappedAtCreation: true,\n        size: 16,\n        usage: 0xffff_ffff, // Invalid usage\n      })\n    );\n\n    // Should still be valid.\n    buffer.getMappedRange();\n  });\n\ng.test('getMappedRange,state,mappedAgain')\n  .desc(\n    'Test that it is valid to call getMappedRange in the mapped state, even if there is a duplicate mapAsync before'\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    // call mapAsync again on already mapped buffer should fail\n    await t.testMapAsyncCall(\n      { validationError: true, earlyRejection: false, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    // getMapppedRange should still success\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,unmapped')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the unmapped state.\nTest for various cases of being unmapped: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer starts unmapped when created.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mapAsync.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mappedAtCreation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,subrange,mapped')\n  .desc(\n    `Test that old getMappedRange returned arraybuffer does not exist after unmap, and newly returned\n    arraybuffer after new map has correct subrange`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const bufferSize = 16;\n    const offset = 8;\n    const subrangeSize = bufferSize - offset;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode);\n\n    const data0 = buffer.getMappedRange();\n    t.expect(data0 instanceof ArrayBuffer);\n    t.expect(data0.byteLength === bufferSize);\n\n    buffer.unmap();\n    t.expect(data0.byteLength === 0);\n\n    await buffer.mapAsync(mapMode, offset);\n    const data1 = buffer.getMappedRange(8);\n\n    t.expect(data0.byteLength === 0);\n    t.expect(data1.byteLength === subrangeSize);\n  });\n\ng.test('getMappedRange,subrange,mappedAtCreation')\n  .desc(\n    `Test that old getMappedRange returned arraybuffer does not exist after unmap and newly returned\n    arraybuffer after new map has correct subrange`\n  )\n  .fn(async t => {\n    const bufferSize = 16;\n    const offset = 8;\n    const subrangeSize = bufferSize - offset;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n      mappedAtCreation: true,\n    });\n\n    const data0 = buffer.getMappedRange();\n    t.expect(data0 instanceof ArrayBuffer);\n    t.expect(data0.byteLength === bufferSize);\n\n    buffer.unmap();\n    t.expect(data0.byteLength === 0);\n\n    await buffer.mapAsync(GPUMapMode.READ, offset);\n    const data1 = buffer.getMappedRange(8);\n\n    t.expect(data0.byteLength === 0);\n    t.expect(data1.byteLength === subrangeSize);\n  });\n\ng.test('getMappedRange,state,destroyed')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the destroyed state.\nTest for various cases of being destroyed: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer is destroyed when unmapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped at creation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,mappingPending')\n  .desc(`Test that it is invalid to call getMappedRange in the mappingPending state.`)\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    /* noawait */ const mapping0 = buffer.mapAsync(mapMode);\n    // seconding mapping should be rejected\n    const mapping1 = t.testMapAsyncCall(\n      { validationError: false, earlyRejection: true, rejectName: 'OperationError' },\n      buffer,\n      mapMode\n    );\n\n    // invalid in mappingPending state\n    t.testGetMappedRangeCall(false, buffer);\n\n    await mapping0;\n\n    // valid after buffer is mapped\n    t.testGetMappedRangeCall(true, buffer);\n\n    await mapping1;\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment,mapped')\n  .desc(`Test that getMappedRange fails if the alignment of offset and size isn't correct.`)\n  .params(u =>\n    u\n      .combine('mapMode', kMapModeOptions)\n      .beginSubcases()\n      .combine('mapOffset', [0, kOffsetAlignment])\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(async t => {\n    const { mapMode, mapOffset, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 32);\n    await buffer.mapAsync(mapMode, mapOffset);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    t.testGetMappedRangeCall(success, buffer, offset + mapOffset, size);\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment,mappedAtCreation')\n  .desc(`Test that getMappedRange fails if the alignment of offset and size isn't correct.`)\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('offset', [0, kOffsetAlignment, kOffsetAlignment / 2])\n      .combine('size', [0, kSizeAlignment, kSizeAlignment / 2])\n  )\n  .fn(t => {\n    const { offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,mappedAtCreation')\n  .desc(\n    `Test that getMappedRange size + offset must be less than the buffer size for a\n    buffer mapped at creation. (and offset has not constraints on its own)`\n  )\n  .paramsSubcasesOnly([\n    // Tests for a zero-sized buffer, with and without a size defined.\n    { bufferSize: 0, offset: undefined, size: undefined },\n    { bufferSize: 0, offset: undefined, size: 0 },\n    { bufferSize: 0, offset: undefined, size: kSizeAlignment },\n    { bufferSize: 0, offset: 0, size: undefined },\n    { bufferSize: 0, offset: 0, size: 0 },\n    { bufferSize: 0, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 0, offset: kOffsetAlignment, size: 0 },\n\n    // Tests for a non-empty buffer, with an undefined offset.\n    { bufferSize: 80, offset: undefined, size: 80 },\n    { bufferSize: 80, offset: undefined, size: 80 + kSizeAlignment },\n\n    // Tests for a non-empty buffer, with an undefined size.\n    { bufferSize: 80, offset: undefined, size: undefined },\n    { bufferSize: 80, offset: 0, size: undefined },\n    { bufferSize: 80, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 80, offset: 80, size: undefined },\n    { bufferSize: 80, offset: 80 + kOffsetAlignment, size: undefined },\n\n    // Tests for a non-empty buffer with a size defined.\n    { bufferSize: 80, offset: 0, size: 80 },\n    { bufferSize: 80, offset: 0, size: 80 + kSizeAlignment },\n    { bufferSize: 80, offset: kOffsetAlignment, size: 80 },\n\n    { bufferSize: 80, offset: 40, size: 40 },\n    { bufferSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n    { bufferSize: 80, offset: 40, size: 40 + kSizeAlignment },\n  ])\n  .fn(t => {\n    const { bufferSize, offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success = actualOffset <= bufferSize && actualOffset + actualSize <= bufferSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,mapped')\n  .desc('Test that getMappedRange size + offset must be less than the mapAsync range.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('mapMode', kMapModeOptions)\n      .combineWithParams([\n        // Tests for an empty buffer, and implicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: undefined,\n          size: kSizeAlignment,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: undefined,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: kOffsetAlignment, size: 0 },\n\n        // Tests for an empty buffer, and explicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: 0 },\n\n        // Test for a fully implicit mapAsync call\n        { bufferSize: 80, mapOffset: undefined, mapSize: undefined, offset: 0, size: 80 },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80,\n        },\n\n        // Test for a mapAsync call with an implicit size\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: 80 - 24 },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 - 24 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80 - 24,\n        },\n\n        // Test for a non-empty buffer fully mapped.\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: kOffsetAlignment, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 + kSizeAlignment },\n\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 + kSizeAlignment },\n\n        // Test for a buffer partially mapped.\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 - kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 + kSizeAlignment },\n\n        // Test for a partially mapped buffer with implicit size and offset for getMappedRange.\n        // - Buffer partially mapped in the middle\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 0, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: undefined },\n        // - Buffer partially mapped to the end\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 80, size: undefined },\n        // - Buffer partially mapped from the start\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: 64 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, mapOffset, mapSize, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode, mapOffset, mapSize);\n\n    const actualMapOffset = mapOffset ?? 0;\n    const actualMapSize = mapSize ?? bufferSize - actualMapOffset;\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success =\n      actualOffset >= actualMapOffset &&\n      actualOffset <= bufferSize &&\n      actualOffset + actualSize <= actualMapOffset + actualMapSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,disjointRanges')\n  .desc('Test that the ranges asked through getMappedRange must be disjoint.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('remapBetweenCalls', [false, true])\n      .combineWithParams([\n        // Disjoint ranges with one that's empty.\n        { offset1: 8, size1: 0, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 0, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 8, size2: 0 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 0 },\n\n        // Disjoint ranges with both non-empty.\n        { offset1: 0, size1: 8, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 8, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 0, size2: 8 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 8 },\n\n        // Empty range contained inside another one.\n        { offset1: 16, size1: 20, offset2: 24, size2: 0 },\n        { offset1: 24, size1: 0, offset2: 16, size2: 20 },\n\n        // Ranges that overlap only partially.\n        { offset1: 16, size1: 20, offset2: 8, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 32, size2: 20 },\n\n        // Ranges that include one another.\n        { offset1: 0, size1: 80, offset2: 16, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 0, size2: 80 },\n      ])\n  )\n  .fn(async t => {\n    const { offset1, size1, offset2, size2, remapBetweenCalls } = t.params;\n    const buffer = t.device.createBuffer({ size: 80, usage: GPUBufferUsage.MAP_READ });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    t.testGetMappedRangeCall(true, buffer, offset1, size1);\n\n    if (remapBetweenCalls) {\n      buffer.unmap();\n      await buffer.mapAsync(GPUMapMode.READ);\n    }\n\n    const range1StartsAfter2 = offset1 >= offset2 + size2;\n    const range2StartsAfter1 = offset2 >= offset1 + size1;\n    const disjoint = range1StartsAfter2 || range2StartsAfter1;\n    const success = disjoint || remapBetweenCalls;\n\n    t.testGetMappedRangeCall(success, buffer, offset2, size2);\n  });\n\ng.test('getMappedRange,disjoinRanges_many')\n  .desc('Test getting a lot of small ranges, and that the disjoint check checks them all.')\n  .fn(async t => {\n    const kStride = 256;\n    const kNumStrides = 256;\n\n    const buffer = t.device.createBuffer({\n      size: kStride * kNumStrides,\n      usage: GPUBufferUsage.MAP_READ,\n    });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    // Get a lot of small mapped ranges.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(true, buffer, stride * kStride, 8);\n    }\n\n    // Check for each range it is invalid to get a range that overlaps it and check that it is valid\n    // to get ranges for the rest of the buffer.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(false, buffer, stride * kStride, kStride);\n      t.testGetMappedRangeCall(true, buffer, stride * kStride + 8, kStride - 8);\n    }\n  });\n\ng.test('unmap,state,unmapped')\n  .desc(\n    `Test it is valid to call unmap on a buffer that is unmapped (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is valid to call unmap after creation of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      buffer.unmap();\n    }\n\n    // It is valid to call unmap after unmapping a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      buffer.unmap();\n    }\n\n    // It is valid to call unmap after unmapping a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      buffer.unmap();\n    }\n  });\n\ng.test('unmap,state,destroyed')\n  .desc(\n    `Test it is valid to call unmap on a buffer that is destroyed (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is valid to call unmap after destruction of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      buffer.destroy();\n      buffer.unmap();\n    }\n\n    // It is valid to call unmap after destroying a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      buffer.unmap();\n    }\n\n    // It is valid to call unmap after destroying a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      buffer.unmap();\n    }\n  });\n\ng.test('unmap,state,mappedAtCreation')\n  .desc('Test it is valid to call unmap on a buffer mapped at creation, for various usages')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('bufferUsage', kBufferUsages)\n  )\n  .fn(t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({ size: 16, usage: bufferUsage, mappedAtCreation: true });\n\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mapped')\n  .desc(\"Test it is valid to call unmap on a buffer that's mapped\")\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    await buffer.mapAsync(mapMode);\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mappingPending')\n  .desc(\"Test it is valid to call unmap on a buffer that's being mapped\")\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const pending = t.testMapAsyncCall(\n      { validationError: false, earlyRejection: false, rejectName: 'AbortError' },\n      buffer,\n      mapMode\n    );\n    buffer.unmap();\n    await pending;\n  });\n\ng.test('gc_behavior,mappedAtCreation')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mappedAtCreation case\"\n  )\n  .fn(async t => {\n    let buffer = null;\n    buffer = t.device.createBuffer({\n      size: 256,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n\ng.test('gc_behavior,mapAsync')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mapAsync case\"\n  )\n  .paramsSubcasesOnly(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    let buffer = null;\n    buffer = t.createMappableBuffer(mapMode, 256);\n    await buffer.mapAsync(mapMode);\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n"],"mappings":"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"}
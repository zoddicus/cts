{"version":3,"file":"maxStorageBufferBindingSize.spec.js","names":["align","roundDown","kMaximumLimitBaseParams","makeLimitTestGroup","kBufferParts","getSizeAndOffsetForBufferPart","device","bufferPart","size","limits","minUniformBufferOffsetAlignment","offset","kStorageBufferRequiredSizeAlignment","kExtraLimits","maxBufferSize","getDeviceLimitToRequest","limitValueTest","defaultLimit","maximumLimit","Math","floor","getTestValue","testValueName","requestedLimit","getDeviceLimitToRequestAndValueToTest","testValue","limit","g","description","test","desc","params","combine","fn","t","limitTest","adapterLimit","testDeviceWithSpecificLimits","shouldError","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","pushErrorScope","storageBuffer","trackForCleanup","createBuffer","usage","GPUBufferUsage","STORAGE","outOfMemoryError","popErrorScope","expectValidationError","createBindGroup","layout","resource","expect","adapter","getDefaultLimit"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxStorageBufferBindingSize.spec.ts"],"sourcesContent":["import { align, roundDown } from '../../../../util/math.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  LimitMode,\n  MaximumLimitValueTest,\n  MaximumTestValue,\n} from './limit_utils.js';\n\nconst kBufferParts = ['wholeBuffer', 'biggerBufferWithOffset'] as const;\ntype BufferPart = typeof kBufferParts[number];\n\nfunction getSizeAndOffsetForBufferPart(device: GPUDevice, bufferPart: BufferPart, size: number) {\n  const align = device.limits.minUniformBufferOffsetAlignment;\n  switch (bufferPart) {\n    case 'wholeBuffer':\n      return { size, offset: 0 };\n    case 'biggerBufferWithOffset':\n      return { size: size + align, offset: align };\n  }\n}\n\nconst kStorageBufferRequiredSizeAlignment = 4;\n\n// We also need to update the maxBufferSize limit when testing.\nconst kExtraLimits = { maxBufferSize: 'maxLimit' as LimitMode };\n\nfunction getDeviceLimitToRequest(\n  limitValueTest: MaximumLimitValueTest,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - kStorageBufferRequiredSizeAlignment;\n    case 'betweenDefaultAndMaximum':\n      return Math.floor((defaultLimit + maximumLimit) / 2);\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + kStorageBufferRequiredSizeAlignment;\n  }\n}\n\nfunction getTestValue(testValueName: MaximumTestValue, requestedLimit: number) {\n  switch (testValueName) {\n    case 'atLimit':\n      return roundDown(requestedLimit, kStorageBufferRequiredSizeAlignment);\n    case 'overLimit':\n      // Note: the requestedLimit might not meet alignment requirements.\n      return align(\n        requestedLimit + kStorageBufferRequiredSizeAlignment,\n        kStorageBufferRequiredSizeAlignment\n      );\n  }\n}\n\nfunction getDeviceLimitToRequestAndValueToTest(\n  limitValueTest: MaximumLimitValueTest,\n  testValueName: MaximumTestValue,\n  defaultLimit: number,\n  maximumLimit: number\n) {\n  const requestedLimit = getDeviceLimitToRequest(limitValueTest, defaultLimit, maximumLimit);\n  return {\n    requestedLimit,\n    testValue: getTestValue(testValueName, requestedLimit),\n  };\n}\n\nconst limit = 'maxStorageBufferBindingSize';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createBindGroup,at_over')\n  .desc(`Test using createBindGroup at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams.combine('bufferPart', kBufferParts))\n  .fn(async t => {\n    const { limitTest, testValueName, bufferPart } = t.params;\n    const { defaultLimit, adapterLimit: maximumLimit } = t;\n    const { requestedLimit, testValue } = getDeviceLimitToRequestAndValueToTest(\n      limitTest,\n      testValueName,\n      defaultLimit,\n      maximumLimit\n    );\n\n    await t.testDeviceWithSpecificLimits(\n      requestedLimit,\n      testValue,\n      async ({ device, testValue, shouldError }) => {\n        const bindGroupLayout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: { type: 'storage' },\n            },\n          ],\n        });\n\n        const { size, offset } = getSizeAndOffsetForBufferPart(device, bufferPart, testValue);\n\n        // If the size of the buffer exceeds the related but separate maxBufferSize limit, we can\n        // skip the validation since the allocation will fail with a validation error.\n        if (size > device.limits.maxBufferSize) {\n          return;\n        }\n\n        device.pushErrorScope('out-of-memory');\n        const storageBuffer = t.trackForCleanup(\n          device.createBuffer({\n            usage: GPUBufferUsage.STORAGE,\n            size,\n          })\n        );\n        const outOfMemoryError = await device.popErrorScope();\n\n        if (!outOfMemoryError) {\n          await t.expectValidationError(\n            () => {\n              device.createBindGroup({\n                layout: bindGroupLayout,\n                entries: [\n                  {\n                    binding: 0,\n                    resource: {\n                      buffer: storageBuffer,\n                      offset,\n                      size: testValue,\n                    },\n                  },\n                ],\n              });\n            },\n            shouldError,\n            `size: ${size}, offset: ${offset}, testValue: ${testValue}`\n          );\n        }\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('validate')\n  .desc(`Test that ${limit} is a multiple of 4 bytes`)\n  .fn(t => {\n    const { defaultLimit, adapterLimit } = t;\n    t.expect(defaultLimit % 4 === 0);\n    t.expect(adapterLimit % 4 === 0);\n  });\n\ng.test('validate,maxBufferSize')\n  .desc(`Test that ${limit} <= maxBufferSize`)\n  .fn(t => {\n    const { adapter, defaultLimit, adapterLimit } = t;\n    t.expect(defaultLimit <= t.getDefaultLimit('maxBufferSize'));\n    t.expect(adapterLimit <= adapter.limits.maxBufferSize);\n  });\n"],"mappings":"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"}
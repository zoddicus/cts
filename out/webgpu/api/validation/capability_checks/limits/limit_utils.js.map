{"version":3,"file":"limit_utils.js","names":["kUnitCaseParamsBuilder","makeTestGroup","getGPU","assert","range","reorder","kLimitInfo","kTextureFormatInfo","GPUTestBase","align","kCreatePipelineTypes","kRenderEncoderTypes","kEncoderTypes","kBindGroupTests","kBindingCombinations","getPipelineTypeForBindingCombination","bindingCombination","getBindGroupIndex","bindGroupTest","i","getWGSLBindings","order","storageDefinitionWGSLSnippetFn","numBindings","id","join","computeBytesPerSample","targets","bytesPerSample","format","info","alignedBytesPerSample","colorRender","alignment","byteCost","getPerStageWGSLForBindingCombinationImpl","bodyFn","extraWGSL","getPerStageWGSLForBindingCombination","usageWGSLSnippetFn","set","getPerStageWGSLForBindingCombinationStorageTextures","kLimitModes","kMaximumTestValues","getMaximumTestValue","limit","testValue","kMinimumTestValues","kMaximumLimitValueTests","getLimitValue","defaultLimit","maximumLimit","limitValueTest","Math","floor","kMinimumLimitValueTests","getDefaultLimit","default","kMinimumLimits","Set","kMaximumLimitBaseParams","combine","kMinimumLimitBaseParams","LimitTestsImpl","_adapter","_device","undefined","adapterLimit","init","gpu","rec","requestAdapter","adapter","limits","Number","isNaN","device","requestDeviceWithLimits","requiredLimits","shouldReject","requiredFeatures","requestDevice","getDefaultOrAdapterLimit","limitMode","_getDeviceWithSpecificLimit","requestedLimit","extraLimits","features","extraLimitStr","Object","entries","extraLimit","has","actualLimit","expect","_getDeviceWithRequestedMaximumLimit","_testThenDestroyDevice","deviceAndLimits","fn","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","testDeviceWithSpecificLimits","deviceLimitValue","testDeviceWithRequestedMaximumLimits","limitTest","testValueName","inputs","expectGPUErrorAsync","filter","msg","returnValue","Promise","error","shouldRejectConditionally","expectedName","p","shouldResolve","e","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","getGroupIndexWGSLForPipelineType","pipelineType","groupIndex","getBindingIndexWGSLForPipelineType","bindingIndex","_createRenderPipelineDescriptor","module","layout","vertex","entryPoint","_createRenderPipelineDescriptorWithFragmentShader","fragment","depthStencil","depthWriteEnabled","depthCompare","_createComputePipelineDescriptor","compute","createPipeline","createPipelineType","createRenderPipeline","createComputePipeline","createPipelineAsync","createRenderPipelineAsync","createComputePipelineAsync","testCreatePipeline","async","testCreateRenderPipeline","pipelineDescriptor","testMaxComputeWorkgroupSize","axis","kExtraLimits","maxComputeInvocationsPerWorkgroup","size","codePointAt","code","getModuleForWorkgroupSize","_getGPURenderCommandsMixin","encoderType","buffer","trackForCleanup","createBuffer","usage","GPUBufferUsage","UNIFORM","texture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","createBindGroupLayout","binding","visibility","GPUShaderStage","VERTEX","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","mixin","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","prep","end","test","finish","createRenderBundleEncoder","colorFormats","testGPURenderCommandsMixin","_getGPUBindingCommandsMixin","COMPUTE","beginComputePass","testGPUBindingCommandsMixin","createShaderModule","makeLimitTestFixture","LimitTests","makeLimitTestGroup","description","g"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["import { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert, range, reorder, ReorderOrder } from '../../../../../common/util/util.js';\nimport { kLimitInfo } from '../../../../capability_info.js';\nimport { kTextureFormatInfo } from '../../../../format_info.js';\nimport { GPUTestBase } from '../../../../gpu_test.js';\nimport { align } from '../../../../util/math.js';\n\ntype GPUSupportedLimit = keyof GPUSupportedLimits;\n\nexport const kCreatePipelineTypes = [\n  'createRenderPipeline',\n  'createRenderPipelineWithFragmentStage',\n  'createComputePipeline',\n] as const;\nexport type CreatePipelineType = typeof kCreatePipelineTypes[number];\n\nexport const kRenderEncoderTypes = ['render', 'renderBundle'] as const;\nexport type RenderEncoderType = typeof kRenderEncoderTypes[number];\n\nexport const kEncoderTypes = ['compute', 'render', 'renderBundle'] as const;\nexport type EncoderType = typeof kEncoderTypes[number];\n\nexport const kBindGroupTests = ['sameGroup', 'differentGroups'] as const;\nexport type BindGroupTest = typeof kBindGroupTests[number];\n\nexport const kBindingCombinations = [\n  'vertex',\n  'fragment',\n  'vertexAndFragmentWithPossibleVertexStageOverflow',\n  'vertexAndFragmentWithPossibleFragmentStageOverflow',\n  'compute',\n] as const;\nexport type BindingCombination = typeof kBindingCombinations[number];\n\nexport function getPipelineTypeForBindingCombination(bindingCombination: BindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return 'createRenderPipeline';\n    case 'fragment':\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return 'createRenderPipelineWithFragmentStage';\n    case 'compute':\n      return 'createComputePipeline';\n  }\n}\n\nfunction getBindGroupIndex(bindGroupTest: BindGroupTest, i: number) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return 0;\n    case 'differentGroups':\n      return i % 3;\n  }\n}\n\nfunction getWGSLBindings(\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  numBindings: number,\n  id: number\n) {\n  return reorder(\n    order,\n    range(\n      numBindings,\n      i =>\n        `@group(${getBindGroupIndex(\n          bindGroupTest,\n          i\n        )}) @binding(${i}) ${storageDefinitionWGSLSnippetFn(i, id)};`\n    )\n  ).join('\\n        ');\n}\n\n/**\n * Given an array of GPUColorTargetState return the number of bytes per sample\n */\nexport function computeBytesPerSample(targets: GPUColorTargetState[]) {\n  let bytesPerSample = 0;\n  for (const { format } of targets) {\n    const info = kTextureFormatInfo[format];\n    const alignedBytesPerSample = align(bytesPerSample, info.colorRender!.alignment);\n    bytesPerSample = alignedBytesPerSample + info.colorRender!.byteCost;\n  }\n  return bytesPerSample;\n}\n\nexport function getPerStageWGSLForBindingCombinationImpl(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  bodyFn: (numBindings: number, set: number) => string,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n      `;\n    case 'fragment':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings, 0)}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings - 1, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings - 1, 1)}\n        }\n      `;\n    }\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings - 1, 0)}\n\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings - 1, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 1)}\n        }\n      `;\n    }\n    case 'compute':\n      return `\n        ${extraWGSL}\n        ${getWGSLBindings(order, bindGroupTest, storageDefinitionWGSLSnippetFn, numBindings, 0)}\n        @group(3) @binding(0) var<storage, read_write> d: f32;\n        @compute @workgroup_size(1) fn main() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n      break;\n  }\n}\n\nexport function getPerStageWGSLForBindingCombination(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport function getPerStageWGSLForBindingCombinationStorageTextures(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport const kLimitModes = ['defaultLimit', 'adapterLimit'] as const;\nexport type LimitMode = typeof kLimitModes[number];\nexport type LimitsRequest = Record<string, LimitMode>;\n\nexport const kMaximumTestValues = ['atLimit', 'overLimit'] as const;\nexport type MaximumTestValue = typeof kMaximumTestValues[number];\n\nexport function getMaximumTestValue(limit: number, testValue: MaximumTestValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const kMinimumTestValues = ['atLimit', 'underLimit'] as const;\nexport type MinimumTestValue = typeof kMinimumTestValues[number];\n\nexport const kMaximumLimitValueTests = [\n  'atDefault',\n  'underDefault',\n  'betweenDefaultAndMaximum',\n  'atMaximum',\n  'overMaximum',\n] as const;\nexport type MaximumLimitValueTest = typeof kMaximumLimitValueTests[number];\n\nexport function getLimitValue(\n  defaultLimit: number,\n  maximumLimit: number,\n  limitValueTest: MaximumLimitValueTest\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'betweenDefaultAndMaximum':\n      // The result can be larger than maximum i32.\n      return Math.floor((defaultLimit + maximumLimit) / 2);\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport const kMinimumLimitValueTests = [\n  'atDefault',\n  'overDefault',\n  'betweenDefaultAndMinimum',\n  'atMinimum',\n  'underMinimum',\n] as const;\nexport type MinimumLimitValueTest = typeof kMinimumLimitValueTests[number];\n\nexport function getDefaultLimit(limit: GPUSupportedLimit): number {\n  return (kLimitInfo as Record<string, { default: number }>)[limit].default;\n}\n\nexport type DeviceAndLimits = {\n  device: GPUDevice;\n  defaultLimit: number;\n  adapterLimit: number;\n  requestedLimit: number;\n  actualLimit: number;\n};\n\nexport type SpecificLimitTestInputs = DeviceAndLimits & {\n  testValue: number;\n  shouldError: boolean;\n};\n\nexport type MaximumLimitTestInputs = SpecificLimitTestInputs & {\n  testValueName: MaximumTestValue;\n};\n\nconst kMinimumLimits = new Set<GPUSupportedLimit>([\n  'minUniformBufferOffsetAlignment',\n  'minStorageBufferOffsetAlignment',\n]);\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kMaximumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMaximumLimitValueTests)\n  .combine('testValueName', kMaximumTestValues);\n\nexport const kMinimumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMinimumLimitValueTests)\n  .combine('testValueName', kMinimumTestValues);\n\nexport class LimitTestsImpl extends GPUTestBase {\n  _adapter: GPUAdapter | null = null;\n  _device: GPUDevice | undefined = undefined;\n  limit: GPUSupportedLimit = '' as GPUSupportedLimit;\n  defaultLimit = 0;\n  adapterLimit = 0;\n\n  async init() {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    this._adapter = await gpu.requestAdapter();\n    const limit = this.limit;\n    this.defaultLimit = getDefaultLimit(limit);\n    this.adapterLimit = this.adapter.limits[limit] as number;\n    assert(!Number.isNaN(this.defaultLimit));\n    assert(!Number.isNaN(this.adapterLimit));\n  }\n\n  get adapter(): GPUAdapter {\n    assert(this._adapter !== undefined);\n    return this._adapter!;\n  }\n\n  get device(): GPUDevice {\n    assert(this._device !== undefined, 'device is only valid in _testThenDestroyDevice callback');\n    return this._device;\n  }\n\n  async requestDeviceWithLimits(\n    adapter: GPUAdapter,\n    requiredLimits: Record<string, number>,\n    shouldReject: boolean,\n    requiredFeatures?: GPUFeatureName[]\n  ) {\n    if (shouldReject) {\n      this.shouldReject('OperationError', adapter.requestDevice({ requiredLimits }));\n      return undefined;\n    } else {\n      return await adapter.requestDevice({ requiredLimits, requiredFeatures });\n    }\n  }\n\n  getDefaultOrAdapterLimit(limit: GPUSupportedLimit, limitMode: LimitMode) {\n    switch (limitMode) {\n      case 'defaultLimit':\n        return getDefaultLimit(limit);\n      case 'adapterLimit':\n        return this.adapter.limits[limit];\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithSpecificLimit(\n    requestedLimit: number,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { adapter, limit, adapterLimit, defaultLimit } = this;\n\n    const requiredLimits: Record<string, number> = {};\n    requiredLimits[limit] = requestedLimit;\n\n    if (extraLimits) {\n      for (const [extraLimitStr, limitMode] of Object.entries(extraLimits)) {\n        const extraLimit = extraLimitStr as GPUSupportedLimit;\n        requiredLimits[extraLimit] =\n          limitMode === 'defaultLimit'\n            ? getDefaultLimit(extraLimit)\n            : (adapter.limits[extraLimit] as number);\n      }\n    }\n\n    const shouldReject = kMinimumLimits.has(limit)\n      ? requestedLimit < adapterLimit\n      : requestedLimit > adapterLimit;\n\n    const device = await this.requestDeviceWithLimits(\n      adapter,\n      requiredLimits,\n      shouldReject,\n      features\n    );\n    const actualLimit = (device ? device.limits[limit] : 0) as number;\n\n    if (shouldReject) {\n      this.expect(!device, 'expected no device');\n    } else {\n      if (kMinimumLimits.has(limit)) {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${requestedLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        }\n      } else {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal requestedLimit: ${requestedLimit}`\n          );\n        }\n      }\n    }\n\n    return device ? { device, defaultLimit, adapterLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedMaximumLimit(\n    limitValueTest: MaximumLimitValueTest,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { defaultLimit, adapterLimit: maximumLimit } = this;\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n    return this._getDeviceWithSpecificLimit(requestedLimit, extraLimits, features);\n  }\n\n  /**\n   * Call the given function and check no WebGPU errors are leaked.\n   */\n  async _testThenDestroyDevice(\n    deviceAndLimits: DeviceAndLimits,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>\n  ) {\n    assert(!this._device);\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n\n    const shouldError = kMinimumLimits.has(this.limit)\n      ? testValue < actualLimit\n      : testValue > actualLimit;\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, `unexpected validation error: ${validationError?.message || ''}`);\n    this.expect(\n      !outOfMemoryError,\n      `unexpected out-of-memory error: ${outOfMemoryError?.message || ''}`\n    );\n    this.expect(!internalError, `unexpected internal error: ${internalError?.message || ''}`);\n\n    device.destroy();\n    this._device = undefined;\n  }\n\n  /**\n   * Creates a device with a specific limit.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithSpecificLimits(\n    deviceLimitValue: number,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithSpecificLimit(\n      deviceLimitValue,\n      extraLimits,\n      features\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    await this._testThenDestroyDevice(deviceAndLimits, testValue, fn);\n  }\n\n  /**\n   * Creates a device with the limit defined by LimitValueTest.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedMaximumLimits(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    fn: (inputs: MaximumLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedMaximumLimit(limitTest, extraLimits);\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { actualLimit } = deviceAndLimits;\n    const testValue = getMaximumTestValue(actualLimit, testValueName);\n\n    await this._testThenDestroyDevice(\n      deviceAndLimits,\n      testValue,\n      async (inputs: SpecificLimitTestInputs) => {\n        await fn({ ...inputs, testValueName });\n      }\n    );\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUErrorAsync<R>(\n    filter: GPUErrorFilter,\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  async shouldRejectConditionally(\n    expectedName: string,\n    p: Promise<unknown>,\n    shouldReject: boolean,\n    msg?: string\n  ): Promise<void> {\n    if (shouldReject) {\n      this.shouldReject(expectedName, p, msg);\n    } else {\n      this.shouldResolve(p, msg);\n    }\n\n    // We need to explicitly wait for the promise because the device may be\n    // destroyed immediately after returning from this function.\n    try {\n      await p;\n    } catch (e) {\n      //\n    }\n  }\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  async expectValidationError<R>(fn: () => R, shouldError: boolean = true, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError<R>(fn: () => R, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  getGroupIndexWGSLForPipelineType(pipelineType: CreatePipelineType, groupIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  getBindingIndexWGSLForPipelineType(pipelineType: CreatePipelineType, bindingIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  _createRenderPipelineDescriptor(module: GPUShaderModule): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n    };\n  }\n\n  _createRenderPipelineDescriptorWithFragmentShader(\n    module: GPUShaderModule\n  ): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n      fragment: {\n        module,\n        entryPoint: 'mainFS',\n        targets: [],\n      },\n      depthStencil: {\n        format: 'depth24plus-stencil8',\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n      },\n    };\n  }\n\n  _createComputePipelineDescriptor(module: GPUShaderModule): GPUComputePipelineDescriptor {\n    return {\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  createPipeline(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipeline(this._createRenderPipelineDescriptor(module));\n        break;\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipeline(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n        break;\n      case 'createComputePipeline':\n        return device.createComputePipeline(this._createComputePipelineDescriptor(module));\n        break;\n    }\n  }\n\n  createPipelineAsync(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipelineAsync(this._createRenderPipelineDescriptor(module));\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipelineAsync(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n      case 'createComputePipeline':\n        return device.createComputePipelineAsync(this._createComputePipelineDescriptor(module));\n    }\n  }\n\n  async testCreatePipeline(\n    createPipelineType: CreatePipelineType,\n    async: boolean,\n    module: GPUShaderModule,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        this.createPipelineAsync(createPipelineType, module),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          this.createPipeline(createPipelineType, module);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testCreateRenderPipeline(\n    pipelineDescriptor: GPURenderPipelineDescriptor,\n    async: boolean,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { device } = this;\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        device.createRenderPipelineAsync(pipelineDescriptor),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          device.createRenderPipeline(pipelineDescriptor);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testMaxComputeWorkgroupSize(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    async: boolean,\n    axis: 'X' | 'Y' | 'Z'\n  ) {\n    const kExtraLimits: LimitsRequest = {\n      maxComputeInvocationsPerWorkgroup: 'adapterLimit',\n    };\n\n    await this.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        if (testValue > device.limits.maxComputeInvocationsPerWorkgroup) {\n          return;\n        }\n\n        const size = [1, 1, 1];\n        size[axis.codePointAt(0)! - 'X'.codePointAt(0)!] = testValue;\n        const { module, code } = this.getModuleForWorkgroupSize(size);\n\n        await this.testCreatePipeline(\n          'createComputePipeline',\n          async,\n          module,\n          shouldError,\n          `size: ${testValue}, limit: ${actualLimit}\\n${code}`\n        );\n      },\n      kExtraLimits\n    );\n  }\n\n  /**\n   * Creates an GPURenderCommandsMixin setup with some initial state.\n   */\n  _getGPURenderCommandsMixin(encoderType: RenderEncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'render': {\n        const buffer = this.trackForCleanup(\n          device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM,\n          })\n        );\n\n        const texture = this.trackForCleanup(\n          device.createTexture({\n            size: [1, 1],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          })\n        );\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const mixin = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: texture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n\n        return {\n          mixin,\n          bindGroup,\n          prep() {\n            mixin.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n\n      case 'renderBundle': {\n        const buffer = this.trackForCleanup(\n          device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM,\n          })\n        );\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const mixin = device.createRenderBundleEncoder({\n          colorFormats: ['rgba8unorm'],\n        });\n\n        return {\n          mixin,\n          bindGroup,\n          prep() {},\n          test() {\n            mixin.finish();\n          },\n        };\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests a method on GPURenderCommandsMixin\n   * The function will be called with the mixin.\n   */\n  async testGPURenderCommandsMixin(\n    encoderType: RenderEncoderType,\n    fn: ({ mixin }: { mixin: GPURenderCommandsMixin }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { mixin, prep, test } = this._getGPURenderCommandsMixin(encoderType);\n    fn({ mixin });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  /**\n   * Creates GPUBindingCommandsMixin setup with some initial state.\n   */\n  _getGPUBindingCommandsMixin(encoderType: EncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'compute': {\n        const buffer = this.trackForCleanup(\n          device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM,\n          })\n        );\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const mixin = encoder.beginComputePass();\n        return {\n          mixin,\n          bindGroup,\n          prep() {\n            mixin.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n      case 'render':\n        return this._getGPURenderCommandsMixin('render');\n      case 'renderBundle':\n        return this._getGPURenderCommandsMixin('renderBundle');\n    }\n  }\n\n  /**\n   * Tests a method on GPUBindingCommandsMixin\n   * The function pass will be called with the mixin and a bindGroup\n   */\n  async testGPUBindingCommandsMixin(\n    encoderType: EncoderType,\n    fn: ({ bindGroup }: { mixin: GPUBindingCommandsMixin; bindGroup: GPUBindGroup }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { mixin, bindGroup, prep, test } = this._getGPUBindingCommandsMixin(encoderType);\n    fn({ mixin, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  getModuleForWorkgroupSize(size: number[]) {\n    const { device } = this;\n    const code = `\n      @group(0) @binding(0) var<storage, read_write> d: f32;\n      @compute @workgroup_size(${size.join(',')}) fn main() {\n        d = 0;\n      }\n    `;\n    const module = device.createShaderModule({ code });\n    return { module, code };\n  }\n}\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(limit: GPUSupportedLimit): typeof LimitTestsImpl {\n  class LimitTests extends LimitTestsImpl {\n    limit = limit;\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit: GPUSupportedLimit) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit));\n  return { g, description, limit };\n}\n"],"mappings":"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"}
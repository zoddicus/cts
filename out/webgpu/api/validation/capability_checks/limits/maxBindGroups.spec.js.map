{"version":3,"file":"maxBindGroups.spec.js","names":["assert","kCreatePipelineTypes","kEncoderTypes","kMaximumLimitBaseParams","makeLimitTestGroup","limit","g","description","kLimitToBindingLayout","name","entry","texture","sampler","buffer","type","storageTexture","access","format","viewDimension","getBindingLayoutEntriesForStage","device","limits","i","getBindingLayoutEntriesForRenderPipeline","visibilities","GPUShaderStage","VERTEX","FRAGMENT","visibility","bindEntryResourceType","binding","getTotalPossibleBindingsPerRenderPipeline","totalPossibleBindingsPerStage","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage","maxUniformBuffersPerShaderStage","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","getBindingLayoutEntries","count","iter","next","value","test","desc","params","fn","t","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","testValue","shouldError","actualLimit","totalPossibleBindingsPerPipeline","bindingDescriptions","bindGroupLayouts","map","push","JSON","stringify","length","createBindGroupLayout","entries","expectValidationError","createPipelineLayout","join","combine","createPipelineType","async","lastIndex","code","getGroupIndexWGSLForPipelineType","module","createShaderModule","testCreatePipeline","encoderType","testGPUBindingCommandsMixin","passEncoder","bindGroup","setBindGroup","adapter","defaultLimit","adapterLimit","expect","getDefaultLimit","maxBindGroupsPlusVertexBuffers"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxBindGroups.spec.ts"],"sourcesContent":["import { assert } from '../../../../../common/util/util.js';\n\nimport {\n  kCreatePipelineTypes,\n  kEncoderTypes,\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n} from './limit_utils.js';\n\nconst limit = 'maxBindGroups';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ntype BindingLayout = {\n  buffer?: GPUBufferBindingLayout;\n  sampler?: GPUSamplerBindingLayout;\n  texture?: GPUTextureBindingLayout;\n  storageTexture?: GPUStorageTextureBindingLayout;\n  externalTexture?: GPUExternalTextureBindingLayout;\n};\n\ntype LimitToBindingLayout = {\n  name: keyof GPUSupportedLimits;\n  entry: BindingLayout;\n};\n\nconst kLimitToBindingLayout: readonly LimitToBindingLayout[] = [\n  {\n    name: 'maxSampledTexturesPerShaderStage',\n    entry: {\n      texture: {},\n    },\n  },\n  {\n    name: 'maxSamplersPerShaderStage',\n    entry: {\n      sampler: {},\n    },\n  },\n  {\n    name: 'maxUniformBuffersPerShaderStage',\n    entry: {\n      buffer: {},\n    },\n  },\n  {\n    name: 'maxStorageBuffersPerShaderStage',\n    entry: {\n      buffer: {\n        type: 'read-only-storage',\n      },\n    },\n  },\n  {\n    name: 'maxStorageTexturesPerShaderStage',\n    entry: {\n      storageTexture: {\n        access: 'write-only',\n        format: 'rgba8unorm',\n        viewDimension: '2d',\n      },\n    },\n  },\n] as const;\n\n/**\n * Yields all possible binding layout entries for a stage.\n */\nfunction* getBindingLayoutEntriesForStage(device: GPUDevice) {\n  for (const { name, entry } of kLimitToBindingLayout) {\n    const limit = device.limits[name] as number;\n    for (let i = 0; i < limit; ++i) {\n      yield entry;\n    }\n  }\n}\n\n/**\n * Yields all of the possible BindingLayoutEntryAndVisibility entries for a render pipeline\n */\nfunction* getBindingLayoutEntriesForRenderPipeline(\n  device: GPUDevice\n): Generator<GPUBindGroupLayoutEntry> {\n  const visibilities = [GPUShaderStage.VERTEX, GPUShaderStage.FRAGMENT];\n  for (const visibility of visibilities) {\n    for (const bindEntryResourceType of getBindingLayoutEntriesForStage(device)) {\n      const entry: GPUBindGroupLayoutEntry = {\n        binding: 0,\n        visibility,\n        ...bindEntryResourceType,\n      };\n      yield entry;\n    }\n  }\n}\n\n/**\n * Returns the total possible bindings per render pipeline\n */\nfunction getTotalPossibleBindingsPerRenderPipeline(device: GPUDevice) {\n  const totalPossibleBindingsPerStage =\n    device.limits.maxSampledTexturesPerShaderStage +\n    device.limits.maxSamplersPerShaderStage +\n    device.limits.maxUniformBuffersPerShaderStage +\n    device.limits.maxStorageBuffersPerShaderStage +\n    device.limits.maxStorageTexturesPerShaderStage;\n  return totalPossibleBindingsPerStage * 2;\n}\n\n/**\n * Yields count GPUBindGroupLayoutEntries\n */\nfunction* getBindingLayoutEntries(\n  device: GPUDevice,\n  count: number\n): Generator<GPUBindGroupLayoutEntry> {\n  assert(count < getTotalPossibleBindingsPerRenderPipeline(device));\n  const iter = getBindingLayoutEntriesForRenderPipeline(device);\n  for (; count > 0; --count) {\n    yield iter.next().value;\n  }\n}\n\ng.test('createPipelineLayout,at_over')\n  .desc(`Test using createPipelineLayout at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams)\n  .fn(async t => {\n    const { limitTest, testValueName } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        const totalPossibleBindingsPerPipeline = getTotalPossibleBindingsPerRenderPipeline(device);\n        // Not sure what to do if we ever hit this but I think it's better to assert than silently skip.\n        assert(\n          testValue < totalPossibleBindingsPerPipeline,\n          `not enough possible bindings(${totalPossibleBindingsPerPipeline}) to test ${testValue} bindGroups`\n        );\n\n        const bindingDescriptions: string[] = [];\n        const bindGroupLayouts = [...getBindingLayoutEntries(device, testValue)].map(entry => {\n          bindingDescriptions.push(\n            `${JSON.stringify(entry)} // group(${bindingDescriptions.length})`\n          );\n          return device.createBindGroupLayout({\n            entries: [entry],\n          });\n        });\n\n        await t.expectValidationError(\n          () => {\n            device.createPipelineLayout({ bindGroupLayouts });\n          },\n          shouldError,\n          `testing ${testValue} bindGroups on maxBindGroups = ${actualLimit} with \\n${bindingDescriptions.join(\n            '\\n'\n          )}`\n        );\n      }\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(\n    `Test using createRenderPipeline(Async) and createComputePipeline(Async) at and over ${limit} limit`\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('createPipelineType', kCreatePipelineTypes)\n      .combine('async', [false, true] as const)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, createPipelineType, async } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const lastIndex = testValue - 1;\n\n        const code = t.getGroupIndexWGSLForPipelineType(createPipelineType, lastIndex);\n        const module = device.createShaderModule({ code });\n\n        await t.testCreatePipeline(createPipelineType, async, module, shouldError);\n      }\n    );\n  });\n\ng.test('setBindGroup,at_over')\n  .desc(`Test using setBindGroup at and over ${limit} limit`)\n  .params(kMaximumLimitBaseParams.combine('encoderType', kEncoderTypes))\n  .fn(async t => {\n    const { limitTest, testValueName, encoderType } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ testValue, actualLimit, shouldError }) => {\n        const lastIndex = testValue - 1;\n        await t.testGPUBindingCommandsMixin(\n          encoderType,\n          ({ passEncoder, bindGroup }) => {\n            passEncoder.setBindGroup(lastIndex, bindGroup);\n          },\n          shouldError,\n          `shouldError: ${shouldError}, actualLimit: ${actualLimit}, testValue: ${lastIndex}`\n        );\n      }\n    );\n  });\n\ng.test('validate,maxBindGroupsPlusVertexBuffers')\n  .desc(`Test that ${limit} <= maxBindGroupsPlusVertexBuffers`)\n  .fn(t => {\n    const { adapter, defaultLimit, adapterLimit } = t;\n    t.expect(defaultLimit <= t.getDefaultLimit('maxBindGroupsPlusVertexBuffers'));\n    t.expect(adapterLimit <= adapter.limits.maxBindGroupsPlusVertexBuffers);\n  });\n"],"mappings":"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"}
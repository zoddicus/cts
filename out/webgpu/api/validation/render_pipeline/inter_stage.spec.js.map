{"version":3,"file":"inter_stage.spec.js","names":["description","makeTestGroup","range","CreateRenderPipelineValidationTest","getVarName","i","InterStageMatchingValidationTest","getVertexStateWithOutputs","outputs","module","device","createShaderModule","code","map","v","replace","join","entryPoint","getFragmentStateWithInputs","inputs","hasBuiltinPosition","targets","format","getDescriptorWithStates","vertex","fragment","layout","g","test","desc","params","u","combine","combineWithParams","_success","fn","t","isAsync","descriptor","doCreateRenderPipelineTest","output","input","_compat_success","shouldSucceed","isCompatibility","locationDelta","maxInterStageShaderVariables","limits","location","numScalarDelta","topology","numScalarComponents","maxInterStageShaderComponents","numVec4","Math","floor","numTrailingScalars","typeString","push","primitive","useExtraBuiltinInputs","numExtraComponents","numUsedComponents","success"],"sources":["../../../../../src/webgpu/api/validation/render_pipeline/inter_stage.spec.ts"],"sourcesContent":["export const description = `\nInterface matching between vertex and fragment shader validation for createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { range } from '../../../../common/util/util.js';\n\nimport { CreateRenderPipelineValidationTest } from './common.js';\n\nfunction getVarName(i: number) {\n  return `v${i}`;\n}\n\nclass InterStageMatchingValidationTest extends CreateRenderPipelineValidationTest {\n  getVertexStateWithOutputs(outputs: readonly string[]): GPUVertexState {\n    return {\n      module: this.device.createShaderModule({\n        code: `\n        struct A {\n            ${outputs.map((v, i) => v.replace('__', getVarName(i))).join(',\\n')},\n            @builtin(position) pos: vec4<f32>,\n        }\n        @vertex fn main() -> A {\n            var vertexOut: A;\n            vertexOut.pos = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            return vertexOut;\n        }\n        `,\n      }),\n      entryPoint: 'main',\n    };\n  }\n\n  getFragmentStateWithInputs(\n    inputs: readonly string[],\n    hasBuiltinPosition: boolean = false\n  ): GPUFragmentState {\n    return {\n      targets: [{ format: 'rgba8unorm' }],\n      module: this.device.createShaderModule({\n        code: `\n        struct B {\n            ${inputs.map((v, i) => v.replace('__', getVarName(i))).join(',\\n')},\n            ${hasBuiltinPosition ? '@builtin(position) pos: vec4<f32>' : ''}\n        }\n        @fragment fn main(fragmentIn: B) -> @location(0) vec4<f32> {\n            return vec4<f32>(1.0, 1.0, 1.0, 1.0);\n        }\n        `,\n      }),\n      entryPoint: 'main',\n    };\n  }\n\n  getDescriptorWithStates(\n    vertex: GPUVertexState,\n    fragment: GPUFragmentState\n  ): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex,\n      fragment,\n    };\n  }\n}\n\nexport const g = makeTestGroup(InterStageMatchingValidationTest);\n\ng.test('location,mismatch')\n  .desc(`Tests that missing declaration at the same location should fail validation.`)\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      { outputs: ['@location(0) __: f32'], inputs: ['@location(0) __: f32'], _success: true },\n      { outputs: ['@location(0) __: f32'], inputs: ['@location(1) __: f32'], _success: false },\n      { outputs: ['@location(1) __: f32'], inputs: ['@location(0) __: f32'], _success: false },\n      {\n        outputs: ['@location(0) __: f32', '@location(1) __: f32'],\n        inputs: ['@location(1) __: f32', '@location(0) __: f32'],\n        _success: true,\n      },\n      {\n        outputs: ['@location(1) __: f32', '@location(0) __: f32'],\n        inputs: ['@location(0) __: f32', '@location(1) __: f32'],\n        _success: true,\n      },\n    ])\n  )\n  .fn(t => {\n    const { isAsync, outputs, inputs, _success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs)\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('location,superset')\n  .desc(`Tests that validation should succeed when vertex output is superset of fragment input`)\n  .params(u => u.combine('isAsync', [false, true]))\n  .fn(t => {\n    const { isAsync } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(['@location(0) vout0: f32', '@location(1) vout1: f32']),\n      t.getFragmentStateWithInputs(['@location(1) fin1: f32'])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, true, descriptor);\n  });\n\ng.test('location,subset')\n  .desc(`Tests that validation should fail when vertex output is a subset of fragment input.`)\n  .params(u => u.combine('isAsync', [false, true]))\n  .fn(t => {\n    const { isAsync } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(['@location(0) vout0: f32']),\n      t.getFragmentStateWithInputs(['@location(0) fin0: f32', '@location(1) fin1: f32'])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, false, descriptor);\n  });\n\ng.test('type')\n  .desc(\n    `Tests that validation should fail when type of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      { output: 'f32', input: 'f32' },\n      { output: 'i32', input: 'f32' },\n      { output: 'u32', input: 'f32' },\n      { output: 'u32', input: 'i32' },\n      { output: 'i32', input: 'u32' },\n      { output: 'vec2<f32>', input: 'vec2<f32>' },\n      { output: 'vec3<f32>', input: 'vec2<f32>' },\n      { output: 'vec2<f32>', input: 'vec3<f32>' },\n      { output: 'vec2<f32>', input: 'f32' },\n      { output: 'f32', input: 'vec2<f32>' },\n    ])\n  )\n  .fn(t => {\n    const { isAsync, output, input } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) @interpolate(flat) vout0: ${output}`]),\n      t.getFragmentStateWithInputs([`@location(0) @interpolate(flat) fin0: ${input}`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, output === input, descriptor);\n  });\n\ng.test('interpolation_type')\n  .desc(\n    `Tests that validation should fail when interpolation type of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // default is @interpolate(perspective, center)\n      { output: '', input: '' },\n      { output: '', input: '@interpolate(perspective)', _success: true },\n      { output: '', input: '@interpolate(perspective, center)', _success: true },\n      { output: '@interpolate(perspective)', input: '', _success: true },\n      { output: '', input: '@interpolate(linear)' },\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(linear)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(flat)', input: '@interpolate(perspective)' },\n      { output: '@interpolate(linear)', input: '@interpolate(flat)' },\n      {\n        output: '@interpolate(linear, center)',\n        input: '@interpolate(linear, center)',\n        _compat_success: false,\n      },\n    ])\n  )\n  .fn(t => {\n    const { isAsync, output, input, _success, _compat_success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) ${output} vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(0) ${input} fin0: f32`])\n    );\n\n    const shouldSucceed =\n      (_success ?? output === input) && (!t.isCompatibility || _compat_success !== false);\n\n    t.doCreateRenderPipelineTest(isAsync, shouldSucceed, descriptor);\n  });\n1;\ng.test('interpolation_sampling')\n  .desc(\n    `Tests that validation should fail when interpolation sampling of vertex output and fragment input at the same location doesn't match.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // default is @interpolate(perspective, center)\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective)' },\n      {\n        output: '@interpolate(perspective)',\n        input: '@interpolate(perspective, center)',\n        _success: true,\n      },\n      {\n        output: '@interpolate(linear, center)',\n        input: '@interpolate(linear)',\n        _success: true,\n        _compat_success: false,\n      },\n      { output: '@interpolate(flat)', input: '@interpolate(flat)' },\n      { output: '@interpolate(perspective)', input: '@interpolate(perspective, sample)' },\n      { output: '@interpolate(perspective, center)', input: '@interpolate(perspective, sample)' },\n      {\n        output: '@interpolate(perspective, center)',\n        input: '@interpolate(perspective, centroid)',\n      },\n      { output: '@interpolate(perspective, centroid)', input: '@interpolate(perspective)' },\n    ])\n  )\n  .fn(t => {\n    const { isAsync, output, input, _success, _compat_success } = t.params;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(0) ${output} vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(0) ${input} fin0: f32`])\n    );\n\n    const shouldSucceed =\n      (_success ?? output === input) && (!t.isCompatibility || _compat_success !== false);\n\n    t.doCreateRenderPipelineTest(isAsync, shouldSucceed, descriptor);\n  });\n\ng.test('max_shader_variable_location')\n  .desc(\n    `Tests that validation should fail when there is location of user-defined output/input variable >= device.limits.maxInterStageShaderVariables`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      // User defined variable location = maxInterStageShaderVariables + locationDelta\n      .combine('locationDelta', [0, -1, -2])\n  )\n  .fn(t => {\n    const { isAsync, locationDelta } = t.params;\n    const maxInterStageShaderVariables = t.device.limits.maxInterStageShaderVariables;\n    const location = maxInterStageShaderVariables + locationDelta;\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs([`@location(${location}) vout0: f32`]),\n      t.getFragmentStateWithInputs([`@location(${location}) fin0: f32`])\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, location < maxInterStageShaderVariables, descriptor);\n  });\n\ng.test('max_components_count,output')\n  .desc(\n    `Tests that validation should fail when scalar components of all user-defined outputs > max vertex shader output components.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // Number of user-defined output scalar components in test shader =\n      //     Math.floor((device.limits.maxInterStageShaderComponents + numScalarDelta) / 4) * 4.\n      { numScalarDelta: 0, topology: 'triangle-list', _success: true },\n      { numScalarDelta: 1, topology: 'triangle-list', _success: false },\n      { numScalarDelta: 0, topology: 'point-list', _success: false },\n      { numScalarDelta: -1, topology: 'point-list', _success: false },\n      { numScalarDelta: -3, topology: 'point-list', _success: false },\n      { numScalarDelta: -4, topology: 'point-list', _success: true },\n    ] as const)\n  )\n  .fn(t => {\n    const { isAsync, numScalarDelta, topology, _success } = t.params;\n\n    const numScalarComponents = t.device.limits.maxInterStageShaderComponents + numScalarDelta;\n\n    const numVec4 = Math.floor(numScalarComponents / 4);\n    const numTrailingScalars = numScalarComponents % 4;\n\n    const outputs = range(numVec4, i => `@location(${i}) vout${i}: vec4<f32>`);\n    const inputs = range(numVec4, i => `@location(${i}) fin${i}: vec4<f32>`);\n\n    if (numTrailingScalars > 0) {\n      const typeString = numTrailingScalars === 1 ? 'f32' : `vec${numTrailingScalars}<f32>`;\n      outputs.push(`@location(${numVec4}) vout${numVec4}: ${typeString}`);\n      inputs.push(`@location(${numVec4}) fin${numVec4}: ${typeString}`);\n    }\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs)\n    );\n    descriptor.primitive = { topology };\n\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('max_components_count,input')\n  .desc(\n    `Tests that validation should fail when scalar components of all user-defined inputs > max vertex shader output components.`\n  )\n  .params(u =>\n    u.combine('isAsync', [false, true]).combineWithParams([\n      // Number of user-defined input scalar components in test shader =\n      //     Math.floor((device.limits.maxInterStageShaderComponents + numScalarDelta) / 4) * 4.\n      { numScalarDelta: 0, useExtraBuiltinInputs: false },\n      { numScalarDelta: 1, useExtraBuiltinInputs: false },\n      { numScalarDelta: 0, useExtraBuiltinInputs: true },\n      { numScalarDelta: -3, useExtraBuiltinInputs: true },\n      { numScalarDelta: -4, useExtraBuiltinInputs: true },\n    ] as const)\n  )\n  .fn(t => {\n    const { isAsync, numScalarDelta, useExtraBuiltinInputs } = t.params;\n\n    const numScalarComponents =\n      Math.floor((t.device.limits.maxInterStageShaderComponents + numScalarDelta) / 4) * 4;\n    const numExtraComponents = useExtraBuiltinInputs ? (t.isCompatibility ? 2 : 3) : 0;\n    const numUsedComponents = numScalarComponents + numExtraComponents;\n    const success = numUsedComponents <= t.device.limits.maxInterStageShaderComponents;\n\n    const numVec4 = Math.floor(numScalarComponents / 4);\n    const numTrailingScalars = numScalarComponents % 4;\n\n    const outputs = range(numVec4, i => `@location(${i}) vout${i}: vec4<f32>`);\n    const inputs = range(numVec4, i => `@location(${i}) fin${i}: vec4<f32>`);\n\n    if (numTrailingScalars > 0) {\n      const typeString = numTrailingScalars === 1 ? 'f32' : `vec${numTrailingScalars}<f32>`;\n      outputs.push(`@location(${numVec4}) vout${numVec4}: ${typeString}`);\n      inputs.push(`@location(${numVec4}) fin${numVec4}: ${typeString}`);\n    }\n\n    if (useExtraBuiltinInputs) {\n      inputs.push(\n        '@builtin(front_facing) front_facing_in: bool',\n        '@builtin(sample_mask) sample_mask_in: u32'\n      );\n      if (!t.isCompatibility) {\n        inputs.push('@builtin(sample_index) sample_index_in: u32');\n      }\n    }\n\n    const descriptor = t.getDescriptorWithStates(\n      t.getVertexStateWithOutputs(outputs),\n      t.getFragmentStateWithInputs(inputs, true)\n    );\n\n    t.doCreateRenderPipelineTest(isAsync, success, descriptor);\n  });\n"],"mappings":"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"}
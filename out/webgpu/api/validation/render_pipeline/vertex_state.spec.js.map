{"version":3,"file":"vertex_state.spec.js","names":["description","makeTestGroup","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kVertexFormats","kVertexFormatInfo","ValidationTest","VERTEX_SHADER_CODE_WITH_NO_INPUT","addTestAttributes","attributes","testAttribute","testAttributeAtStart","extraAttributeCount","extraAttributeSkippedLocations","currentLocation","extraAttribsAdded","includes","push","format","shaderLocation","offset","unshift","F","getDescriptor","buffers","vertexShaderCode","descriptor","layout","vertex","module","device","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","lastEmpty","params","vertexBuffers","i","arrayStride","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","testShaderLocation","vertexBufferIndexA","vertexBufferIndexB","testAttributeAtStartA","testAttributeAtStartB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocation","shader","beginSubcases","expand","p","shaderBaseType","shaderType","requiredBaseType","sint","uint","snorm","unorm","float","bytesPerComponent","componentCount","formatSize","Set","floor","formatInfo","stride","limit","formats"],"sources":["../../../../../src/webgpu/api/validation/render_pipeline/vertex_state.spec.ts"],"sourcesContent":["export const description = `\nThis test dedicatedly tests validation of GPUVertexState of createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kVertexFormats,\n  kVertexFormatInfo,\n} from '../../../capability_info.js';\nimport { ValidationTest } from '../validation_test.js';\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  @vertex fn main() -> @builtin(position) vec4<f32> {\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction addTestAttributes(\n  attributes: GPUVertexAttribute[],\n  {\n    testAttribute,\n    testAttributeAtStart = true,\n    extraAttributeCount = 0,\n    extraAttributeSkippedLocations = [],\n  }: {\n    testAttribute?: GPUVertexAttribute;\n    testAttributeAtStart?: boolean;\n    extraAttributeCount?: Number;\n    extraAttributeSkippedLocations?: Number[];\n  }\n) {\n  // Add a bunch of dummy attributes each with a different location such that none of the locations\n  // are in extraAttributeSkippedLocations\n  let currentLocation = 0;\n  let extraAttribsAdded = 0;\n  while (extraAttribsAdded !== extraAttributeCount) {\n    if (extraAttributeSkippedLocations.includes(currentLocation)) {\n      currentLocation++;\n      continue;\n    }\n\n    attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n    currentLocation++;\n    extraAttribsAdded++;\n  }\n\n  // Add the test attribute at the start or the end of the attributes.\n  if (testAttribute) {\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n  }\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        @fragment fn main() -> @location(0) vec4<f32> {\n          return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: vsModule,\n          entryPoint: 'main',\n          buffers,\n        },\n        fragment: {\n          module: fsModule,\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `@location(${input.location}) input${count} : ${input.type},\\n`;\n      body += `var i${count} : ${input.type} = input.input${count};\\n`;\n      count++;\n    }\n\n    return `\n      struct Inputs {\n        ${interfaces}\n      };\n      @vertex fn main(input : Inputs) -> @builtin(position) vec4<f32> {\n        ${body}\n        return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('count', [0, 1, kMaxVertexBuffers, kMaxVertexBuffers + 1])\n      .combine('lastEmpty', [false, true])\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        } as const);\n      }\n    }\n\n    const success = count <= kMaxVertexBuffers;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('attribCount', [0, 1, kMaxVertexAttributes, kMaxVertexAttributes + 1])\n      .combine('attribsPerBuffer', [0, 1, 4])\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === kMaxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded } as const);\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('arrayStride', [\n        0,\n        4,\n        256,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride,\n        kMaxVertexBufferArrayStride + 4,\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= kMaxVertexBufferArrayStride;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('arrayStride', [\n        0,\n        1,\n        2,\n        4,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride - 2,\n        kMaxVertexBufferArrayStride,\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: testShaderLocation },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexA', [0, 1, kMaxVertexBuffers - 1])\n      .combine('vertexBufferIndexB', [0, 1, kMaxVertexBuffers - 1])\n      .combine('testAttributeAtStartA', [false, true])\n      .combine('testAttributeAtStartB', [false, true])\n      .combine('shaderLocationA', [0, 1, 7, kMaxVertexAttributes - 1])\n      .combine('shaderLocationB', [0, 1, 7, kMaxVertexAttributes - 1])\n      .combine('extraAttributeCount', [0, 4])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexA,\n      vertexBufferIndexB,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationA,\n      shaderLocationB,\n      extraAttributeCount,\n    } = t.params;\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    addTestAttributes(attributesA, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationA },\n      testAttributeAtStart: testAttributeAtStartA,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [shaderLocationA, shaderLocationB],\n    });\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA so they end\n    // up in the same vertex buffer.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    addTestAttributes(attributesB, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationB },\n      testAttributeAtStart: testAttributeAtStartB,\n    });\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit, MAX_I32 (the WGSL spec requires a non-negative i32)`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('testLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes, 2 ** 31 - 1])\n  )\n  .fn(t => {\n    const { testLocation } = t.params;\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          } as const,\n        ],\n      },\n    ];\n\n    const success = testLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocation', [0, 1, 4, 7, kMaxVertexAttributes - 1])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n      testShaderLocation,\n    } = t.params;\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    const attributes: GPUVertexAttribute[] = [];\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    // Fill attributes with a bunch of attributes for other locations.\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    addTestAttributes(attributes, {\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n    t.testVertexState(false, vertexBuffers, shader);\n\n    // Add an attribute for the test location and try again.\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', shaderLocation: testShaderLocation, offset: 0 },\n      testAttributeAtStart,\n    });\n    t.testVertexState(true, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_type_matches_attribute_format')\n  .desc(\n    `\n    Test that the vertex shader declaration must have a type compatible with the vertex format.\n     - Test for all formats.\n     - Test for all combinations of u/i/f32 with and without vectors.`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('shaderBaseType', ['u32', 'i32', 'f32'])\n      .expand('shaderType', p => [\n        p.shaderBaseType,\n        `vec2<${p.shaderBaseType}>`,\n        `vec3<${p.shaderBaseType}>`,\n        `vec4<${p.shaderBaseType}>`,\n      ])\n  )\n  .fn(t => {\n    const { format, shaderBaseType, shaderType } = t.params;\n    const shader = t.generateTestVertexShader([\n      {\n        type: shaderType,\n        location: 0,\n      },\n    ]);\n\n    const requiredBaseType = {\n      sint: 'i32',\n      uint: 'u32',\n      snorm: 'f32',\n      unorm: 'f32',\n      float: 'f32',\n    }[kVertexFormatInfo[format].type];\n\n    const success = requiredBaseType === shaderBaseType;\n    t.testVertexState(\n      success,\n      [\n        {\n          arrayStride: 0,\n          attributes: [{ offset: 0, shaderLocation: 0, format }],\n        },\n      ],\n      shader\n    );\n  });\n\ng.test('vertex_attribute_offset_alignment')\n  .desc(\n    `\n    Test that vertex attribute offsets must be aligned to the format's component byte size.\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .combine('arrayStride', [256, kMaxVertexBufferArrayStride])\n      .expand('offset', p => {\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n\n        return new Set([\n          0,\n          Math.floor(formatSize / 2),\n          formatSize,\n          2,\n          4,\n          p.arrayStride - formatSize,\n          p.arrayStride - formatSize - Math.floor(formatSize / 2),\n          p.arrayStride - formatSize - 4,\n          p.arrayStride - formatSize - 2,\n        ]);\n      })\n      .beginSubcases()\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    const success = offset % Math.min(4, formatSize) === 0;\n\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_contained_in_stride')\n  .desc(\n    `\n    Test that vertex attribute [offset, offset + formatSize) must be contained in the arrayStride if arrayStride is not 0:\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('arrayStride', [\n        0,\n        256,\n        kMaxVertexBufferArrayStride - 4,\n        kMaxVertexBufferArrayStride,\n      ])\n      .expand('offset', function* (p) {\n        // Compute a bunch of test offsets to test.\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n        yield 0;\n        yield 4;\n\n        // arrayStride = 0 is a special case because for the offset validation it acts the same\n        // as arrayStride = kMaxVertexBufferArrayStride. We special case here so as to avoid adding\n        // negative offsets that would cause an IDL exception to be thrown instead of a validation\n        // error.\n        const stride = p.arrayStride !== 0 ? p.arrayStride : kMaxVertexBufferArrayStride;\n        yield stride - formatSize;\n        yield stride - formatSize + 4;\n\n        // Avoid adding duplicate cases when formatSize == 4 (it is already tested above)\n        if (formatSize !== 4) {\n          yield formatSize;\n          yield stride;\n        }\n      })\n      .combine('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1])\n      .combine('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    const limit = arrayStride === 0 ? kMaxVertexBufferArrayStride : arrayStride;\n\n    const success = offset + formatSize <= limit;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('many_attributes_overlapping')\n  .desc(`Test that it is valid to have many vertex attributes overlap`)\n  .fn(t => {\n    // Create many attributes, each of them intersects with at least 3 others.\n    const attributes = [];\n    const formats = ['float32x4', 'uint32x4', 'sint32x4'] as const;\n    for (let i = 0; i < kMaxVertexAttributes; i++) {\n      attributes.push({ format: formats[i % 3], offset: i * 4, shaderLocation: i } as const);\n    }\n\n    t.testVertexState(true, [{ arrayStride: 0, attributes }]);\n  });\n"],"mappings":"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"}
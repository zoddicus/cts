{"version":3,"file":"error_test.js","names":["Fixture","getGPU","assert","raceWithRejectOnTimeout","ErrorTest","_device","undefined","device","init","gpu","rec","adapter","requestAdapter","trackForCleanup","requestDevice","requiredLimits","maxTextureDimension2D","limits","maxTextureArrayLayers","generateError","filter","createTexture","format","usage","GPUTextureUsage","COPY_DST","size","createBuffer","queue","submit","isInstanceOfError","error","GPUOutOfMemoryError","GPUValidationError","GPUInternalError","expectUncapturedError","fn","immediateAsyncExpectation","TIMEOUT_IN_MS","promise","Promise","resolve","eventListener","event","debug","addEventListener","once"],"sources":["../../src/webgpu/error_test.ts"],"sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { getGPU } from '../common/util/navigator_gpu.js';\nimport { assert, raceWithRejectOnTimeout } from '../common/util/util.js';\n\n/**\n * A test class to help test error scopes and uncapturederror events.\n */\nexport class ErrorTest extends Fixture {\n  _device: GPUDevice | undefined = undefined;\n\n  get device(): GPUDevice {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  override async init(): Promise<void> {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null);\n\n    // We need to max out the adapter limits related to texture dimensions to more reliably cause an\n    // OOM error when asked for it, so set that on the device now.\n    const device = this.trackForCleanup(\n      await adapter.requestDevice({\n        requiredLimits: {\n          maxTextureDimension2D: adapter.limits.maxTextureDimension2D,\n          maxTextureArrayLayers: adapter.limits.maxTextureArrayLayers,\n        },\n      })\n    );\n    assert(device !== null);\n    this._device = device;\n  }\n\n  /**\n   * Generates an error of the given filter type. For now, the errors are generated by calling a\n   * known code-path to cause the error. This can be updated in the future should there be a more\n   * direct way to inject errors.\n   */\n  generateError(filter: GPUErrorFilter): void {\n    switch (filter) {\n      case 'out-of-memory':\n        this.trackForCleanup(\n          this.device.createTexture({\n            // One of the largest formats. With the base limits, the texture will be 256 GiB.\n            format: 'rgba32float',\n            usage: GPUTextureUsage.COPY_DST,\n            size: [\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureArrayLayers,\n            ],\n          })\n        );\n        break;\n      case 'validation':\n        // Generating a validation error by passing in an invalid usage when creating a buffer.\n        this.trackForCleanup(\n          this.device.createBuffer({\n            size: 1024,\n            usage: 0xffff, // Invalid GPUBufferUsage\n          })\n        );\n        break;\n    }\n    // MAINTENANCE_TODO: This is a workaround for Chromium not flushing. Remove when not needed.\n    this.device.queue.submit([]);\n  }\n\n  /**\n   * Checks whether the error is of the type expected given the filter.\n   */\n  isInstanceOfError(filter: GPUErrorFilter, error: GPUError | null): boolean {\n    switch (filter) {\n      case 'out-of-memory':\n        return error instanceof GPUOutOfMemoryError;\n      case 'validation':\n        return error instanceof GPUValidationError;\n      case 'internal':\n        return error instanceof GPUInternalError;\n    }\n  }\n\n  /**\n   * Expect an uncapturederror event to occur. Note: this MUST be awaited, because\n   * otherwise it could erroneously pass by capturing an error from later in the test.\n   */\n  async expectUncapturedError(fn: Function): Promise<GPUUncapturedErrorEvent> {\n    return this.immediateAsyncExpectation(() => {\n      // MAINTENANCE_TODO: Make arbitrary timeout value a test runner variable\n      const TIMEOUT_IN_MS = 1000;\n\n      const promise: Promise<GPUUncapturedErrorEvent> = new Promise(resolve => {\n        const eventListener = ((event: GPUUncapturedErrorEvent) => {\n          this.debug(`Got uncaptured error event with ${event.error}`);\n          resolve(event);\n        }) as EventListener;\n\n        this.device.addEventListener('uncapturederror', eventListener, { once: true });\n      });\n\n      fn();\n\n      return raceWithRejectOnTimeout(\n        promise,\n        TIMEOUT_IN_MS,\n        'Timeout occurred waiting for uncaptured error'\n      );\n    });\n  }\n}\n"],"mappings":"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"}
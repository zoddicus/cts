{"version":3,"file":"types.js","names":["keysOf","assert","align","kArrayLength","HostSharableTypes","kScalarTypeInfo","layout","alignment","size","supportsAtomics","arrayLength","innerLength","undefined","kScalarTypes","kVectorContainerTypeInfo","kVectorContainerTypes","kMatrixContainerTypeInfo","kMatrixContainerTypes","TexelFormats","format","_shaderType","generateTypes","storageClass","baseType","containerType","isAtomic","scalarInfo","scalarType","isHostSharable","toString","type","_kTypeInfo","elementBaseType","vectorType","matrixType","matrixInfo","arrayTypeInfo","arrayStride","elementLayout","sharableType","p","storageMode","supportedScalarTypes","info","isHostShared"],"sources":["../../../src/webgpu/shader/types.ts"],"sourcesContent":["import { keysOf } from '../../common/util/data_tables.js';\nimport { assert } from '../../common/util/util.js';\nimport { align } from '../util/math.js';\n\nconst kArrayLength = 3;\n\nexport type ContainerType = 'scalar' | 'vector' | 'matrix' | 'atomic' | 'array';\nexport type ScalarType = 'i32' | 'u32' | 'f32' | 'bool';\n\nexport const HostSharableTypes = ['i32', 'u32', 'f32'] as const;\n\n/** Info for each plain scalar type. */\nexport const kScalarTypeInfo = /* prettier-ignore */ {\n  'i32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'u32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'f32':    { layout: { alignment:  4, size:  4 }, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n  'bool':   { layout:                   undefined, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n} as const;\n/** List of all plain scalar types. */\nexport const kScalarTypes = keysOf(kScalarTypeInfo);\n\n/** Info for each vecN<> container type. */\nexport const kVectorContainerTypeInfo = /* prettier-ignore */ {\n  'vec2':   { layout: { alignment:  8, size:  8 }, arrayLength: 2 , innerLength: 0 },\n  'vec3':   { layout: { alignment: 16, size: 12 }, arrayLength: 3 , innerLength: 0 },\n  'vec4':   { layout: { alignment: 16, size: 16 }, arrayLength: 4 , innerLength: 0 },\n} as const;\n/** List of all vecN<> container types. */\nexport const kVectorContainerTypes = keysOf(kVectorContainerTypeInfo);\n\n/** Info for each matNxN<> container type. */\nexport const kMatrixContainerTypeInfo = /* prettier-ignore */ {\n  'mat2x2': { layout: { alignment:  8, size: 16 }, arrayLength: 2, innerLength: 2 },\n  'mat3x2': { layout: { alignment:  8, size: 24 }, arrayLength: 3, innerLength: 2 },\n  'mat4x2': { layout: { alignment:  8, size: 32 }, arrayLength: 4, innerLength: 2 },\n  'mat2x3': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 3 },\n  'mat3x3': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 3 },\n  'mat4x3': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 3 },\n  'mat2x4': { layout: { alignment: 16, size: 32 }, arrayLength: 2, innerLength: 4 },\n  'mat3x4': { layout: { alignment: 16, size: 48 }, arrayLength: 3, innerLength: 4 },\n  'mat4x4': { layout: { alignment: 16, size: 64 }, arrayLength: 4, innerLength: 4 },\n} as const;\n/** List of all matNxN<> container types. */\nexport const kMatrixContainerTypes = keysOf(kMatrixContainerTypeInfo);\n\nexport type StorageClass = 'storage' | 'uniform' | 'private' | 'function' | 'workgroup';\n\n/** List of texel formats and their shader representation */\nexport const TexelFormats = [\n  { format: 'rgba8unorm', _shaderType: 'f32' },\n  { format: 'rgba8snorm', _shaderType: 'f32' },\n  { format: 'rgba8uint', _shaderType: 'u32' },\n  { format: 'rgba8sint', _shaderType: 'i32' },\n  { format: 'rgba16uint', _shaderType: 'u32' },\n  { format: 'rgba16sint', _shaderType: 'i32' },\n  { format: 'rgba16float', _shaderType: 'f32' },\n  { format: 'r32uint', _shaderType: 'u32' },\n  { format: 'r32sint', _shaderType: 'i32' },\n  { format: 'r32float', _shaderType: 'f32' },\n  { format: 'rg32uint', _shaderType: 'u32' },\n  { format: 'rg32sint', _shaderType: 'i32' },\n  { format: 'rg32float', _shaderType: 'f32' },\n  { format: 'rgba32uint', _shaderType: 'i32' },\n  { format: 'rgba32sint', _shaderType: 'i32' },\n  { format: 'rgba32float', _shaderType: 'f32' },\n] as const;\n\n/**\n * Generate a bunch types (vec, mat, sized/unsized array) for testing.\n */\nexport function* generateTypes({\n  storageClass,\n  baseType,\n  containerType,\n  isAtomic = false,\n}: {\n  storageClass: StorageClass;\n  /** Base scalar type (i32/u32/f32/bool). */\n  baseType: ScalarType;\n  /** Container type (scalar/vector/matrix/array) */\n  containerType: ContainerType;\n  /** Whether to wrap the baseType in `atomic<>`. */\n  isAtomic?: boolean;\n}) {\n  const scalarInfo = kScalarTypeInfo[baseType];\n  if (isAtomic) {\n    assert(scalarInfo.supportsAtomics, 'type does not support atomics');\n  }\n  const scalarType = isAtomic ? `atomic<${baseType}>` : baseType;\n\n  // Storage and uniform require host-sharable types.\n  if (storageClass === 'storage' || storageClass === 'uniform') {\n    assert(isHostSharable(baseType), 'type ' + baseType.toString() + ' is not host sharable');\n  }\n\n  // Scalar types\n  if (containerType === 'scalar') {\n    yield {\n      type: `${scalarType}`,\n      _kTypeInfo: {\n        elementBaseType: `${scalarType}`,\n        ...scalarInfo,\n      },\n    };\n  }\n\n  // Vector types\n  if (containerType === 'vector') {\n    for (const vectorType of kVectorContainerTypes) {\n      yield {\n        type: `${vectorType}<${scalarType}>`,\n        _kTypeInfo: { elementBaseType: baseType, ...kVectorContainerTypeInfo[vectorType] },\n      };\n    }\n  }\n\n  if (containerType === 'matrix') {\n    // Matrices can only be f32.\n    if (baseType === 'f32') {\n      for (const matrixType of kMatrixContainerTypes) {\n        const matrixInfo = kMatrixContainerTypeInfo[matrixType];\n        yield {\n          type: `${matrixType}<${scalarType}>`,\n          _kTypeInfo: {\n            elementBaseType: `vec${matrixInfo.innerLength}<${scalarType}>`,\n            ...matrixInfo,\n          },\n        };\n      }\n    }\n  }\n\n  // Array types\n  if (containerType === 'array') {\n    const arrayTypeInfo = {\n      elementBaseType: `${baseType}`,\n      arrayLength: kArrayLength,\n      layout: scalarInfo.layout\n        ? {\n            alignment: scalarInfo.layout.alignment,\n            size:\n              storageClass === 'uniform'\n                ? // Uniform storage class must have array elements aligned to 16.\n                  kArrayLength *\n                  arrayStride({\n                    ...scalarInfo.layout,\n                    alignment: 16,\n                  })\n                : kArrayLength * arrayStride(scalarInfo.layout),\n          }\n        : undefined,\n    };\n\n    // Sized\n    if (storageClass === 'uniform') {\n      yield {\n        type: `array<vec4<${scalarType}>,${kArrayLength}>`,\n        _kTypeInfo: arrayTypeInfo,\n      };\n    } else {\n      yield { type: `array<${scalarType},${kArrayLength}>`, _kTypeInfo: arrayTypeInfo };\n    }\n    // Unsized\n    if (storageClass === 'storage') {\n      yield { type: `array<${scalarType}>`, _kTypeInfo: arrayTypeInfo };\n    }\n  }\n\n  function arrayStride(elementLayout: { size: number; alignment: number }) {\n    return align(elementLayout.size, elementLayout.alignment);\n  }\n\n  function isHostSharable(baseType: ScalarType) {\n    for (const sharableType of HostSharableTypes) {\n      if (sharableType === baseType) return true;\n    }\n    return false;\n  }\n}\n\n/** Atomic access requires scalar/array container type and storage/workgroup memory. */\nexport function supportsAtomics(p: {\n  storageClass: string;\n  storageMode: string | undefined;\n  access: string;\n  containerType: ContainerType;\n}) {\n  return (\n    ((p.storageClass === 'storage' && p.storageMode === 'read_write') ||\n      p.storageClass === 'workgroup') &&\n    (p.containerType === 'scalar' || p.containerType === 'array')\n  );\n}\n\n/** Generates an iterator of supported base types (i32/u32/f32/bool) */\nexport function* supportedScalarTypes(p: { isAtomic: boolean; storageClass: string }) {\n  for (const scalarType of kScalarTypes) {\n    const info = kScalarTypeInfo[scalarType];\n\n    // Test atomics only on supported scalar types.\n    if (p.isAtomic && !info.supportsAtomics) continue;\n\n    // Storage and uniform require host-sharable types.\n    const isHostShared = p.storageClass === 'storage' || p.storageClass === 'uniform';\n    if (isHostShared && info.layout === undefined) continue;\n\n    yield scalarType;\n  }\n}\n"],"mappings":"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"}
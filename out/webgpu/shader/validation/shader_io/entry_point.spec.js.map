{"version":3,"file":"entry_point.spec.js","names":["description","makeTestGroup","ShaderValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","vertex_attr","target_stage","fragment_attr","compute_attr","code","expectCompileResult"],"sources":["../../../../../src/webgpu/shader/validation/shader_io/entry_point.spec.ts"],"sourcesContent":["export const description = `Validation tests for attributes and entry point requirements`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('missing_attribute_on_param')\n  .desc(`Test that an entry point without an IO attribute on one of its parameters is rejected.`)\n  .params(u =>\n    u.combine('target_stage', ['', 'vertex', 'fragment', 'compute'] as const).beginSubcases()\n  )\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n    const code = `\n@vertex\nfn vert_main(@location(0) a : f32,\n             ${vertex_attr}  b : f32,\n@             location(2) c : f32) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main(@location(0)  a : f32,\n             ${fragment_attr} b : f32,\n@             location(2)  c : f32) {\n}\n\n@compute @workgroup_size(1)\nfn comp_main(@builtin(global_invocation_id) a : vec3<u32>,\n             ${compute_attr}                   b : vec3<u32>,\n             @builtin(local_invocation_id)  c : vec3<u32>) {\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_param_struct')\n  .desc(\n    `Test that an entry point struct parameter without an IO attribute on one of its members is rejected.`\n  )\n  .params(u =>\n    u.combine('target_stage', ['', 'vertex', 'fragment', 'compute'] as const).beginSubcases()\n  )\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n    const code = `\nstruct VertexInputs {\n  @location(0) a : f32,\n  ${vertex_attr}  b : f32,\n@  location(2) c : f32,\n};\nstruct FragmentInputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\nstruct ComputeInputs {\n  @builtin(global_invocation_id) a : vec3<u32>,\n  ${compute_attr}                   b : vec3<u32>,\n  @builtin(local_invocation_id)  c : vec3<u32>,\n};\n\n@vertex\nfn vert_main(inputs : VertexInputs) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main(inputs : FragmentInputs) {\n}\n\n@compute @workgroup_size(1)\nfn comp_main(inputs : ComputeInputs) {\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_return_type')\n  .desc(`Test that an entry point without an IO attribute on its return type is rejected.`)\n  .params(u => u.combine('target_stage', ['', 'vertex', 'fragment'] as const).beginSubcases())\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@builtin(position)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(0)';\n    const code = `\n@vertex\nfn vert_main() -> ${vertex_attr} vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main() -> ${fragment_attr} vec4<f32> {\n  return vec4<f32>();\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_return_type_struct')\n  .desc(\n    `Test that an entry point struct return type without an IO attribute on one of its members is rejected.`\n  )\n  .params(u => u.combine('target_stage', ['', 'vertex', 'fragment'] as const).beginSubcases())\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const code = `\nstruct VertexOutputs {\n  @location(0)       a : f32,\n  ${vertex_attr}        b : f32,\n  @builtin(position) c : vec4<f32>,\n};\nstruct FragmentOutputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\n\n@vertex\nfn vert_main() -> VertexOutputs {\n  return VertexOutputs();\n}\n\n@fragment\nfn frag_main() -> FragmentOutputs {\n  return FragmentOutputs();\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('no_entry_point_provided')\n  .desc(`Tests that a shader without an entry point is accepted`)\n  .fn(t => {\n    t.expectCompileResult(true, 'fn main() {}');\n  });\n"],"mappings":"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"}
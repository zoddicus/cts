{"version":3,"file":"builtins.spec.js","names":["description","makeTestGroup","ShaderValidationTest","generateShader","g","kBuiltins","name","stage","io","type","kTestTypes","test","desc","params","u","combineWithParams","combine","beginSubcases","fn","t","code","attribute","target_stage","target_io","use_struct","expectation","some","x","expectCompileResult","target_type","p1","first","p2","second","s1a","s1b","s2a","s2b","ra","rb","firstIsRet","secondIsRet","use"],"sources":["../../../../../src/webgpu/shader/validation/shader_io/builtins.spec.ts"],"sourcesContent":["export const description = `Validation tests for entry point built-in variables`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { generateShader } from './util.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// List of all built-in variables and their stage, in|out usage, and type.\n// Taken from table in Section 15:\n// https://www.w3.org/TR/2021/WD-WGSL-20211013/#builtin-variables\nexport const kBuiltins = [\n  { name: 'vertex_index', stage: 'vertex', io: 'in', type: 'u32' },\n  { name: 'instance_index', stage: 'vertex', io: 'in', type: 'u32' },\n  { name: 'position', stage: 'vertex', io: 'out', type: 'vec4<f32>' },\n  { name: 'position', stage: 'fragment', io: 'in', type: 'vec4<f32>' },\n  { name: 'front_facing', stage: 'fragment', io: 'in', type: 'bool' },\n  { name: 'frag_depth', stage: 'fragment', io: 'out', type: 'f32' },\n  { name: 'local_invocation_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'local_invocation_index', stage: 'compute', io: 'in', type: 'u32' },\n  { name: 'global_invocation_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'workgroup_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'num_workgroups', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'sample_index', stage: 'fragment', io: 'in', type: 'u32' },\n  { name: 'sample_mask', stage: 'fragment', io: 'in', type: 'u32' },\n  { name: 'sample_mask', stage: 'fragment', io: 'out', type: 'u32' },\n] as const;\n\n// List of types to test against.\nconst kTestTypes = [\n  'bool',\n  'u32',\n  'i32',\n  'f32',\n  'vec2<bool>',\n  'vec2<u32>',\n  'vec2<i32>',\n  'vec2<f32>',\n  'vec3<bool>',\n  'vec3<u32>',\n  'vec3<i32>',\n  'vec3<f32>',\n  'vec4<bool>',\n  'vec4<u32>',\n  'vec4<i32>',\n  'vec4<f32>',\n  'mat2x2<f32>',\n  'mat2x3<f32>',\n  'mat2x4<f32>',\n  'mat3x2<f32>',\n  'mat3x3<f32>',\n  'mat3x4<f32>',\n  'mat4x2<f32>',\n  'mat4x3<f32>',\n  'mat4x4<f32>',\n  'atomic<u32>',\n  'atomic<i32>',\n  'array<bool,4>',\n  'array<u32,4>',\n  'array<i32,4>',\n  'array<f32,4>',\n  'MyStruct',\n] as const;\n\ng.test('stage_inout')\n  .desc(\n    `Test that each @builtin attribute is validated against the required stage and in/out usage for that built-in variable.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .combine('target_stage', ['', 'vertex', 'fragment', 'compute'] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = generateShader({\n      attribute: `@builtin(${t.params.name})`,\n      type: t.params.type,\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to pass iff the built-in table contains an entry that matches.\n    const expectation = kBuiltins.some(\n      x =>\n        x.name === t.params.name &&\n        (x.stage === t.params.target_stage ||\n          (t.params.use_struct && t.params.target_stage === '')) &&\n        (x.io === t.params.target_io || t.params.target_stage === '') &&\n        x.type === t.params.type\n    );\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('type')\n  .desc(\n    `Test that each @builtin attribute is validated against the required type of that built-in variable.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .combine('target_type', kTestTypes)\n      .beginSubcases()\n  )\n  .fn(t => {\n    let code = '';\n\n    if (t.params.target_type === 'MyStruct') {\n      // Generate a struct that contains the correct built-in type.\n      code += 'struct MyStruct {\\n';\n      code += `  value : ${t.params.type}\\n`;\n      code += '};\\n\\n';\n    }\n\n    code += generateShader({\n      attribute: `@builtin(${t.params.name})`,\n      type: t.params.target_type,\n      stage: t.params.stage,\n      io: t.params.io,\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to pass iff the built-in table contains an entry that matches.\n    const expectation = kBuiltins.some(\n      x =>\n        x.name === t.params.name &&\n        x.stage === t.params.stage &&\n        x.io === t.params.io &&\n        x.type === t.params.target_type\n    );\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('nesting')\n  .desc(`Test validation of nested built-in variables`)\n  .params(u =>\n    u\n      .combine('target_stage', ['fragment', ''] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    // Generate a struct that contains a sample_mask builtin, nested inside another struct.\n    let code = `\n    struct Inner {\n      @builtin(sample_mask) value : u32\n    };\n    struct Outer {\n      inner : Inner\n    };`;\n\n    code += generateShader({\n      attribute: '',\n      type: 'Outer',\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: false,\n    });\n\n    // Expect to pass only if the struct is not used for entry point IO.\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('duplicates')\n  .desc(`Test that duplicated built-in variables are validated.`)\n  .params(u =>\n    u\n      // Place two @builtin(sample_mask) attributes onto the entry point function.\n      // We use `sample_mask` as it is valid as both an input and output for the same entry point.\n      // The function:\n      // - has two non-struct parameters (`p1` and `p2`)\n      // - has two struct parameters each with two members (`s1{a,b}` and `s2{a,b}`)\n      // - returns a struct with two members (`ra` and `rb`)\n      // By default, all of these variables will have unique @location() attributes.\n      .combine('first', ['p1', 's1a', 's2a', 'ra'] as const)\n      .combine('second', ['p2', 's1b', 's2b', 'rb'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const p1 =\n      t.params.first === 'p1' ? '@builtin(sample_mask)' : '@location(1) @interpolate(flat)';\n    const p2 =\n      t.params.second === 'p2' ? '@builtin(sample_mask)' : '@location(2) @interpolate(flat)';\n    const s1a =\n      t.params.first === 's1a' ? '@builtin(sample_mask)' : '@location(3) @interpolate(flat)';\n    const s1b =\n      t.params.second === 's1b' ? '@builtin(sample_mask)' : '@location(4) @interpolate(flat)';\n    const s2a =\n      t.params.first === 's2a' ? '@builtin(sample_mask)' : '@location(5) @interpolate(flat)';\n    const s2b =\n      t.params.second === 's2b' ? '@builtin(sample_mask)' : '@location(6) @interpolate(flat)';\n    const ra =\n      t.params.first === 'ra' ? '@builtin(sample_mask)' : '@location(1) @interpolate(flat)';\n    const rb =\n      t.params.second === 'rb' ? '@builtin(sample_mask)' : '@location(2) @interpolate(flat)';\n    const code = `\n    struct S1 {\n      ${s1a} a : u32,\n      ${s1b} b : u32,\n    };\n    struct S2 {\n      ${s2a} a : u32,\n      ${s2b} b : u32,\n    };\n    struct R {\n      ${ra} a : u32,\n      ${rb} b : u32,\n    };\n    @fragment\n    fn main(${p1} p1 : u32,\n            ${p2} p2 : u32,\n            s1 : S1,\n            s2 : S2,\n            ) -> R {\n      return R();\n    }\n    `;\n\n    // The test should fail if both @builtin(sample_mask) attributes are on the input parameters\n    // or structures, or it they are both on the output struct. Otherwise it should pass.\n    const firstIsRet = t.params.first === 'ra';\n    const secondIsRet = t.params.second === 'rb';\n    const expectation = firstIsRet !== secondIsRet;\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('missing_vertex_position')\n  .desc(`Test that vertex shaders are required to output @builtin(position).`)\n  .params(u =>\n    u\n      .combine('use_struct', [true, false] as const)\n      .combine('attribute', ['@builtin(position)', '@location(0)'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = `\n    struct S {\n      ${t.params.attribute} value : vec4<f32>\n    };\n\n    @vertex\n    fn main() -> ${t.params.use_struct ? 'S' : `${t.params.attribute} vec4<f32>`} {\n      return ${t.params.use_struct ? 'S' : 'vec4<f32>'}();\n    }\n    `;\n\n    // Expect to pass only when using @builtin(position).\n    t.expectCompileResult(t.params.attribute === '@builtin(position)', code);\n  });\n\ng.test('reuse_builtin_name')\n  .desc(`Test that a builtin name can be used in different contexts`)\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use', ['alias', 'struct', 'function', 'module-var', 'function-var'])\n  )\n  .fn(t => {\n    let code = '';\n    if (t.params.use === 'alias') {\n      code += `alias ${t.params.name} = i32;`;\n    } else if (t.params.use === `struct`) {\n      code += `struct ${t.params.name} { i: f32, }`;\n    } else if (t.params.use === `function`) {\n      code += `fn ${t.params.name}() {}`;\n    } else if (t.params.use === `module-var`) {\n      code += `const ${t.params.name} = 1;`;\n    } else if (t.params.use === `function-var`) {\n      code += `fn test() { let ${t.params.name} = 1; }`;\n    }\n    t.expectCompileResult(true, code);\n  });\n"],"mappings":"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"}
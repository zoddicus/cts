{"version":3,"file":"util.js","names":["generateShader","attribute","type","stage","io","use_struct","code","includes","param","retType","retVal"],"sources":["../../../../../src/webgpu/shader/validation/shader_io/util.ts"],"sourcesContent":["/**\n * Generate an entry point that uses an entry point IO variable.\n *\n * @param {Object} params\n * @param params.attribute The entry point IO attribute.\n * @param params.type The type to use for the entry point IO variable.\n * @param params.stage The shader stage.\n * @param params.io An \"in|out\" string specifying whether the entry point IO is an input or an output.\n * @param params.use_struct True to wrap the entry point IO in a struct.\n * @returns The generated shader code.\n */\nexport function generateShader({\n  attribute,\n  type,\n  stage,\n  io,\n  use_struct,\n}: {\n  attribute: string;\n  type: string;\n  stage: string;\n  io: string;\n  use_struct: boolean;\n}) {\n  let code = '';\n\n  if (use_struct) {\n    // Generate a struct that wraps the entry point IO variable.\n    code += 'struct S {\\n';\n    code += `  ${attribute} value : ${type},\\n`;\n    if (stage === 'vertex' && io === 'out' && !attribute.includes('builtin(position)')) {\n      // Add position builtin for vertex outputs.\n      code += `  @builtin(position) position : vec4<f32>,\\n`;\n    }\n    code += '};\\n\\n';\n  }\n\n  if (stage !== '') {\n    // Generate the entry point attributes.\n    code += `@${stage}`;\n    if (stage === 'compute') {\n      code += ' @workgroup_size(1)';\n    }\n  }\n\n  // Generate the entry point parameter and return type.\n  let param = '';\n  let retType = '';\n  let retVal = '';\n  if (io === 'in') {\n    if (use_struct) {\n      param = `in : S`;\n    } else {\n      param = `${attribute} value : ${type}`;\n    }\n\n    // Vertex shaders must always return `@builtin(position)`.\n    if (stage === 'vertex') {\n      retType = `-> @builtin(position) vec4<f32>`;\n      retVal = `return vec4<f32>();`;\n    }\n  } else if (io === 'out') {\n    if (use_struct) {\n      retType = '-> S';\n      retVal = `return S();`;\n    } else {\n      retType = `-> ${attribute} ${type}`;\n      retVal = `return ${type}();`;\n    }\n  }\n\n  code += `\n    fn main(${param}) ${retType} {\n      ${retVal}\n    }\n  `;\n\n  return code;\n}\n"],"mappings":";AAAA;AAAA,G,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,OAAO,SAASA,cAAc,CAAC,EAC7BC,SAAS;EACTC,IAAI;EACJC,KAAK;EACLC,EAAE;EACFC;;;;;;;AAOF,CAAC,EAAE;EACD,IAAIC,IAAI,GAAG,EAAE;;EAEb,IAAID,UAAU,EAAE;IACd;IACAC,IAAI,IAAI,cAAc;IACtBA,IAAI,IAAK,KAAIL,SAAU,YAAWC,IAAK,KAAI;IAC3C,IAAIC,KAAK,KAAK,QAAQ,IAAIC,EAAE,KAAK,KAAK,IAAI,CAACH,SAAS,CAACM,QAAQ,CAAC,mBAAmB,CAAC,EAAE;MAClF;MACAD,IAAI,IAAK,8CAA6C;IACxD;IACAA,IAAI,IAAI,QAAQ;EAClB;;EAEA,IAAIH,KAAK,KAAK,EAAE,EAAE;IAChB;IACAG,IAAI,IAAK,IAAGH,KAAM,EAAC;IACnB,IAAIA,KAAK,KAAK,SAAS,EAAE;MACvBG,IAAI,IAAI,qBAAqB;IAC/B;EACF;;EAEA;EACA,IAAIE,KAAK,GAAG,EAAE;EACd,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIN,EAAE,KAAK,IAAI,EAAE;IACf,IAAIC,UAAU,EAAE;MACdG,KAAK,GAAI,QAAO;IAClB,CAAC,MAAM;MACLA,KAAK,GAAI,GAAEP,SAAU,YAAWC,IAAK,EAAC;IACxC;;IAEA;IACA,IAAIC,KAAK,KAAK,QAAQ,EAAE;MACtBM,OAAO,GAAI,iCAAgC;MAC3CC,MAAM,GAAI,qBAAoB;IAChC;EACF,CAAC,MAAM,IAAIN,EAAE,KAAK,KAAK,EAAE;IACvB,IAAIC,UAAU,EAAE;MACdI,OAAO,GAAG,MAAM;MAChBC,MAAM,GAAI,aAAY;IACxB,CAAC,MAAM;MACLD,OAAO,GAAI,MAAKR,SAAU,IAAGC,IAAK,EAAC;MACnCQ,MAAM,GAAI,UAASR,IAAK,KAAI;IAC9B;EACF;;EAEAI,IAAI,IAAK;AACX,cAAcE,KAAM,KAAIC,OAAQ;AAChC,QAAQC,MAAO;AACf;AACA,GAAG;;EAED,OAAOJ,IAAI;AACb"}
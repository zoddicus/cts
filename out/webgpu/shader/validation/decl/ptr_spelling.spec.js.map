{"version":3,"file":"ptr_spelling.spec.js","names":["description","makeTestGroup","keysOf","kAccessModeInfo","kAddressSpaceInfo","ShaderValidationTest","pointerType","explicitSpaceExpander","accessModeExpander","getVarDeclShader","supportsWrite","kNonHandleAddressSpaces","filter","as","g","test","desc","specURL","params","u","combine","expand","fn","t","prog","ok","ptrStoreType","expectCompileResult","typePart","inferPtrType","storeType","i","spellAccessMode","addressSpace","accessMode","kStoreTypeNotInstantiable","ptr","privateAtomic","functionAtomic","uniformAtomic","workgroupRTArray","uniformRTArray","privateRTArray","functionRTArray","RTArrayNotLast","nestedRTArray","case"],"sources":["../../../../../src/webgpu/shader/validation/decl/ptr_spelling.spec.ts"],"sourcesContent":["export const description = `\nValidate spelling of pointer types.\n\nPointer types may appear.\n\nThey are parameterized by:\n- address space, always\n- store type\n- and access mode, as specified by the table in Address Spaces.\n   Concretely, only 'storage' address space allows it, and allows 'read', and 'read_write'.\n\nA pointer type can be spelled only if it corresponds to a variable that could be\ndeclared in the program.  So we need to test combinations against possible variable\ndeclarations.\n`;\n\n// This file tests spelling of the pointer type on let-declared pointers.\n//\n// Spelling of pointer-typed parameters on user-declared functions is tested by\n// webgpu:shader,validation,functions,restrictions:function_parameter_types:\"*\"\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { AddressSpace, kAccessModeInfo, kAddressSpaceInfo } from '../../types.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport {\n  pointerType,\n  explicitSpaceExpander,\n  accessModeExpander,\n  getVarDeclShader,\n  supportsWrite,\n  ShaderStage,\n} from './util.js';\n\n// Address spaces that can hold an i32 variable.\nconst kNonHandleAddressSpaces = keysOf(kAddressSpaceInfo).filter(\n  as => as !== 'handle'\n) as AddressSpace[];\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('let_ptr_explicit_type_matches_var')\n  .desc(\n    'Let-declared pointer with explicit type initialized from var with same address space and access mode'\n  )\n  .specURL('https://w3.org/TR#ref-ptr-types')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      // Vary the store type.\n      .combine('ptrStoreType', ['i32', 'u32'])\n  )\n  .fn(t => {\n    // Match the address space and access mode.\n    const prog = getVarDeclShader(t.params, `let p: ${pointerType(t.params)} = &x;`);\n    const ok = t.params.ptrStoreType === 'i32'; // The store type matches the variable's store type.\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('let_ptr_reads')\n  .desc('Validate reading via ptr when permitted by access mode')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      .combine('inferPtrType', [false, true])\n      .combine('ptrStoreType', ['i32'])\n  )\n  .fn(t => {\n    // Try reading through the pointer.\n    const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n    const prog = getVarDeclShader(t.params, `let p${typePart} = &x; let read = *p;`);\n    const ok = true; // We can always read.\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('let_ptr_writes')\n  .desc('Validate writing via ptr when permitted by access mode')\n  .specURL('https://w3.org/TR#ref-ptr-types')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      .combine('inferPtrType', [false, true])\n      .combine('ptrStoreType', ['i32'])\n  )\n  .fn(t => {\n    // Try writing through the pointer.\n    const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n    const prog = getVarDeclShader(t.params, `let p${typePart} = &x; *p = 42;`);\n    const ok = supportsWrite(t.params);\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('ptr_handle_space_invalid').fn(t => {\n  t.expectCompileResult(false, 'alias p = ptr<handle,u32>;');\n});\n\ng.test('ptr_bad_store_type')\n  .params(u => u.combine('storeType', ['undeclared', 'clamp', '1']))\n  .fn(t => {\n    t.expectCompileResult(false, `alias p = ptr<private,${t.params.storeType}>;`);\n  });\n\ng.test('ptr_address_space_never_uses_access_mode')\n  .params(u =>\n    u\n      .combine(\n        'addressSpace',\n        keysOf(kAddressSpaceInfo).filter(i => kAddressSpaceInfo[i].spellAccessMode === 'never')\n      )\n      .combine('accessMode', keysOf(kAccessModeInfo))\n  )\n  .fn(t => {\n    const prog = `alias pty = ptr<${t.params.addressSpace},u32,;${t.params.accessMode}>;`;\n    t.expectCompileResult(false, prog);\n  });\n\nconst kStoreTypeNotInstantiable: Record<string, string> = {\n  ptr: 'alias p = ptr<storage,ptr<private,i32>>;',\n  privateAtomic: 'alias p = ptr<private,atomic<u32>>;',\n  functionAtomic: 'alias p = ptr<function,atomic<u32>>;',\n  uniformAtomic: 'alias p = ptr<uniform,atomic<u32>>;',\n  workgroupRTArray: 'alias p = ptr<workgroup,array<i32>>;',\n  uniformRTArray: 'alias p = ptr<uniform,array<i32>>;',\n  privateRTArray: 'alias p = ptr<private,array<i32>>;',\n  functionRTArray: 'alias p = ptr<function,array<i32>>;',\n  RTArrayNotLast: 'struct S { a: array<i32>, b: i32 } alias p = ptr<storage,S>;',\n  nestedRTArray: 'struct S { a: array<i32>, b: i32 } struct { s: S } alias p = ptr<storage,T>;',\n} as const;\n\ng.test('ptr_not_instantiable')\n  .desc(\n    'Validate that ptr type must correspond to a variable that could be declared somewhere; test bad cases'\n  )\n  .params(u => u.combine('case', keysOf(kStoreTypeNotInstantiable)))\n  .fn(t => {\n    t.expectCompileResult(false, kStoreTypeNotInstantiable[t.params.case]);\n  });\n"],"mappings":"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"}
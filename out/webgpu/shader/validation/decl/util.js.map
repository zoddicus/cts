{"version":3,"file":"util.js","names":["kAccessModeInfo","kAddressSpaceInfo","kShaderStages","declareEntryPoint","arg","name","undefined","stage","body","declareVarX","addressSpace","accessMode","parts","binding","push","template_parts","length","join","varDeclCompatibleAddressSpace","p","info","spell","explicitSpace","explicitSpaceExpander","accessModeExpander","explicitAccess","spellAccessMode","accessModes","getVarDeclShader","additionalBody","decl","scope","pointerType","space","modePart","ptrStoreType","effectiveAccessMode","supportsRead","mode","includes","read","supportsWrite","write"],"sources":["../../../../../src/webgpu/shader/validation/decl/util.ts"],"sourcesContent":["import {\n  AccessMode,\n  AddressSpace,\n  AddressSpaceInfo,\n  kAccessModeInfo,\n  kAddressSpaceInfo,\n} from '../../types.js';\n\n/** An enumerator of shader stages */\nexport type ShaderStage = 'vertex' | 'fragment' | 'compute';\n\n/** The list of all shader stages */\nexport const kShaderStages = ['vertex', 'fragment', 'compute'] as const;\n\n/**\n * declareEntrypoint emits the WGSL to declare an entry point with the name, stage and body.\n * The generated function will have an appropriate return type and return statement, so that @p body\n * does not have to change between stage.\n * @param arg - arg specifies the\n * optional entry point function name, the shader stage, and the body of the\n * function, excluding any automatically generated return statements.\n * @returns the WGSL string for the entry point\n */\nexport function declareEntryPoint(arg: {\n  name?: string;\n  stage: ShaderStage;\n  body: string;\n}): string {\n  if (arg.name === undefined) {\n    arg.name = 'main';\n  }\n  switch (arg.stage) {\n    case 'vertex':\n      return `@vertex\nfn ${arg.name}() -> @builtin(position) vec4f {\n  ${arg.body}\n  return vec4f();\n}`;\n    case 'fragment':\n      return `@fragment\nfn ${arg.name}() {\n  ${arg.body}\n}`;\n    case 'compute':\n      return `@compute @workgroup_size(1)\nfn ${arg.name}() {\n  ${arg.body}\n}`;\n  }\n}\n\n/**\n * @returns a WGSL var declaration with given parameters for variable 'x' and\n * store type i32.\n */\nexport function declareVarX(addressSpace: AddressSpace | '', accessMode: AccessMode | ''): string {\n  const parts: string[] = [];\n  if (addressSpace && kAddressSpaceInfo[addressSpace].binding) parts.push('@group(0) @binding(0) ');\n  parts.push('var');\n\n  const template_parts: string[] = [];\n  if (addressSpace) template_parts.push(addressSpace);\n  if (accessMode) template_parts.push(accessMode);\n  if (template_parts.length > 0) parts.push(`<${template_parts.join(',')}>`);\n\n  parts.push(' x: i32;');\n  return parts.join('');\n}\n\n/**\n * @returns true if an explicit address space is requested on a variable\n * declaration whenever the address space requires one:\n *\n *    must implies requested\n *\n * Rewrite as:\n *\n *    !must or requested\n */\nexport function varDeclCompatibleAddressSpace(p: {\n  addressSpace: AddressSpace;\n  explicitSpace: boolean;\n}): boolean {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  return !(info.spell === 'must') || p.explicitSpace;\n}\n\n/**\n * @returns a list of booleans indicating valid cases of specifying the address\n * space.\n */\nexport function explicitSpaceExpander(p: { addressSpace: AddressSpace }): readonly boolean[] {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  return info.spell === 'must' ? [true] : [true, false];\n}\n\n/**\n * @returns a list of usable access modes under given experiment conditions, or undefined\n * if none are allowed.\n */\nexport function accessModeExpander(p: {\n  addressSpace: AddressSpace;\n  explicitAccess: boolean; // Whether the access mode will be emitted.\n}): readonly (AccessMode | '')[] {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  return p.explicitAccess && info.spellAccessMode !== 'never' ? info.accessModes : [''];\n}\n\n/**\n * @returns a WGSL program with a single variable declaration, with the\n * given parameterization\n */\nexport function getVarDeclShader(\n  p: {\n    addressSpace: AddressSpace; // Address space for the variable.\n    explicitSpace: boolean; // Should the address space be explicitly spelled?\n    accessMode: AccessMode | ''; // What access mode to use.\n    explicitAccess: boolean; // Should the access mode be explicitly spelled?\n    stage: ShaderStage; // What shader stage to use.\n  },\n  additionalBody?: string\n): string {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const decl = declareVarX(\n    p.explicitSpace ? p.addressSpace : '',\n    p.explicitAccess ? p.accessMode : ''\n  );\n\n  additionalBody = additionalBody ?? '';\n\n  switch (info.scope) {\n    case 'module':\n      return decl + '\\n' + declareEntryPoint({ stage: p.stage, body: additionalBody });\n\n    case 'function':\n      return declareEntryPoint({ stage: p.stage, body: decl + '\\n' + additionalBody });\n  }\n}\n\n/**\n * @returns the WGSL spelling of a pointer type corresponding to a variable\n * declared with the given parameters.\n */\nexport function pointerType(p: {\n  addressSpace: AddressSpace; // Address space to use if p.explicitSpace\n  explicitSpace: boolean; // If false, use 'function' address space\n  accessMode: AccessMode | ''; // The access mode to use, if any\n  ptrStoreType: string; // The store type.\n}): string {\n  const space = p.explicitSpace ? p.addressSpace : 'function';\n  const modePart = p.accessMode ? ',' + p.accessMode : '';\n  return `ptr<${space},${p.ptrStoreType}${modePart}>`;\n}\n\n/** @returns the effective access mode for the given experiment.  */\nexport function effectiveAccessMode(\n  info: AddressSpaceInfo,\n  accessMode: AccessMode | ''\n): AccessMode {\n  return accessMode || info.accessModes[0]; // default is first.\n}\n\n/** @returns whether the setup allows reads */\nexport function supportsRead(p: {\n  addressSpace: AddressSpace;\n  accessMode: AccessMode | '';\n}): boolean {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const mode = effectiveAccessMode(info, p.accessMode);\n  return info.accessModes.includes(mode) && kAccessModeInfo[mode].read;\n}\n\n/** @returns whether the setup allows writes */\nexport function supportsWrite(p: {\n  addressSpace: AddressSpace;\n  accessMode: AccessMode | '';\n}): boolean {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const mode = effectiveAccessMode(info, p.accessMode);\n  return info.accessModes.includes(mode) && kAccessModeInfo[mode].write;\n}\n"],"mappings":"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"}
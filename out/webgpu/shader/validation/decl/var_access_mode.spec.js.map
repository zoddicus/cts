{"version":3,"file":"var_access_mode.spec.js","names":["description","makeTestGroup","keysOf","kAccessModeInfo","kAddressSpaceInfo","ShaderValidationTest","declareEntryPoint","kNonHandleAddressSpaces","filter","as","g","declareVarX","addressSpace","accessMode","parts","binding","push","template_parts","length","join","getShader","p","additionalBody","as_info","decl","explicitSpace","undefined","explicitMode","scope","stage","body","infoExpander","explicitSpaceExpander","info","spell","accessModeExpander","spellAccessMode","accessModes","compatibleAS","effectiveMode","supportsRead","mode","includes","read","supportsWrite","write","test","desc","specURL","params","u","combine","expand","t","fn","prog","ok","expectCompileResult"],"sources":["../../../../../src/webgpu/shader/validation/decl/var_access_mode.spec.ts"],"sourcesContent":["export const description = `\n7.3 var Declarations\n\nThe access mode always has a default value, and except for variables in the\nstorage address space, must not be specified in the WGSL source. See ยง13.3 Address Spaces.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport {\n  AccessMode,\n  AddressSpace,\n  AddressSpaceInfo,\n  kAccessModeInfo,\n  kAddressSpaceInfo,\n} from '../../types.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { declareEntryPoint, ShaderStage } from './util.js';\n\n// Test address spaces that we can hold an i32 variable.\nconst kNonHandleAddressSpaces = keysOf(kAddressSpaceInfo).filter(\n  as => as !== 'handle'\n) as AddressSpace[];\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n/**\n * @returns a WGSL var declaration with given parameters for variable 'x' and\n * store type i32.\n */\nfunction declareVarX(\n  addressSpace: AddressSpace | undefined,\n  accessMode: AccessMode | undefined\n): string {\n  const parts: string[] = [];\n  if (addressSpace && kAddressSpaceInfo[addressSpace].binding) parts.push('@group(0) @binding(0) ');\n  parts.push('var');\n\n  const template_parts: string[] = [];\n  if (addressSpace) template_parts.push(addressSpace as string);\n  if (accessMode) template_parts.push(accessMode);\n  if (template_parts.length > 0) parts.push(`<${template_parts.join(',')}>`);\n\n  parts.push(' x: i32;');\n  return parts.join('');\n}\n\n/**\n * @returns a WGSL program for the test parameterization.\n */\nfunction getShader(\n  p: {\n    addressSpace: AddressSpace; // What address space for the variable.\n    explicitSpace: boolean; // Should the address space be explicitly spelled?\n    accessMode?: AccessMode; // What access mode to use.\n    explicitMode: boolean; // Should the access mode be explicitly spelled?\n    stage: ShaderStage; // What shader stage to use.\n  },\n  additionalBody?: string\n): string {\n  const as_info = kAddressSpaceInfo[p.addressSpace];\n  const decl = declareVarX(\n    p.explicitSpace ? p.addressSpace : undefined,\n    p.explicitMode ? p.accessMode : undefined\n  );\n\n  additionalBody = additionalBody ?? '';\n\n  switch (as_info.scope) {\n    case 'module':\n      return decl + '\\n' + declareEntryPoint({ stage: p.stage, body: additionalBody });\n\n    case 'function':\n      return declareEntryPoint({ stage: p.stage, body: decl + '\\n' + additionalBody });\n  }\n}\n\n/** @returns the list of address space info objects for the given address space.  */\nfunction infoExpander(p: { addressSpace: AddressSpace }): readonly AddressSpaceInfo[] {\n  return [kAddressSpaceInfo[p.addressSpace]];\n}\n\n/**\n * @returns a list of booleans indicating valid cases of specifying the address\n * space.\n */\nfunction explicitSpaceExpander(p: { info: AddressSpaceInfo }): readonly boolean[] {\n  return p.info.spell === 'must' ? [true] : [true, false];\n}\n/** @returns a list of usable access modes under given experiment conditions.  */\nfunction accessModeExpander(p: {\n  explicitMode: boolean; // Whether the access mode will be emitted.\n  info: AddressSpaceInfo;\n}): readonly AccessMode[] {\n  return p.explicitMode && p.info.spellAccessMode !== 'never' ? p.info.accessModes : [];\n}\n\n/**\n * @returns false if the test does not spell the address space in the var\n * declaration but the address space requires it.\n * Use this filter when trying to test something other than access mode\n * functionality.\n */\nfunction compatibleAS(p: { info: AddressSpaceInfo; explicitSpace: boolean }): boolean {\n  return !p.explicitSpace && p.info.spell === 'must';\n}\n\n/** @returns the effective access mode for the given experiment.  */\nfunction effectiveMode(p: { info: AddressSpaceInfo; accessMode: AccessMode }): AccessMode {\n  return p.accessMode || p.info.accessModes[0]; // default is first.\n}\n/** @returns whether the setup allows reads */\nfunction supportsRead(p: { info: AddressSpaceInfo; accessMode: AccessMode }): boolean {\n  const mode = effectiveMode(p);\n  return p.info.accessModes.includes(mode) && kAccessModeInfo[mode].read;\n}\n/** @returns whether the setup allows writes */\nfunction supportsWrite(p: { info: AddressSpaceInfo; accessMode: AccessMode }): boolean {\n  const mode = effectiveMode(p);\n  return p.info.accessModes.includes(mode) && kAccessModeInfo[mode].write;\n}\n\ng.test('explicit_access_mode')\n  .desc('Validate uses of an explicit access mode on a var declaration')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#var-decls')\n  .params(\n    u =>\n      u\n        .combine('addressSpace', kNonHandleAddressSpaces)\n        .expand('info', infoExpander)\n        .combine('explicitSpace', [true, false])\n        .filter(t => compatibleAS(t))\n        .combine('explicitMode', [true])\n        .combine('accessMode', keysOf(kAccessModeInfo))\n        .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n  )\n  .fn(t => {\n    const prog = getShader(t.params);\n\n    const ok =\n      // The address space must be explicitly specified.\n      t.params.explicitSpace &&\n      // The address space must allow an access mode to be spelled, and the\n      // access mode must be in the list of modes for the address space.\n      t.params.info.spellAccessMode !== 'never' &&\n      (t.params.info.accessModes as readonly string[]).includes(t.params.accessMode);\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('implicit_access_mode')\n  .desc('Validate an implicit access mode on a var declaration')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#var-decls')\n  .params(\n    u =>\n      u\n        .combine('addressSpace', kNonHandleAddressSpaces)\n        .expand('info', infoExpander)\n        .expand('explicitSpace', explicitSpaceExpander)\n        .combine('explicitMode', [false])\n        .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n  )\n  .fn(t => {\n    const prog = getShader(t.params);\n\n    // 7.3 var Declarations\n    // \"The access mode always has a default value,..\"\n    const ok = true;\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('read_access')\n  .desc('A variable can be read from when the access mode permits')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#var-decls')\n  .params(\n    u =>\n      u\n        .combine('addressSpace', kNonHandleAddressSpaces)\n        .expand('info', infoExpander)\n        .expand('explicitSpace', explicitSpaceExpander)\n        .combine('explicitMode', [false, true])\n        .expand('accessMode', accessModeExpander)\n        .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n  )\n  .fn(t => {\n    const prog = getShader(t.params, 'let copy = x;');\n    const ok = supportsRead(t.params);\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('write_access')\n  .desc('A variable can be written to when the access mode permits')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#var-decls')\n  .params(\n    u =>\n      u\n        .combine('addressSpace', kNonHandleAddressSpaces)\n        .expand('info', infoExpander)\n        .expand('explicitSpace', explicitSpaceExpander)\n        .combine('explicitMode', [false, true])\n        .expand('accessMode', accessModeExpander)\n        .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n  )\n  .fn(t => {\n    const prog = getShader(t.params, 'x = 0;');\n    const ok = supportsWrite(t.params);\n    t.expectCompileResult(ok, prog);\n  });\n"],"mappings":";AAAA;AAAA,GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SAASC,MAAM,QAAQ,wCAAwC;AAC/D;;;;AAIEC,eAAe;AACfC,iBAAiB;AACZ,gBAAgB;AACvB,SAASC,oBAAoB,QAAQ,8BAA8B;;AAEnE,SAASC,iBAAiB,QAAqB,WAAW;;AAE1D;AACA,MAAMC,uBAAuB,GAAGL,MAAM,CAACE,iBAAiB,CAAC,CAACI,MAAM;AAC9D,CAAAC,EAAE,KAAIA,EAAE,KAAK,QAAQ,CACJ;;;AAEnB,OAAO,MAAMC,CAAC,GAAGT,aAAa,CAACI,oBAAoB,CAAC;;AAEpD;AACA;AACA;AACA;AACA,SAASM,WAAW;AAClBC,YAAsC;AACtCC,UAAkC;AAC1B;EACR,MAAMC,KAAe,GAAG,EAAE;EAC1B,IAAIF,YAAY,IAAIR,iBAAiB,CAACQ,YAAY,CAAC,CAACG,OAAO,EAAED,KAAK,CAACE,IAAI,CAAC,wBAAwB,CAAC;EACjGF,KAAK,CAACE,IAAI,CAAC,KAAK,CAAC;;EAEjB,MAAMC,cAAwB,GAAG,EAAE;EACnC,IAAIL,YAAY,EAAEK,cAAc,CAACD,IAAI,CAACJ,YAAY,CAAW;EAC7D,IAAIC,UAAU,EAAEI,cAAc,CAACD,IAAI,CAACH,UAAU,CAAC;EAC/C,IAAII,cAAc,CAACC,MAAM,GAAG,CAAC,EAAEJ,KAAK,CAACE,IAAI,CAAE,IAAGC,cAAc,CAACE,IAAI,CAAC,GAAG,CAAE,GAAE,CAAC;;EAE1EL,KAAK,CAACE,IAAI,CAAC,UAAU,CAAC;EACtB,OAAOF,KAAK,CAACK,IAAI,CAAC,EAAE,CAAC;AACvB;;AAEA;AACA;AACA;AACA,SAASC,SAAS;AAChBC,CAMC;;;;;;;AACDC,cAAuB;AACf;EACR,MAAMC,OAAO,GAAGnB,iBAAiB,CAACiB,CAAC,CAACT,YAAY,CAAC;EACjD,MAAMY,IAAI,GAAGb,WAAW;EACtBU,CAAC,CAACI,aAAa,GAAGJ,CAAC,CAACT,YAAY,GAAGc,SAAS;EAC5CL,CAAC,CAACM,YAAY,GAAGN,CAAC,CAACR,UAAU,GAAGa,SAAS,CAC1C;;;EAEDJ,cAAc,GAAGA,cAAc,IAAI,EAAE;;EAErC,QAAQC,OAAO,CAACK,KAAK;IACnB,KAAK,QAAQ;MACX,OAAOJ,IAAI,GAAG,IAAI,GAAGlB,iBAAiB,CAAC,EAAEuB,KAAK,EAAER,CAAC,CAACQ,KAAK,EAAEC,IAAI,EAAER,cAAc,CAAC,CAAC,CAAC;;IAElF,KAAK,UAAU;MACb,OAAOhB,iBAAiB,CAAC,EAAEuB,KAAK,EAAER,CAAC,CAACQ,KAAK,EAAEC,IAAI,EAAEN,IAAI,GAAG,IAAI,GAAGF,cAAc,CAAC,CAAC,CAAC,CAAC;;AAEvF;;AAEA;AACA,SAASS,YAAY,CAACV,CAAiC,EAA+B;EACpF,OAAO,CAACjB,iBAAiB,CAACiB,CAAC,CAACT,YAAY,CAAC,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA,SAASoB,qBAAqB,CAACX,CAA6B,EAAsB;EAChF,OAAOA,CAAC,CAACY,IAAI,CAACC,KAAK,KAAK,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;AACzD;AACA;AACA,SAASC,kBAAkB,CAACd,CAG3B;;;AAAyB;EACxB,OAAOA,CAAC,CAACM,YAAY,IAAIN,CAAC,CAACY,IAAI,CAACG,eAAe,KAAK,OAAO,GAAGf,CAAC,CAACY,IAAI,CAACI,WAAW,GAAG,EAAE;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAY,CAACjB,CAAqD,EAAW;EACpF,OAAO,CAACA,CAAC,CAACI,aAAa,IAAIJ,CAAC,CAACY,IAAI,CAACC,KAAK,KAAK,MAAM;AACpD;;AAEA;AACA,SAASK,aAAa,CAAClB,CAAqD,EAAc;EACxF,OAAOA,CAAC,CAACR,UAAU,IAAIQ,CAAC,CAACY,IAAI,CAACI,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD;AACA;AACA,SAASG,YAAY,CAACnB,CAAqD,EAAW;EACpF,MAAMoB,IAAI,GAAGF,aAAa,CAAClB,CAAC,CAAC;EAC7B,OAAOA,CAAC,CAACY,IAAI,CAACI,WAAW,CAACK,QAAQ,CAACD,IAAI,CAAC,IAAItC,eAAe,CAACsC,IAAI,CAAC,CAACE,IAAI;AACxE;AACA;AACA,SAASC,aAAa,CAACvB,CAAqD,EAAW;EACrF,MAAMoB,IAAI,GAAGF,aAAa,CAAClB,CAAC,CAAC;EAC7B,OAAOA,CAAC,CAACY,IAAI,CAACI,WAAW,CAACK,QAAQ,CAACD,IAAI,CAAC,IAAItC,eAAe,CAACsC,IAAI,CAAC,CAACI,KAAK;AACzE;;AAEAnC,CAAC,CAACoC,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI,CAAC,+DAA+D,CAAC;AACrEC,OAAO,CAAC,iDAAiD,CAAC;AAC1DC,MAAM;AACL,CAAAC,CAAC;AACCA,CAAC;AACEC,OAAO,CAAC,cAAc,EAAE5C,uBAAuB,CAAC;AAChD6C,MAAM,CAAC,MAAM,EAAErB,YAAY,CAAC;AAC5BoB,OAAO,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvC3C,MAAM,CAAC,CAAA6C,CAAC,KAAIf,YAAY,CAACe,CAAC,CAAC,CAAC;AAC5BF,OAAO,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,CAAC;AAC/BA,OAAO,CAAC,YAAY,EAAEjD,MAAM,CAACC,eAAe,CAAC,CAAC;AAC9CgD,OAAO,CAAC,OAAO,EAAE,CAAC,SAAS,CAAgB,CAAC,CAAC;AAAA,CACnD;AACAG,EAAE,CAAC,CAAAD,CAAC,KAAI;EACP,MAAME,IAAI,GAAGnC,SAAS,CAACiC,CAAC,CAACJ,MAAM,CAAC;;EAEhC,MAAMO,EAAE;EACN;EACAH,CAAC,CAACJ,MAAM,CAACxB,aAAa;EACtB;EACA;EACA4B,CAAC,CAACJ,MAAM,CAAChB,IAAI,CAACG,eAAe,KAAK,OAAO;EACxCiB,CAAC,CAACJ,MAAM,CAAChB,IAAI,CAACI,WAAW,CAAuBK,QAAQ,CAACW,CAAC,CAACJ,MAAM,CAACpC,UAAU,CAAC;;EAEhFwC,CAAC,CAACI,mBAAmB,CAACD,EAAE,EAAED,IAAI,CAAC;AACjC,CAAC,CAAC;;AAEJ7C,CAAC,CAACoC,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI,CAAC,uDAAuD,CAAC;AAC7DC,OAAO,CAAC,iDAAiD,CAAC;AAC1DC,MAAM;AACL,CAAAC,CAAC;AACCA,CAAC;AACEC,OAAO,CAAC,cAAc,EAAE5C,uBAAuB,CAAC;AAChD6C,MAAM,CAAC,MAAM,EAAErB,YAAY,CAAC;AAC5BqB,MAAM,CAAC,eAAe,EAAEpB,qBAAqB,CAAC;AAC9CmB,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,CAAC,CAAC;AAChCA,OAAO,CAAC,OAAO,EAAE,CAAC,SAAS,CAAgB,CAAC,CAAC;AAAA,CACnD;AACAG,EAAE,CAAC,CAAAD,CAAC,KAAI;EACP,MAAME,IAAI,GAAGnC,SAAS,CAACiC,CAAC,CAACJ,MAAM,CAAC;;EAEhC;EACA;EACA,MAAMO,EAAE,GAAG,IAAI;;EAEfH,CAAC,CAACI,mBAAmB,CAACD,EAAE,EAAED,IAAI,CAAC;AACjC,CAAC,CAAC;;AAEJ7C,CAAC,CAACoC,IAAI,CAAC,aAAa,CAAC;AAClBC,IAAI,CAAC,0DAA0D,CAAC;AAChEC,OAAO,CAAC,iDAAiD,CAAC;AAC1DC,MAAM;AACL,CAAAC,CAAC;AACCA,CAAC;AACEC,OAAO,CAAC,cAAc,EAAE5C,uBAAuB,CAAC;AAChD6C,MAAM,CAAC,MAAM,EAAErB,YAAY,CAAC;AAC5BqB,MAAM,CAAC,eAAe,EAAEpB,qBAAqB,CAAC;AAC9CmB,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACtCC,MAAM,CAAC,YAAY,EAAEjB,kBAAkB,CAAC;AACxCgB,OAAO,CAAC,OAAO,EAAE,CAAC,SAAS,CAAgB,CAAC,CAAC;AAAA,CACnD;AACAG,EAAE,CAAC,CAAAD,CAAC,KAAI;EACP,MAAME,IAAI,GAAGnC,SAAS,CAACiC,CAAC,CAACJ,MAAM,EAAE,eAAe,CAAC;EACjD,MAAMO,EAAE,GAAGhB,YAAY,CAACa,CAAC,CAACJ,MAAM,CAAC;EACjCI,CAAC,CAACI,mBAAmB,CAACD,EAAE,EAAED,IAAI,CAAC;AACjC,CAAC,CAAC;;AAEJ7C,CAAC,CAACoC,IAAI,CAAC,cAAc,CAAC;AACnBC,IAAI,CAAC,2DAA2D,CAAC;AACjEC,OAAO,CAAC,iDAAiD,CAAC;AAC1DC,MAAM;AACL,CAAAC,CAAC;AACCA,CAAC;AACEC,OAAO,CAAC,cAAc,EAAE5C,uBAAuB,CAAC;AAChD6C,MAAM,CAAC,MAAM,EAAErB,YAAY,CAAC;AAC5BqB,MAAM,CAAC,eAAe,EAAEpB,qBAAqB,CAAC;AAC9CmB,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACtCC,MAAM,CAAC,YAAY,EAAEjB,kBAAkB,CAAC;AACxCgB,OAAO,CAAC,OAAO,EAAE,CAAC,SAAS,CAAgB,CAAC,CAAC;AAAA,CACnD;AACAG,EAAE,CAAC,CAAAD,CAAC,KAAI;EACP,MAAME,IAAI,GAAGnC,SAAS,CAACiC,CAAC,CAACJ,MAAM,EAAE,QAAQ,CAAC;EAC1C,MAAMO,EAAE,GAAGZ,aAAa,CAACS,CAAC,CAACJ,MAAM,CAAC;EAClCI,CAAC,CAACI,mBAAmB,CAACD,EAAE,EAAED,IAAI,CAAC;AACjC,CAAC,CAAC"}
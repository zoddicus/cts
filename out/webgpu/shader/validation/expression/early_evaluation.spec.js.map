{"version":3,"file":"early_evaluation.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kCompositeCases","const_scalar","code","stage","valid","const_vector","const_let_vector","const_let_vector_comp","const_let_array_comp","const_let_struct_comp","const_let_matrix","const_let_matrix_vec","const_let_matrix_comp","override_scalar","override_vector","override_let_vector","override_let_vector_comp","override_let_array_comp","override_let_struct_comp","override_let_matrix","override_let_matrix_vec","override_let_matrix_comp","test","desc","params","u","combine","fn","t","case","wgsl","expectCompileResult","constants","expectPipelineResult","expectedResult","reference"],"sources":["../../../../../src/webgpu/shader/validation/expression/early_evaluation.spec.ts"],"sourcesContent":["export const description = `\nTests specific validation for early evaluation expressions\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ninterface CompositeCase {\n  code: string;\n  stage: 'constant' | 'override';\n  valid: boolean;\n}\n\nconst kCompositeCases: Record<string, CompositeCase> = {\n  const_scalar: {\n    code: `let tmp = const_1e30 * const_1e30;`,\n    stage: 'constant',\n    valid: false,\n  },\n  const_vector: {\n    code: `let tmp = vec4(const_1e30) * vec4(const_1e30);`,\n    stage: 'constant',\n    valid: false,\n  },\n  const_let_vector: {\n    code: `let tmp = vec4(const_1e30) * vec4(vec3(const_1e30), let_1e30);`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_vector_comp: {\n    code: `let tmp = vec2(const_1e30)[0] * vec2(const_1e30, let_1e30)[0];`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_array_comp: {\n    code: `let tmp = array(const_1e30, const_1e30)[0] * array(const_1e30, let_1e30)[0];`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_struct_comp: {\n    code: `let tmp = S(const_1e30, const_1e30).x * S(const_1e30, let_1e30).x;`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_matrix: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30)) * mat2x2(vec2(const_1e30), vec2(let_1e30));`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_matrix_vec: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30))[0] * mat2x2(vec2(const_1e30), vec2(let_1e30))[0];`,\n    stage: 'constant',\n    valid: true,\n  },\n  const_let_matrix_comp: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30))[0].x * mat2x2(vec2(const_1e30), vec2(let_1e30))[0].x;`,\n    stage: 'constant',\n    valid: true,\n  },\n  override_scalar: {\n    code: `let tmp = override_1e30 * override_1e30;`,\n    stage: 'override',\n    valid: false,\n  },\n  override_vector: {\n    code: `let tmp = vec4(override_1e30) * vec4(override_1e30);`,\n    stage: 'override',\n    valid: false,\n  },\n  override_let_vector: {\n    code: `let tmp = vec4(override_1e30) * vec4(vec3(override_1e30), let_1e30);`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_vector_comp: {\n    code: `let tmp = vec2(override_1e30)[0] * vec2(override_1e30, let_1e30)[0];`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_array_comp: {\n    code: `let tmp = array(override_1e30, override_1e30)[0] * array(override_1e30, let_1e30)[0];`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_struct_comp: {\n    code: `let tmp = S(override_1e30, override_1e30).x * S(override_1e30, let_1e30).x;`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_matrix: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30)) * mat2x2(vec2(override_1e30), vec2(let_1e30));`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_matrix_vec: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30))[0] * mat2x2(vec2(override_1e30), vec2(let_1e30))[0];`,\n    stage: 'override',\n    valid: true,\n  },\n  override_let_matrix_comp: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30))[0].x * mat2x2(vec2(override_1e30), vec2(let_1e30))[0].x;`,\n    stage: 'override',\n    valid: true,\n  },\n};\n\ng.test('composites')\n  .desc('Validates that composites are either wholly evaluated or not at all')\n  .params(u => u.combine('case', keysOf(kCompositeCases)))\n  .fn(t => {\n    const { code, stage, valid } = kCompositeCases[t.params.case];\n    const wgsl = `\nstruct S {\n  x : f32,\n  y : f32,\n}\nconst const_1e30 = f32(1e30);\noverride override_1e30 : f32;\nfn foo() -> u32 {\n  let let_1e30 = f32(1e30);\n  ${code}\n  return 0;\n}`;\n\n    if (stage === 'constant') {\n      t.expectCompileResult(valid, wgsl);\n    } else {\n      const constants: Record<string, number> = {};\n      constants['override_1e30'] = 1e30;\n      t.expectPipelineResult({\n        expectedResult: valid,\n        code: wgsl,\n        constants,\n        reference: ['override_1e30', 'foo()'],\n      });\n    }\n  });\n"],"mappings":"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"}
{"version":3,"file":"add_sub_mul.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","kAllScalarsAndVectors","kConvertableToFloatScalar","scalarTypeOf","Type","VectorType","ShaderValidationTest","g","kOperators","add","op","sub","mul","kScalarAndVectorTypes","test","desc","params","u","combine","filter","value","startsWith","beginSubcases","beforeAllSubcases","t","lhs","f16","rhs","selectDeviceOrSkipTestCase","fn","lhsElement","rhsElement","hasF16","code","create","wgsl","elementsCompatible","elementTypes","includes","bool","abstractInt","abstractFloat","every","e","valid","width","expectCompileResult","kInvalidTypes","array","expr","control","ptr","atomic","texture","sampler","struct","unimplemented","type"],"sources":["../../../../../../src/webgpu/shader/validation/expression/binary/add_sub_mul.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for add/sub/mul expressions.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport {\n  kAllScalarsAndVectors,\n  kConvertableToFloatScalar,\n  scalarTypeOf,\n  Type,\n  VectorType,\n} from '../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of operators tested in this file.\nconst kOperators = {\n  add: { op: '+' },\n  sub: { op: '-' },\n  mul: { op: '*' },\n};\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector')\n  .desc(\n    `\n  Validates that scalar and vector expressions are only accepted for compatible numeric types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('lhs', keysOf(kScalarAndVectorTypes))\n      .combine(\n        'rhs',\n        // Skip vec3 and vec4 on the RHS to keep the number of subcases down.\n        // vec3 + vec3 and vec4 + vec4 is tested in execution tests.\n        keysOf(kScalarAndVectorTypes).filter(\n          value => !(value.startsWith('vec3') || value.startsWith('vec4'))\n        )\n      )\n      .beginSubcases()\n      .combine('op', keysOf(kOperators))\n  )\n  .beforeAllSubcases(t => {\n    if (\n      scalarTypeOf(kScalarAndVectorTypes[t.params.lhs]) === Type.f16 ||\n      scalarTypeOf(kScalarAndVectorTypes[t.params.rhs]) === Type.f16\n    ) {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const lhs = kScalarAndVectorTypes[t.params.lhs];\n    const rhs = kScalarAndVectorTypes[t.params.rhs];\n    const lhsElement = scalarTypeOf(lhs);\n    const rhsElement = scalarTypeOf(rhs);\n    const hasF16 = lhsElement === Type.f16 || rhsElement === Type.f16;\n    const code = `\n${hasF16 ? 'enable f16;' : ''}\nconst lhs = ${lhs.create(0).wgsl()};\nconst rhs = ${rhs.create(0).wgsl()};\nconst foo = lhs ${op.op} rhs;\n`;\n\n    let elementsCompatible = lhsElement === rhsElement;\n    const elementTypes = [lhsElement, rhsElement];\n\n    // Booleans are not allowed for arithmetic expressions.\n    if (elementTypes.includes(Type.bool)) {\n      elementsCompatible = false;\n\n      // AbstractInt is allowed with everything but booleans which are already checked above.\n    } else if (elementTypes.includes(Type.abstractInt)) {\n      elementsCompatible = true;\n\n      // AbstractFloat is allowed with AbstractInt (checked above) or float types\n    } else if (elementTypes.includes(Type.abstractFloat)) {\n      elementsCompatible = elementTypes.every(e => kConvertableToFloatScalar.includes(e));\n    }\n\n    // Determine if the full type is compatible. The only invalid case is mixed vector sizes.\n    let valid = elementsCompatible;\n    if (lhs instanceof VectorType && rhs instanceof VectorType) {\n      valid = valid && lhs.width === rhs.width;\n    }\n\n    t.expectCompileResult(valid, code);\n  });\n\ninterface InvalidTypeConfig {\n  // An expression that produces a value of the target type.\n  expr: string;\n  // A function that converts an expression of the target type into a valid integer operand.\n  control: (x: string) => string;\n}\nconst kInvalidTypes: Record<string, InvalidTypeConfig> = {\n  array: {\n    expr: 'arr',\n    control: e => `${e}[0]`,\n  },\n\n  ptr: {\n    expr: '(&u)',\n    control: e => `*${e}`,\n  },\n\n  atomic: {\n    expr: 'a',\n    control: e => `atomicLoad(&${e})`,\n  },\n\n  texture: {\n    expr: 't',\n    control: e => `i32(textureLoad(${e}, vec2(), 0).x)`,\n  },\n\n  sampler: {\n    expr: 's',\n    control: e => `i32(textureSampleLevel(t, ${e}, vec2(), 0).x)`,\n  },\n\n  struct: {\n    expr: 'str',\n    control: e => `${e}.u`,\n  },\n};\n\ng.test('scalar_vector_out_of_range')\n  .desc(\n    `\n  TODO: Check with a couple values in f32 or f16 that would result in out of range values on the type.\n  `\n  )\n  .unimplemented();\n\ng.test('invalid_type_with_itself')\n  .desc(\n    `\n  Validates that expressions are never accepted for non-scalar, non-vector, and non-matrix types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', keysOf(kOperators))\n      .combine('type', keysOf(kInvalidTypes))\n      .combine('control', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const type = kInvalidTypes[t.params.type];\n    const expr = t.params.control ? type.control(type.expr) : type.expr;\n    const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { u : u32 }\n\nvar<private> u : u32;\nvar<private> m : mat2x2f;\nvar<private> arr : array<i32, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${expr} ${op.op} ${expr};\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n"],"mappings":"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"}
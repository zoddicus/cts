{"version":3,"file":"add_sub_mul.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","assert","kBit","kAllScalarsAndVectors","kConcreteNumericScalarsAndVectors","kConvertableToFloatScalar","ScalarType","scalarTypeOf","Type","VectorType","nextAfterF16","nextAfterF32","reinterpretU16AsF16","reinterpretU32AsF32","ShaderValidationTest","kConstantAndOverrideStages","validateConstOrOverrideBinaryOpEval","g","kOperators","add","op","sub","mul","kScalarAndVectorTypes","kConcreteNumericScalarAndVectorTypes","test","desc","params","u","combine","filter","value","startsWith","beginSubcases","beforeAllSubcases","t","lhs","f16","rhs","selectDeviceOrSkipTestCase","fn","lhsElement","rhsElement","hasF16","code","create","wgsl","elementsCompatible","elementTypes","includes","bool","abstractInt","abstractFloat","every","e","valid","width","expectCompileResult","expand","p","toString","lType","nonZeroIndex","valueCase","swap","elementType","maxValue","nextAfter","v","outOfRangeIsError","positive","max","f32","u32","i32","Math","floor","ceil","sqrt","computedValue","leftValue","rightValue","type","index","values","Array","fill","success","abs","stage","kInvalidTypes","array","expr","control","ptr","atomic","texture","sampler","struct"],"sources":["../../../../../../src/webgpu/shader/validation/expression/binary/add_sub_mul.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for add/sub/mul expressions.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport { assert } from '../../../../../common/util/util.js';\nimport { kBit } from '../../../../util/constants.js';\nimport {\n  kAllScalarsAndVectors,\n  kConcreteNumericScalarsAndVectors,\n  kConvertableToFloatScalar,\n  ScalarType,\n  scalarTypeOf,\n  Type,\n  Value,\n  VectorType,\n} from '../../../../util/conversion.js';\nimport { nextAfterF16, nextAfterF32 } from '../../../../util/math.js';\nimport { reinterpretU16AsF16, reinterpretU32AsF32 } from '../../../../util/reinterpret.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\nimport {\n  kConstantAndOverrideStages,\n  validateConstOrOverrideBinaryOpEval,\n} from '../call/builtin/const_override_validation.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of operators tested in this file.\nconst kOperators = {\n  add: { op: '+' },\n  sub: { op: '-' },\n  mul: { op: '*' },\n};\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\nconst kConcreteNumericScalarAndVectorTypes = objectsToRecord(kConcreteNumericScalarsAndVectors);\n\ng.test('scalar_vector')\n  .desc(\n    `\n  Validates that scalar and vector expressions are only accepted for compatible numeric types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('lhs', keysOf(kScalarAndVectorTypes))\n      .combine(\n        'rhs',\n        // Skip vec3 and vec4 on the RHS to keep the number of subcases down.\n        // vec3 + vec3 and vec4 + vec4 is tested in execution tests.\n        keysOf(kScalarAndVectorTypes).filter(\n          value => !(value.startsWith('vec3') || value.startsWith('vec4'))\n        )\n      )\n      .beginSubcases()\n      .combine('op', keysOf(kOperators))\n  )\n  .beforeAllSubcases(t => {\n    if (\n      scalarTypeOf(kScalarAndVectorTypes[t.params.lhs]) === Type.f16 ||\n      scalarTypeOf(kScalarAndVectorTypes[t.params.rhs]) === Type.f16\n    ) {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const lhs = kScalarAndVectorTypes[t.params.lhs];\n    const rhs = kScalarAndVectorTypes[t.params.rhs];\n    const lhsElement = scalarTypeOf(lhs);\n    const rhsElement = scalarTypeOf(rhs);\n    const hasF16 = lhsElement === Type.f16 || rhsElement === Type.f16;\n    const code = `\n${hasF16 ? 'enable f16;' : ''}\nconst lhs = ${lhs.create(0).wgsl()};\nconst rhs = ${rhs.create(0).wgsl()};\nconst foo = lhs ${op.op} rhs;\n`;\n\n    let elementsCompatible = lhsElement === rhsElement;\n    const elementTypes = [lhsElement, rhsElement];\n\n    // Booleans are not allowed for arithmetic expressions.\n    if (elementTypes.includes(Type.bool)) {\n      elementsCompatible = false;\n\n      // AbstractInt is allowed with everything but booleans which are already checked above.\n    } else if (elementTypes.includes(Type.abstractInt)) {\n      elementsCompatible = true;\n\n      // AbstractFloat is allowed with AbstractInt (checked above) or float types\n    } else if (elementTypes.includes(Type.abstractFloat)) {\n      elementsCompatible = elementTypes.every(e => kConvertableToFloatScalar.includes(e));\n    }\n\n    // Determine if the full type is compatible. The only invalid case is mixed vector sizes.\n    let valid = elementsCompatible;\n    if (lhs instanceof VectorType && rhs instanceof VectorType) {\n      valid = valid && lhs.width === rhs.width;\n    }\n\n    t.expectCompileResult(valid, code);\n  });\n\ng.test('scalar_vector_out_of_range')\n  .desc(\n    `\n    Checks that constant or override evaluation of add/sub/mul operations on scalar/vectors that produce out of range values cause validation errors.\n      - Checks for all concrete numeric scalar and vector types, including scalar * vector and vector * scalar.\n      - Checks for all vector elements that could cause the out of range to happen.\n      - Checks for pairs of values at one ULP difference at the boundary of the out of range.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', keysOf(kOperators))\n      .combine('lhs', keysOf(kConcreteNumericScalarAndVectorTypes))\n      .expand('rhs', p => {\n        if (kScalarAndVectorTypes[p.lhs] instanceof VectorType) {\n          return [p.lhs, scalarTypeOf(kScalarAndVectorTypes[p.lhs]).toString()];\n        }\n        return [p.lhs];\n      })\n      .beginSubcases()\n      .expand('swap', p => {\n        if (p.lhs === p.rhs) {\n          return [false];\n        }\n        return [false, true];\n      })\n      .combine('nonZeroIndex', [0, 1, 2, 3])\n      .filter(p => {\n        const lType = kScalarAndVectorTypes[p.lhs];\n        if (lType instanceof VectorType) {\n          return lType.width > p.nonZeroIndex;\n        }\n        return p.nonZeroIndex === 0;\n      })\n      .combine('valueCase', ['halfmax', 'halfmax+ulp', 'sqrtmax', 'sqrtmax+ulp'] as const)\n      .combine('stage', kConstantAndOverrideStages)\n  )\n  .beforeAllSubcases(t => {\n    if (\n      scalarTypeOf(kScalarAndVectorTypes[t.params.lhs]) === Type.f16 ||\n      scalarTypeOf(kScalarAndVectorTypes[t.params.rhs]) === Type.f16\n    ) {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const { op, valueCase, nonZeroIndex, swap } = t.params;\n    let { lhs, rhs } = t.params;\n\n    const elementType = scalarTypeOf(kScalarAndVectorTypes[lhs]);\n\n    // Handle the swapping of LHS and RHS to test all cases of scalar * vector.\n    if (swap) {\n      [rhs, lhs] = [lhs, rhs];\n    }\n\n    // What is the maximum representable value for the type? Also how do we add a ULP?\n    let maxValue = 0;\n    let nextAfter: (v: number) => number = v => v + 1;\n    let outOfRangeIsError = false;\n    switch (elementType) {\n      case Type.f16:\n        maxValue = reinterpretU16AsF16(kBit.f16.positive.max);\n        nextAfter = v => nextAfterF16(v, 'positive', 'no-flush');\n        outOfRangeIsError = true;\n        break;\n      case Type.f32:\n        maxValue = reinterpretU32AsF32(kBit.f32.positive.max);\n        nextAfter = v => nextAfterF32(v, 'positive', 'no-flush');\n        outOfRangeIsError = true;\n        break;\n      case Type.u32:\n        maxValue = kBit.u32.max;\n        break;\n      case Type.i32:\n        maxValue = kBit.i32.positive.max;\n        break;\n    }\n\n    // Decide on the test value that may or may not do an out of range computation.\n    let value;\n    switch (valueCase) {\n      case 'halfmax':\n        value = Math.floor(maxValue / 2);\n        break;\n      case 'halfmax+ulp':\n        value = nextAfter(Math.ceil(maxValue / 2));\n        break;\n      case 'sqrtmax':\n        value = Math.floor(Math.sqrt(maxValue));\n        break;\n      case 'sqrtmax+ulp':\n        value = nextAfter(Math.ceil(Math.sqrt(maxValue)));\n        break;\n    }\n\n    // What value will be computed by the test?\n    let computedValue;\n    let leftValue = value;\n    const rightValue = value;\n    switch (op) {\n      case 'add':\n        computedValue = value + value;\n        break;\n      case 'sub':\n        computedValue = -value - value;\n        leftValue = -value;\n        break;\n      case 'mul':\n        computedValue = value * value;\n        break;\n    }\n\n    // Creates either a scalar with the value, or a vector with the value only at a specific index.\n    const create = (type: ScalarType | VectorType, index: number, value: number): Value => {\n      if (type instanceof ScalarType) {\n        return type.create(value);\n      } else {\n        assert(type instanceof VectorType);\n        const values = new Array(type.width);\n        values.fill(0);\n        values[index] = value;\n        return type.create(values);\n      }\n    };\n\n    // Check if there is overflow\n    const success = Math.abs(computedValue) <= maxValue || !outOfRangeIsError;\n    validateConstOrOverrideBinaryOpEval(\n      t,\n      kOperators[op].op,\n      success,\n      t.params.stage,\n      create(kScalarAndVectorTypes[lhs], nonZeroIndex, leftValue),\n      t.params.stage,\n      create(kScalarAndVectorTypes[rhs], nonZeroIndex, rightValue)\n    );\n  });\n\ninterface InvalidTypeConfig {\n  // An expression that produces a value of the target type.\n  expr: string;\n  // A function that converts an expression of the target type into a valid integer operand.\n  control: (x: string) => string;\n}\nconst kInvalidTypes: Record<string, InvalidTypeConfig> = {\n  array: {\n    expr: 'arr',\n    control: e => `${e}[0]`,\n  },\n\n  ptr: {\n    expr: '(&u)',\n    control: e => `*${e}`,\n  },\n\n  atomic: {\n    expr: 'a',\n    control: e => `atomicLoad(&${e})`,\n  },\n\n  texture: {\n    expr: 't',\n    control: e => `i32(textureLoad(${e}, vec2(), 0).x)`,\n  },\n\n  sampler: {\n    expr: 's',\n    control: e => `i32(textureSampleLevel(t, ${e}, vec2(), 0).x)`,\n  },\n\n  struct: {\n    expr: 'str',\n    control: e => `${e}.u`,\n  },\n};\n\ng.test('invalid_type_with_itself')\n  .desc(\n    `\n  Validates that expressions are never accepted for non-scalar, non-vector, and non-matrix types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', keysOf(kOperators))\n      .combine('type', keysOf(kInvalidTypes))\n      .combine('control', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const type = kInvalidTypes[t.params.type];\n    const expr = t.params.control ? type.control(type.expr) : type.expr;\n    const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { u : u32 }\n\nvar<private> u : u32;\nvar<private> m : mat2x2f;\nvar<private> arr : array<i32, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${expr} ${op.op} ${expr};\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n"],"mappings":"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"}
{"version":3,"file":"shader_builtin_utils.js","names":["assert","Type","kEntryPointsToValidateFragmentOnlyBuiltins","none","expectSuccess","code","fragment","vertex","compute","fragment_and_compute","compute_without_call","kTestTextureTypes","kTextureTypeSuffixToType","f32","vec4f","u32","vec4i","vec4u","getSampleAndBaseTextureTypeForTextureType","textureType","match","exec","sampleType"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/shader_builtin_utils.ts"],"sourcesContent":["import { assert } from '../../../../../../common/util/util.js';\nimport { Type } from '../../../../../util/conversion.js';\n\n/**\n * Use to test that certain WGSL builtins are only available in the fragment stage.\n * Create WGSL that defines a function \"foo\" and its required variables that uses\n * the builtin being tested. Append it to these code strings then compile. It should\n * succeed or fail based on the value `expectSuccess`.\n *\n * See ./textureSample.spec.ts was one example\n */\nexport const kEntryPointsToValidateFragmentOnlyBuiltins = {\n  none: {\n    expectSuccess: true,\n    code: ``,\n  },\n  fragment: {\n    expectSuccess: true,\n    code: `\n      @fragment\n      fn main() {\n        foo();\n      }\n    `,\n  },\n  vertex: {\n    expectSuccess: false,\n    code: `\n      @vertex\n      fn main() -> @builtin(position) vec4f {\n        foo();\n        return vec4f();\n      }\n    `,\n  },\n  compute: {\n    expectSuccess: false,\n    code: `\n      @compute @workgroup_size(1)\n      fn main() {\n        foo();\n      }\n    `,\n  },\n  fragment_and_compute: {\n    expectSuccess: false,\n    code: `\n      @fragment\n      fn main1() {\n        foo();\n      }\n\n      @compute @workgroup_size(1)\n      fn main2() {\n        foo();\n      }\n    `,\n  },\n  compute_without_call: {\n    expectSuccess: true,\n    code: `\n      @compute @workgroup_size(1)\n      fn main() {\n      }\n    `,\n  },\n};\n\nexport const kTestTextureTypes = [\n  'texture_1d<f32>',\n  'texture_1d<u32>',\n  'texture_2d<f32>',\n  'texture_2d<u32>',\n  'texture_2d_array<f32>',\n  'texture_2d_array<u32>',\n  'texture_3d<f32>',\n  'texture_3d<u32>',\n  'texture_cube<f32>',\n  'texture_cube<u32>',\n  'texture_cube_array<f32>',\n  'texture_cube_array<u32>',\n  'texture_multisampled_2d<f32>',\n  'texture_multisampled_2d<u32>',\n  'texture_depth_multisampled_2d',\n  'texture_external',\n  'texture_storage_1d<rgba8unorm, read>',\n  'texture_storage_1d<r32uint, read>',\n  'texture_storage_2d<rgba8unorm, read>',\n  'texture_storage_2d<r32uint, read>',\n  'texture_storage_2d_array<rgba8unorm, read>',\n  'texture_storage_2d_a32uint8unorm, read>',\n  'texture_storage_3d<rgba8unorm, read>',\n  'texture_storage_3d<r32uint, read>',\n  'texture_depth_2d',\n  'texture_depth_2d_array',\n  'texture_depth_cube',\n  'texture_depth_cube_array',\n] as const;\n\nconst kTextureTypeSuffixToType: { [key: string]: Type } = {\n  f32: Type.vec4f,\n  u32: Type.vec4i,\n  'rgba8unorm, read': Type.vec4f,\n  'r32uint, read': Type.vec4u,\n};\n\n/** @returns the base type and sample type for kTestTextureTypes */\nexport function getSampleAndBaseTextureTypeForTextureType(\n  textureType: (typeof kTestTextureTypes)[number]\n): [string, Type] {\n  const match = /^(.*?)<(.*?)>/.exec(textureType);\n  const sampleType = match ? kTextureTypeSuffixToType[match[2]] : Type.vec4f;\n  assert(!!sampleType);\n  return [match ? match[1] : textureType, sampleType];\n}\n"],"mappings":";;GAAA,SAASA,MAAM,QAAQ,uCAAuC,CAC9D,SAASC,IAAI,QAAQ,mCAAmC;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,0CAA0C,GAAG;EACxDC,IAAI,EAAE;IACJC,aAAa,EAAE,IAAI;IACnBC,IAAI,EAAG;EACT,CAAC;EACDC,QAAQ,EAAE;IACRF,aAAa,EAAE,IAAI;IACnBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;EACE,CAAC;EACDE,MAAM,EAAE;IACNH,aAAa,EAAE,KAAK;IACpBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACDG,OAAO,EAAE;IACPJ,aAAa,EAAE,KAAK;IACpBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;EACE,CAAC;EACDI,oBAAoB,EAAE;IACpBL,aAAa,EAAE,KAAK;IACpBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC;EACDK,oBAAoB,EAAE;IACpBN,aAAa,EAAE,IAAI;IACnBC,IAAI,EAAG;AACX;AACA;AACA;AACA;EACE;AACF,CAAC;;AAED,OAAO,MAAMM,iBAAiB,GAAG;AAC/B,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,uBAAuB;AACvB,uBAAuB;AACvB,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;AACnB,mBAAmB;AACnB,yBAAyB;AACzB,yBAAyB;AACzB,8BAA8B;AAC9B,8BAA8B;AAC9B,+BAA+B;AAC/B,kBAAkB;AAClB,sCAAsC;AACtC,mCAAmC;AACnC,sCAAsC;AACtC,mCAAmC;AACnC,4CAA4C;AAC5C,yCAAyC;AACzC,sCAAsC;AACtC,mCAAmC;AACnC,kBAAkB;AAClB,wBAAwB;AACxB,oBAAoB;AACpB,0BAA0B,CAClB;;;AAEV,MAAMC,wBAAiD,GAAG;EACxDC,GAAG,EAAEZ,IAAI,CAACa,KAAK;EACfC,GAAG,EAAEd,IAAI,CAACe,KAAK;EACf,kBAAkB,EAAEf,IAAI,CAACa,KAAK;EAC9B,eAAe,EAAEb,IAAI,CAACgB;AACxB,CAAC;;AAED;AACA,OAAO,SAASC,yCAAyCA;AACvDC,WAA+C;AAC/B;EAChB,MAAMC,KAAK,GAAG,eAAe,CAACC,IAAI,CAACF,WAAW,CAAC;EAC/C,MAAMG,UAAU,GAAGF,KAAK,GAAGR,wBAAwB,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGnB,IAAI,CAACa,KAAK;EAC1Ed,MAAM,CAAC,CAAC,CAACsB,UAAU,CAAC;EACpB,OAAO,CAACF,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGD,WAAW,EAAEG,UAAU,CAAC;AACrD"}
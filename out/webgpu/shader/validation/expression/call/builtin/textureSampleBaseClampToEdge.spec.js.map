{"version":3,"file":"textureSampleBaseClampToEdge.spec.js","names":["builtin","description","makeTestGroup","keysOf","objectsToRecord","Type","kAllScalarsAndVectors","isConvertible","isUnsignedType","ShaderValidationTest","kTestTextureTypes","kTextureSampleBaseClampToEdgeTextureTypes","kValuesTypes","g","test","specURL","desc","params","u","combine","fn","t","returnType","textureType","returnVarType","varWGSL","toString","code","expectSuccess","vec4f","expectCompileResult","beginSubcases","filter","coordType","value","coordArgType","coordWGSL","create","wgsl","vec2f","testTextureType","includes","use"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/textureSampleBaseClampToEdge.spec.ts"],"sourcesContent":["const builtin = 'textureSampleBaseClampToEdge';\nexport const description = `\nValidation tests for the ${builtin}() builtin.\n\n* test textureSampleBaseClampToEdge coords parameter must be correct type\n* test textureSampleBaseClampToEdge returns the correct type\n* test textureSampleBaseClampToEdge doesn't work with texture types it's not supposed to\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../../common/util/data_tables.js';\nimport {\n  Type,\n  kAllScalarsAndVectors,\n  isConvertible,\n  isUnsignedType,\n} from '../../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nimport { kTestTextureTypes } from './shader_builtin_utils.js';\n\nconst kTextureSampleBaseClampToEdgeTextureTypes = ['texture_2d<f32>', 'texture_external'];\nconst kValuesTypes = objectsToRecord(kAllScalarsAndVectors);\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('return_type')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge')\n  .desc(\n    `\nValidates the return type of ${builtin} is the expected type.\n`\n  )\n  .params(u =>\n    u\n      .combine('returnType', keysOf(kValuesTypes))\n      .combine('textureType', kTextureSampleBaseClampToEdgeTextureTypes)\n  )\n  .fn(t => {\n    const { returnType, textureType } = t.params;\n    const returnVarType = kValuesTypes[returnType];\n\n    const varWGSL = returnVarType.toString();\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v: ${varWGSL} = textureSampleBaseClampToEdge(t, s, vec2f(0));\n  return vec4f(0);\n}\n`;\n    const expectSuccess = isConvertible(Type.vec4f, returnVarType);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('coords_argument')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge')\n  .desc(\n    `\nValidates that only incorrect coords arguments are rejected by ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', kTextureSampleBaseClampToEdgeTextureTypes)\n      .combine('coordType', keysOf(kValuesTypes))\n      .beginSubcases()\n      .combine('value', [-1, 0, 1] as const)\n      // filter out unsigned types with negative values\n      .filter(t => !isUnsignedType(kValuesTypes[t.coordType]) || t.value >= 0)\n  )\n  .fn(t => {\n    const { textureType, coordType, value } = t.params;\n    const coordArgType = kValuesTypes[coordType];\n    const coordWGSL = coordArgType.create(value).wgsl();\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSampleBaseClampToEdge(t, s, ${coordWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess = isConvertible(coordArgType, Type.vec2f);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('texture_type')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge')\n  .desc(\n    `\nValidates that incompatible texture types don't work with ${builtin}\n`\n  )\n  .params(u => u.combine('testTextureType', kTestTextureTypes))\n  .fn(t => {\n    const { testTextureType } = t.params;\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${testTextureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSampleBaseClampToEdge(t, s, vec2f(0));\n  return vec4f(0);\n}\n`;\n    const expectSuccess = kTextureSampleBaseClampToEdgeTextureTypes.includes(testTextureType);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('must_use')\n  .desc('Tests that the result must be used')\n  .params(u => u.combine('use', [true, false] as const))\n  .fn(t => {\n    const code = `\n    @group(0) @binding(0) var t : texture_2d<f32>;\n    @group(0) @binding(1) var s : sampler;\n    fn foo() {\n      ${t.params.use ? '_ =' : ''} textureSampleBaseClampToEdge(t,s, vec2(0,0));\n    }`;\n    t.expectCompileResult(t.params.use, code);\n  });\n"],"mappings":"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"}
{"version":3,"file":"textureSample.spec.js","names":["builtin","description","makeTestGroup","keysOf","objectsToRecord","Type","kAllScalarsAndVectors","isConvertible","isUnsignedType","ShaderValidationTest","kEntryPointsToValidateFragmentOnlyBuiltins","kTestTextureTypes","kValidTextureSampleParameterTypes","returnType","vec4f","coordsArgType","f32","vec2f","offsetArgType","vec2i","hasArrayIndexArg","vec3f","vec3i","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","kTextureTypes","kValuesTypes","g","test","specURL","desc","params","u","combine","beginSubcases","expand","t","textureType","fn","offset","returnVarType","returnExpectedType","varWGSL","toString","coordWGSL","create","wgsl","arrayWGSL","offsetWGSL","code","expectSuccess","expectCompileResult","filter","coordType","value","coordArgType","coordsRequiredType","arrayIndexType","arrayIndexArgType","args","map","arg","join","i32","u32","offsetType","offsetRequiredType","varType","entryPoint","config","testTextureType","types","typesMatch","use"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/textureSample.spec.ts"],"sourcesContent":["const builtin = 'textureSample';\nexport const description = `\nValidation tests for the ${builtin}() builtin.\n\n* test textureSample coords parameter must be correct type\n* test textureSample array_index parameter must be correct type\n* test textureSample coords parameter must be correct type\n* test textureSample offset parameter must be correct type\n* test textureSample offset parameter must be a const-expression\n* test textureSample offset parameter must be between -8 and +7 inclusive\n* test textureSample not usable in a compute or vertex shader\n* test textureSample returns the correct type\n* test textureSample doesn't work with texture types it's not supposed to\n\nnote: uniformity validation is covered in src/webgpu/shader/validation/uniformity/uniformity.spec.ts\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../../common/util/data_tables.js';\nimport {\n  Type,\n  kAllScalarsAndVectors,\n  isConvertible,\n  ScalarType,\n  VectorType,\n  isUnsignedType,\n} from '../../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nimport {\n  kEntryPointsToValidateFragmentOnlyBuiltins,\n  kTestTextureTypes,\n} from './shader_builtin_utils.js';\n\ntype TextureSampleArguments = {\n  returnType: ScalarType | VectorType;\n  coordsArgType: ScalarType | VectorType;\n  hasArrayIndexArg?: boolean;\n  offsetArgType?: VectorType;\n};\n\nconst kValidTextureSampleParameterTypes: { [n: string]: TextureSampleArguments } = {\n  'texture_1d<f32>': { returnType: Type.vec4f, coordsArgType: Type.f32 },\n  'texture_2d<f32>': {\n    returnType: Type.vec4f,\n    coordsArgType: Type.vec2f,\n    offsetArgType: Type.vec2i,\n  },\n  'texture_2d_array<f32>': {\n    returnType: Type.vec4f,\n    coordsArgType: Type.vec2f,\n    hasArrayIndexArg: true,\n    offsetArgType: Type.vec2i,\n  },\n  'texture_3d<f32>': {\n    returnType: Type.vec4f,\n    coordsArgType: Type.vec3f,\n    offsetArgType: Type.vec3i,\n  },\n  'texture_cube<f32>': { returnType: Type.vec4f, coordsArgType: Type.vec3f },\n  'texture_cube_array<f32>': {\n    returnType: Type.vec4f,\n    coordsArgType: Type.vec3f,\n    hasArrayIndexArg: true,\n  },\n  texture_depth_2d: { returnType: Type.f32, coordsArgType: Type.vec2f, offsetArgType: Type.vec2i },\n  texture_depth_2d_array: {\n    returnType: Type.f32,\n    coordsArgType: Type.vec2f,\n    hasArrayIndexArg: true,\n    offsetArgType: Type.vec2i,\n  },\n  texture_depth_cube: { returnType: Type.f32, coordsArgType: Type.vec3f },\n  texture_depth_cube_array: {\n    returnType: Type.f32,\n    coordsArgType: Type.vec3f,\n    hasArrayIndexArg: true,\n  },\n} as const;\n\nconst kTextureTypes = keysOf(kValidTextureSampleParameterTypes);\nconst kValuesTypes = objectsToRecord(kAllScalarsAndVectors);\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('return_type')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates the return type of ${builtin} is the expected type.\n`\n  )\n  .params(u =>\n    u\n      .combine('returnType', keysOf(kValuesTypes))\n      .combine('textureType', keysOf(kValidTextureSampleParameterTypes))\n      .beginSubcases()\n      .expand('offset', t =>\n        kValidTextureSampleParameterTypes[t.textureType].offsetArgType ? [false, true] : [false]\n      )\n  )\n  .fn(t => {\n    const { returnType, textureType, offset } = t.params;\n    const returnVarType = kValuesTypes[returnType];\n    const {\n      returnType: returnExpectedType,\n      offsetArgType,\n      coordsArgType,\n      hasArrayIndexArg,\n    } = kValidTextureSampleParameterTypes[textureType];\n\n    const varWGSL = returnVarType.toString();\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = offset ? `, ${offsetArgType?.create(0).wgsl()}` : '';\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v: ${varWGSL} = textureSample(t, s, ${coordWGSL}${arrayWGSL}${offsetWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess = isConvertible(returnExpectedType, returnVarType);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('coords_argument')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that only incorrect coords arguments are rejected by ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', keysOf(kValidTextureSampleParameterTypes))\n      .combine('coordType', keysOf(kValuesTypes))\n      .beginSubcases()\n      .combine('value', [-1, 0, 1] as const)\n      // filter out unsigned types with negative values\n      .filter(t => !isUnsignedType(kValuesTypes[t.coordType]) || t.value >= 0)\n      .expand('offset', t =>\n        kValidTextureSampleParameterTypes[t.textureType].offsetArgType ? [false, true] : [false]\n      )\n  )\n  .fn(t => {\n    const { textureType, coordType, offset, value } = t.params;\n    const coordArgType = kValuesTypes[coordType];\n    const {\n      offsetArgType,\n      coordsArgType: coordsRequiredType,\n      hasArrayIndexArg,\n    } = kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordArgType.create(value).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = offset ? `, ${offsetArgType?.create(0).wgsl()}` : '';\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSample(t, s, ${coordWGSL}${arrayWGSL}${offsetWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess = isConvertible(coordArgType, coordsRequiredType);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('array_index_argument')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that only incorrect array_index arguments are rejected by ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', kTextureTypes)\n      // filter out types with no array_index\n      .filter(t => !!kValidTextureSampleParameterTypes[t.textureType].hasArrayIndexArg)\n      .combine('arrayIndexType', keysOf(kValuesTypes))\n      .beginSubcases()\n      .combine('value', [-9, -8, 0, 7, 8])\n      // filter out unsigned types with negative values\n      .filter(t => !isUnsignedType(kValuesTypes[t.arrayIndexType]) || t.value >= 0)\n      .expand('offset', t =>\n        kValidTextureSampleParameterTypes[t.textureType].offsetArgType ? [false, true] : [false]\n      )\n  )\n  .fn(t => {\n    const { textureType, arrayIndexType, value, offset } = t.params;\n    const arrayIndexArgType = kValuesTypes[arrayIndexType];\n    const args = [arrayIndexArgType.create(value)];\n    const { coordsArgType, offsetArgType } = kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = args.map(arg => arg.wgsl()).join(', ');\n    const offsetWGSL = offset ? `, ${offsetArgType!.create(0).wgsl()}` : '';\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSample(t, s, ${coordWGSL}, ${arrayWGSL}${offsetWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess =\n      isConvertible(arrayIndexArgType, Type.i32) || isConvertible(arrayIndexArgType, Type.u32);\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('offset_argument')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that only incorrect offset arguments are rejected by ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', kTextureTypes)\n      // filter out types with no offset\n      .filter(t => !!kValidTextureSampleParameterTypes[t.textureType].offsetArgType)\n      .combine('offsetType', keysOf(kValuesTypes))\n      .beginSubcases()\n      .combine('value', [-9, -8, 0, 7, 8])\n      // filter out unsigned types with negative values\n      .filter(t => !isUnsignedType(kValuesTypes[t.offsetType]) || t.value >= 0)\n  )\n  .fn(t => {\n    const { textureType, offsetType, value } = t.params;\n    const offsetArgType = kValuesTypes[offsetType];\n    const args = [offsetArgType.create(value)];\n    const {\n      coordsArgType,\n      hasArrayIndexArg,\n      offsetArgType: offsetRequiredType,\n    } = kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = args.map(arg => arg.wgsl()).join(', ');\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSample(t, s, ${coordWGSL}${arrayWGSL}, ${offsetWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess =\n      isConvertible(offsetArgType, offsetRequiredType!) && value >= -8 && value <= 7;\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('offset_argument,non_const')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that only non-const offset arguments are rejected by ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', kTextureTypes)\n      .combine('varType', ['c', 'u', 'l'])\n      // filter out types with no offset\n      .filter(t => !!kValidTextureSampleParameterTypes[t.textureType].offsetArgType)\n  )\n  .fn(t => {\n    const { textureType, varType } = t.params;\n    const { coordsArgType, hasArrayIndexArg, offsetArgType } =\n      kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = `${offsetArgType}(${varType})`;\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@group(0) @binding(2) var<uniform> u: ${offsetArgType};\n@fragment fn fs() -> @location(0) vec4f {\n  const c = 1;\n  let l = ${offsetArgType!.create(0).wgsl()};\n  let v = textureSample(t, s, ${coordWGSL}${arrayWGSL}, ${offsetWGSL});\n  return vec4f(0);\n}\n`;\n    const expectSuccess = varType === 'c';\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('only_in_fragment')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that ${builtin} must not be used in a compute or vertex shader.\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', kTextureTypes)\n      .combine('entryPoint', keysOf(kEntryPointsToValidateFragmentOnlyBuiltins))\n      .expand('offset', t =>\n        kValidTextureSampleParameterTypes[t.textureType].offsetArgType ? [false, true] : [false]\n      )\n  )\n  .fn(t => {\n    const { textureType, entryPoint, offset } = t.params;\n    const { coordsArgType, hasArrayIndexArg, offsetArgType } =\n      kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = offset ? `, ${offsetArgType?.create(0).wgsl()}` : '';\n\n    const config = kEntryPointsToValidateFragmentOnlyBuiltins[entryPoint];\n    const code = `\n${config.code}\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n\nfn foo() {\n  _ = textureSample(t, s, ${coordWGSL}${arrayWGSL}${offsetWGSL});\n}`;\n    t.expectCompileResult(config.expectSuccess, code);\n  });\n\ng.test('texture_type')\n  .specURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesample')\n  .desc(\n    `\nValidates that incompatible texture types don't work with ${builtin}\n`\n  )\n  .params(u =>\n    u\n      .combine('testTextureType', kTestTextureTypes)\n      .combine('textureType', keysOf(kValidTextureSampleParameterTypes))\n      .expand('offset', t =>\n        kValidTextureSampleParameterTypes[t.textureType].offsetArgType ? [false, true] : [false]\n      )\n  )\n  .fn(t => {\n    const { testTextureType, textureType, offset } = t.params;\n    const { coordsArgType, offsetArgType, hasArrayIndexArg } =\n      kValidTextureSampleParameterTypes[textureType];\n\n    const coordWGSL = coordsArgType.create(0).wgsl();\n    const arrayWGSL = hasArrayIndexArg ? ', 0' : '';\n    const offsetWGSL = offset ? `, ${offsetArgType?.create(0).wgsl()}` : '';\n\n    const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${testTextureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSample(t, s, ${coordWGSL}${arrayWGSL}${offsetWGSL});\n  return vec4f(0);\n}\n`;\n\n    const types = kValidTextureSampleParameterTypes[testTextureType];\n    const typesMatch = types\n      ? types.coordsArgType === coordsArgType &&\n        types.hasArrayIndexArg === hasArrayIndexArg &&\n        (offset ? types.offsetArgType === offsetArgType : true)\n      : false;\n\n    const expectSuccess = testTextureType === textureType || typesMatch;\n    t.expectCompileResult(expectSuccess, code);\n  });\n\ng.test('must_use')\n  .desc('Tests that the result must be used')\n  .params(u => u.combine('use', [true, false] as const))\n  .fn(t => {\n    const code = `\n    @group(0) @binding(0) var t : texture_2d<f32>;\n    @group(0) @binding(1) var s : sampler;\n    fn foo() {\n      ${t.params.use ? '_ =' : ''} textureSample(t, s, vec2(0,0));\n    }`;\n    t.expectCompileResult(t.params.use, code);\n  });\n"],"mappings":";;GAAA,MAAMA,OAAO,GAAG,eAAe,CAC/B,OAAO,MAAMC,WAAW,GAAI;AAC5B,2BAA2BD,OAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,SAASE,aAAa,QAAQ,kDAAkD;AAChF,SAASC,MAAM,EAAEC,eAAe,QAAQ,8CAA8C;AACtF;EACEC,IAAI;EACJC,qBAAqB;EACrBC,aAAa;;;EAGbC,cAAc;AACT,mCAAmC;AAC1C,SAASC,oBAAoB,QAAQ,oCAAoC;;AAEzE;EACEC,0CAA0C;EAC1CC,iBAAiB;AACZ,2BAA2B;;;;;;;;;AASlC,MAAMC,iCAA0E,GAAG;EACjF,iBAAiB,EAAE,EAAEC,UAAU,EAAER,IAAI,CAACS,KAAK,EAAEC,aAAa,EAAEV,IAAI,CAACW,GAAG,CAAC,CAAC;EACtE,iBAAiB,EAAE;IACjBH,UAAU,EAAER,IAAI,CAACS,KAAK;IACtBC,aAAa,EAAEV,IAAI,CAACY,KAAK;IACzBC,aAAa,EAAEb,IAAI,CAACc;EACtB,CAAC;EACD,uBAAuB,EAAE;IACvBN,UAAU,EAAER,IAAI,CAACS,KAAK;IACtBC,aAAa,EAAEV,IAAI,CAACY,KAAK;IACzBG,gBAAgB,EAAE,IAAI;IACtBF,aAAa,EAAEb,IAAI,CAACc;EACtB,CAAC;EACD,iBAAiB,EAAE;IACjBN,UAAU,EAAER,IAAI,CAACS,KAAK;IACtBC,aAAa,EAAEV,IAAI,CAACgB,KAAK;IACzBH,aAAa,EAAEb,IAAI,CAACiB;EACtB,CAAC;EACD,mBAAmB,EAAE,EAAET,UAAU,EAAER,IAAI,CAACS,KAAK,EAAEC,aAAa,EAAEV,IAAI,CAACgB,KAAK,CAAC,CAAC;EAC1E,yBAAyB,EAAE;IACzBR,UAAU,EAAER,IAAI,CAACS,KAAK;IACtBC,aAAa,EAAEV,IAAI,CAACgB,KAAK;IACzBD,gBAAgB,EAAE;EACpB,CAAC;EACDG,gBAAgB,EAAE,EAAEV,UAAU,EAAER,IAAI,CAACW,GAAG,EAAED,aAAa,EAAEV,IAAI,CAACY,KAAK,EAAEC,aAAa,EAAEb,IAAI,CAACc,KAAK,CAAC,CAAC;EAChGK,sBAAsB,EAAE;IACtBX,UAAU,EAAER,IAAI,CAACW,GAAG;IACpBD,aAAa,EAAEV,IAAI,CAACY,KAAK;IACzBG,gBAAgB,EAAE,IAAI;IACtBF,aAAa,EAAEb,IAAI,CAACc;EACtB,CAAC;EACDM,kBAAkB,EAAE,EAAEZ,UAAU,EAAER,IAAI,CAACW,GAAG,EAAED,aAAa,EAAEV,IAAI,CAACgB,KAAK,CAAC,CAAC;EACvEK,wBAAwB,EAAE;IACxBb,UAAU,EAAER,IAAI,CAACW,GAAG;IACpBD,aAAa,EAAEV,IAAI,CAACgB,KAAK;IACzBD,gBAAgB,EAAE;EACpB;AACF,CAAU;;AAEV,MAAMO,aAAa,GAAGxB,MAAM,CAACS,iCAAiC,CAAC;AAC/D,MAAMgB,YAAY,GAAGxB,eAAe,CAACE,qBAAqB,CAAC;;AAE3D,OAAO,MAAMuB,CAAC,GAAG3B,aAAa,CAACO,oBAAoB,CAAC;;AAEpDoB,CAAC,CAACC,IAAI,CAAC,aAAa,CAAC;AAClBC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,+BAA+BhC,OAAQ;AACvC;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,YAAY,EAAEhC,MAAM,CAACyB,YAAY,CAAC,CAAC;AAC3CO,OAAO,CAAC,aAAa,EAAEhC,MAAM,CAACS,iCAAiC,CAAC,CAAC;AACjEwB,aAAa,CAAC,CAAC;AACfC,MAAM,CAAC,QAAQ,EAAE,CAAAC,CAAC;AACjB1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;AACzF;AACJ,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEzB,UAAU,EAAE0B,WAAW,EAAEE,MAAM,CAAC,CAAC,GAAGH,CAAC,CAACL,MAAM;EACpD,MAAMS,aAAa,GAAGd,YAAY,CAACf,UAAU,CAAC;EAC9C,MAAM;IACJA,UAAU,EAAE8B,kBAAkB;IAC9BzB,aAAa;IACbH,aAAa;IACbK;EACF,CAAC,GAAGR,iCAAiC,CAAC2B,WAAW,CAAC;;EAElD,MAAMK,OAAO,GAAGF,aAAa,CAACG,QAAQ,CAAC,CAAC;EACxC,MAAMC,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAGT,MAAM,GAAI,KAAIvB,aAAa,EAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE,EAAC,GAAG,EAAE;;EAEvE,MAAMG,IAAI,GAAI;AAClB;AACA,+BAA+BZ,WAAY;AAC3C;AACA,WAAWK,OAAQ,0BAAyBE,SAAU,GAAEG,SAAU,GAAEC,UAAW;AAC/E;AACA;AACA,CAAC;EACG,MAAME,aAAa,GAAG7C,aAAa,CAACoC,kBAAkB,EAAED,aAAa,CAAC;EACtEJ,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,iEAAiEhC,OAAQ;AACzE;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAEhC,MAAM,CAACS,iCAAiC,CAAC,CAAC;AACjEuB,OAAO,CAAC,WAAW,EAAEhC,MAAM,CAACyB,YAAY,CAAC,CAAC;AAC1CQ,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAU;AACrC;AAAA,CACCmB,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC9B,cAAc,CAACoB,YAAY,CAACU,CAAC,CAACiB,SAAS,CAAC,CAAC,IAAIjB,CAAC,CAACkB,KAAK,IAAI,CAAC,CAAC;AACvEnB,MAAM,CAAC,QAAQ,EAAE,CAAAC,CAAC;AACjB1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;AACzF;AACJ,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEC,WAAW,EAAEgB,SAAS,EAAEd,MAAM,EAAEe,KAAK,CAAC,CAAC,GAAGlB,CAAC,CAACL,MAAM;EAC1D,MAAMwB,YAAY,GAAG7B,YAAY,CAAC2B,SAAS,CAAC;EAC5C,MAAM;IACJrC,aAAa;IACbH,aAAa,EAAE2C,kBAAkB;IACjCtC;EACF,CAAC,GAAGR,iCAAiC,CAAC2B,WAAW,CAAC;;EAElD,MAAMO,SAAS,GAAGW,YAAY,CAACV,MAAM,CAACS,KAAK,CAAC,CAACR,IAAI,CAAC,CAAC;EACnD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAGT,MAAM,GAAI,KAAIvB,aAAa,EAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE,EAAC,GAAG,EAAE;;EAEvE,MAAMG,IAAI,GAAI;AAClB;AACA,+BAA+BZ,WAAY;AAC3C;AACA,gCAAgCO,SAAU,GAAEG,SAAU,GAAEC,UAAW;AACnE;AACA;AACA,CAAC;EACG,MAAME,aAAa,GAAG7C,aAAa,CAACkD,YAAY,EAAEC,kBAAkB,CAAC;EACrEpB,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,sEAAsEhC,OAAQ;AAC9E;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAER,aAAa;AACrC;AAAA,CACC2B,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC,CAAC1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACnB,gBAAgB,CAAC;AAChFe,OAAO,CAAC,gBAAgB,EAAEhC,MAAM,CAACyB,YAAY,CAAC,CAAC;AAC/CQ,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACnC;AAAA,CACCmB,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC9B,cAAc,CAACoB,YAAY,CAACU,CAAC,CAACqB,cAAc,CAAC,CAAC,IAAIrB,CAAC,CAACkB,KAAK,IAAI,CAAC,CAAC;AAC5EnB,MAAM,CAAC,QAAQ,EAAE,CAAAC,CAAC;AACjB1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;AACzF;AACJ,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEC,WAAW,EAAEoB,cAAc,EAAEH,KAAK,EAAEf,MAAM,CAAC,CAAC,GAAGH,CAAC,CAACL,MAAM;EAC/D,MAAM2B,iBAAiB,GAAGhC,YAAY,CAAC+B,cAAc,CAAC;EACtD,MAAME,IAAI,GAAG,CAACD,iBAAiB,CAACb,MAAM,CAACS,KAAK,CAAC,CAAC;EAC9C,MAAM,EAAEzC,aAAa,EAAEG,aAAa,CAAC,CAAC,GAAGN,iCAAiC,CAAC2B,WAAW,CAAC;;EAEvF,MAAMO,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAGY,IAAI,CAACC,GAAG,CAAC,CAAAC,GAAG,KAAIA,GAAG,CAACf,IAAI,CAAC,CAAC,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC;EACxD,MAAMd,UAAU,GAAGT,MAAM,GAAI,KAAIvB,aAAa,CAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE,EAAC,GAAG,EAAE;;EAEvE,MAAMG,IAAI,GAAI;AAClB;AACA,+BAA+BZ,WAAY;AAC3C;AACA,gCAAgCO,SAAU,KAAIG,SAAU,GAAEC,UAAW;AACrE;AACA;AACA,CAAC;EACG,MAAME,aAAa;EACjB7C,aAAa,CAACqD,iBAAiB,EAAEvD,IAAI,CAAC4D,GAAG,CAAC,IAAI1D,aAAa,CAACqD,iBAAiB,EAAEvD,IAAI,CAAC6D,GAAG,CAAC;EAC1F5B,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,iEAAiEhC,OAAQ;AACzE;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAER,aAAa;AACrC;AAAA,CACC2B,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC,CAAC1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,CAAC;AAC7EiB,OAAO,CAAC,YAAY,EAAEhC,MAAM,CAACyB,YAAY,CAAC,CAAC;AAC3CQ,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACnC;AAAA,CACCmB,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC9B,cAAc,CAACoB,YAAY,CAACU,CAAC,CAAC6B,UAAU,CAAC,CAAC,IAAI7B,CAAC,CAACkB,KAAK,IAAI,CAAC;AAC5E,CAAC;AACAhB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEC,WAAW,EAAE4B,UAAU,EAAEX,KAAK,CAAC,CAAC,GAAGlB,CAAC,CAACL,MAAM;EACnD,MAAMf,aAAa,GAAGU,YAAY,CAACuC,UAAU,CAAC;EAC9C,MAAMN,IAAI,GAAG,CAAC3C,aAAa,CAAC6B,MAAM,CAACS,KAAK,CAAC,CAAC;EAC1C,MAAM;IACJzC,aAAa;IACbK,gBAAgB;IAChBF,aAAa,EAAEkD;EACjB,CAAC,GAAGxD,iCAAiC,CAAC2B,WAAW,CAAC;;EAElD,MAAMO,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAGW,IAAI,CAACC,GAAG,CAAC,CAAAC,GAAG,KAAIA,GAAG,CAACf,IAAI,CAAC,CAAC,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC;;EAEzD,MAAMb,IAAI,GAAI;AAClB;AACA,+BAA+BZ,WAAY;AAC3C;AACA,gCAAgCO,SAAU,GAAEG,SAAU,KAAIC,UAAW;AACrE;AACA;AACA,CAAC;EACG,MAAME,aAAa;EACjB7C,aAAa,CAACW,aAAa,EAAEkD,kBAAmB,CAAC,IAAIZ,KAAK,IAAI,CAAC,CAAC,IAAIA,KAAK,IAAI,CAAC;EAChFlB,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,2BAA2B,CAAC;AAChCC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,iEAAiEhC,OAAQ;AACzE;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAER,aAAa,CAAC;AACrCQ,OAAO,CAAC,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACnC;AAAA,CACCmB,MAAM,CAAC,CAAAhB,CAAC,KAAI,CAAC,CAAC1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa;AACjF,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEC,WAAW,EAAE8B,OAAO,CAAC,CAAC,GAAG/B,CAAC,CAACL,MAAM;EACzC,MAAM,EAAElB,aAAa,EAAEK,gBAAgB,EAAEF,aAAa,CAAC,CAAC;EACtDN,iCAAiC,CAAC2B,WAAW,CAAC;;EAEhD,MAAMO,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAI,GAAEhC,aAAc,IAAGmD,OAAQ,GAAE;;EAEjD,MAAMlB,IAAI,GAAI;AAClB;AACA,+BAA+BZ,WAAY;AAC3C,wCAAwCrB,aAAc;AACtD;AACA;AACA,YAAYA,aAAa,CAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE;AAC5C,gCAAgCF,SAAU,GAAEG,SAAU,KAAIC,UAAW;AACrE;AACA;AACA,CAAC;EACG,MAAME,aAAa,GAAGiB,OAAO,KAAK,GAAG;EACrC/B,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,kBAAkB,CAAC;AACvBC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,iBAAiBhC,OAAQ;AACzB;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAER,aAAa,CAAC;AACrCQ,OAAO,CAAC,YAAY,EAAEhC,MAAM,CAACO,0CAA0C,CAAC,CAAC;AACzE2B,MAAM,CAAC,QAAQ,EAAE,CAAAC,CAAC;AACjB1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;AACzF;AACJ,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEC,WAAW,EAAE+B,UAAU,EAAE7B,MAAM,CAAC,CAAC,GAAGH,CAAC,CAACL,MAAM;EACpD,MAAM,EAAElB,aAAa,EAAEK,gBAAgB,EAAEF,aAAa,CAAC,CAAC;EACtDN,iCAAiC,CAAC2B,WAAW,CAAC;;EAEhD,MAAMO,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAGT,MAAM,GAAI,KAAIvB,aAAa,EAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE,EAAC,GAAG,EAAE;;EAEvE,MAAMuB,MAAM,GAAG7D,0CAA0C,CAAC4D,UAAU,CAAC;EACrE,MAAMnB,IAAI,GAAI;AAClB,EAAEoB,MAAM,CAACpB,IAAK;AACd;AACA,+BAA+BZ,WAAY;AAC3C;AACA;AACA,4BAA4BO,SAAU,GAAEG,SAAU,GAAEC,UAAW;AAC/D,EAAE;EACEZ,CAAC,CAACe,mBAAmB,CAACkB,MAAM,CAACnB,aAAa,EAAED,IAAI,CAAC;AACnD,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,cAAc,CAAC;AACnBC,OAAO,CAAC,qDAAqD,CAAC;AAC9DC,IAAI;EACF;AACL,4DAA4DhC,OAAQ;AACpE;AACE,CAAC;AACAiC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,iBAAiB,EAAExB,iBAAiB,CAAC;AAC7CwB,OAAO,CAAC,aAAa,EAAEhC,MAAM,CAACS,iCAAiC,CAAC,CAAC;AACjEyB,MAAM,CAAC,QAAQ,EAAE,CAAAC,CAAC;AACjB1B,iCAAiC,CAAC0B,CAAC,CAACC,WAAW,CAAC,CAACrB,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;AACzF;AACJ,CAAC;AACAsB,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAM,EAAEkC,eAAe,EAAEjC,WAAW,EAAEE,MAAM,CAAC,CAAC,GAAGH,CAAC,CAACL,MAAM;EACzD,MAAM,EAAElB,aAAa,EAAEG,aAAa,EAAEE,gBAAgB,CAAC,CAAC;EACtDR,iCAAiC,CAAC2B,WAAW,CAAC;;EAEhD,MAAMO,SAAS,GAAG/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAChD,MAAMC,SAAS,GAAG7B,gBAAgB,GAAG,KAAK,GAAG,EAAE;EAC/C,MAAM8B,UAAU,GAAGT,MAAM,GAAI,KAAIvB,aAAa,EAAE6B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE,EAAC,GAAG,EAAE;;EAEvE,MAAMG,IAAI,GAAI;AAClB;AACA,+BAA+BqB,eAAgB;AAC/C;AACA,gCAAgC1B,SAAU,GAAEG,SAAU,GAAEC,UAAW;AACnE;AACA;AACA,CAAC;;EAEG,MAAMuB,KAAK,GAAG7D,iCAAiC,CAAC4D,eAAe,CAAC;EAChE,MAAME,UAAU,GAAGD,KAAK;EACpBA,KAAK,CAAC1D,aAAa,KAAKA,aAAa;EACrC0D,KAAK,CAACrD,gBAAgB,KAAKA,gBAAgB;EAC1CqB,MAAM,GAAGgC,KAAK,CAACvD,aAAa,KAAKA,aAAa,GAAG,IAAI,CAAC;EACvD,KAAK;;EAET,MAAMkC,aAAa,GAAGoB,eAAe,KAAKjC,WAAW,IAAImC,UAAU;EACnEpC,CAAC,CAACe,mBAAmB,CAACD,aAAa,EAAED,IAAI,CAAC;AAC5C,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,UAAU,CAAC;AACfE,IAAI,CAAC,oCAAoC,CAAC;AAC1CC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,CAAU,CAAC,CAAC;AACrDK,EAAE,CAAC,CAAAF,CAAC,KAAI;EACP,MAAMa,IAAI,GAAI;AAClB;AACA;AACA;AACA,QAAQb,CAAC,CAACL,MAAM,CAAC0C,GAAG,GAAG,KAAK,GAAG,EAAG;AAClC,MAAM;EACFrC,CAAC,CAACe,mBAAmB,CAACf,CAAC,CAACL,MAAM,CAAC0C,GAAG,EAAExB,IAAI,CAAC;AAC3C,CAAC,CAAC"}
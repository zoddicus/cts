{"version":3,"file":"atomics.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kAtomicOps","add","src","sub","max","min","and","or","xor","load","store","exchange","compareexchangeweak","test","specURL","desc","params","u","combine","fn","t","atomicOp","code","stage","pass","expectCompileResult"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/atomics.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for atomic builtins.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kAtomicOps = {\n  add: { src: 'atomicAdd(&a,1)' },\n  sub: { src: 'atomicSub(&a,1)' },\n  max: { src: 'atomicMax(&a,1)' },\n  min: { src: 'atomicMin(&a,1)' },\n  and: { src: 'atomicAnd(&a,1)' },\n  or: { src: 'atomicOr(&a,1)' },\n  xor: { src: 'atomicXor(&a,1)' },\n  load: { src: 'atomicLoad(&a)' },\n  store: { src: 'atomicStore(&a,1)' },\n  exchange: { src: 'atomicExchange(&a,1)' },\n  compareexchangeweak: { src: 'atomicCompareExchangeWeak(&a,1,1)' },\n};\n\ng.test('stage')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-rmw')\n  .desc(\n    `\nAtomic built-in functions must not be used in a vertex shader stage.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', ['fragment', 'vertex', 'compute'] as const) //\n      .combine('atomicOp', keysOf(kAtomicOps))\n  )\n  .fn(t => {\n    const atomicOp = kAtomicOps[t.params.atomicOp].src;\n    let code = `\n@group(0) @binding(0) var<storage, read_write> a: atomic<i32>;\n`;\n\n    switch (t.params.stage) {\n      case 'compute':\n        code += `\n@compute @workgroup_size(1,1,1) fn main() {\n  ${atomicOp};\n}`;\n        break;\n\n      case 'fragment':\n        code += `\n@fragment fn main() -> @location(0) vec4<f32> {\n  ${atomicOp};\n  return vec4<f32>();\n}`;\n        break;\n\n      case 'vertex':\n        code += `\n@vertex fn vmain() -> @builtin(position) vec4<f32> {\n  ${atomicOp};\n  return vec4<f32>();\n}`;\n        break;\n    }\n\n    const pass = t.params.stage !== 'vertex';\n    t.expectCompileResult(pass, code);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,kDAAkD;AAChF,SAASC,MAAM,QAAQ,8CAA8C;AACrE,SAASC,oBAAoB,QAAQ,oCAAoC;;AAEzE,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,oBAAoB,CAAC;;AAEpD,MAAME,UAAU,GAAG;EACjBC,GAAG,EAAE,EAAEC,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BC,GAAG,EAAE,EAAED,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BE,GAAG,EAAE,EAAEF,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BG,GAAG,EAAE,EAAEH,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BI,GAAG,EAAE,EAAEJ,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BK,EAAE,EAAE,EAAEL,GAAG,EAAE,gBAAgB,CAAC,CAAC;EAC7BM,GAAG,EAAE,EAAEN,GAAG,EAAE,iBAAiB,CAAC,CAAC;EAC/BO,IAAI,EAAE,EAAEP,GAAG,EAAE,gBAAgB,CAAC,CAAC;EAC/BQ,KAAK,EAAE,EAAER,GAAG,EAAE,mBAAmB,CAAC,CAAC;EACnCS,QAAQ,EAAE,EAAET,GAAG,EAAE,sBAAsB,CAAC,CAAC;EACzCU,mBAAmB,EAAE,EAAEV,GAAG,EAAE,mCAAmC,CAAC;AAClE,CAAC;;AAEDH,CAAC,CAACc,IAAI,CAAC,OAAO,CAAC;AACZC,OAAO,CAAC,wCAAwC,CAAC;AACjDC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,OAAO,EAAE,CAAC,UAAU,EAAE,QAAQ,EAAE,SAAS,CAAU,CAAC,CAAC;AAAA,CAC7DA,OAAO,CAAC,UAAU,EAAErB,MAAM,CAACG,UAAU,CAAC;AAC3C,CAAC;AACAmB,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,QAAQ,GAAGrB,UAAU,CAACoB,CAAC,CAACJ,MAAM,CAACK,QAAQ,CAAC,CAACnB,GAAG;EAClD,IAAIoB,IAAI,GAAI;AAChB;AACA,CAAC;;EAEG,QAAQF,CAAC,CAACJ,MAAM,CAACO,KAAK;IACpB,KAAK,SAAS;MACZD,IAAI,IAAK;AACjB;AACA,IAAID,QAAS;AACb,EAAE;MACM;;IAEF,KAAK,UAAU;MACbC,IAAI,IAAK;AACjB;AACA,IAAID,QAAS;AACb;AACA,EAAE;MACM;;IAEF,KAAK,QAAQ;MACXC,IAAI,IAAK;AACjB;AACA,IAAID,QAAS;AACb;AACA,EAAE;MACM;EACJ;;EAEA,MAAMG,IAAI,GAAGJ,CAAC,CAACJ,MAAM,CAACO,KAAK,KAAK,QAAQ;EACxCH,CAAC,CAACK,mBAAmB,CAACD,IAAI,EAAEF,IAAI,CAAC;AACnC,CAAC,CAAC"}
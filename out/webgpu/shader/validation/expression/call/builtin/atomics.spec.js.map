{"version":3,"file":"atomics.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kAtomicOps","add","a","sub","max","min","and","or","xor","load","store","exchange","compareexchangeweak","test","specURL","desc","params","u","combine","fn","t","atomicOp","code","stage","pass","expectCompileResult","generateAtomicCode","type","access","aspace","style","op","moduleVar","functionVar","param","aParam","aspaceParam","beginSubcases","filter","skipIfLanguageFeatureNotSupported","aspaceOK","accessOK","dataValue","dataType","atomicType","expect","returnType","atomic","decl","addrspace"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/atomics.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for atomic builtins.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ninterface stringToString {\n  (a: string): string;\n}\n\nconst kAtomicOps: Record<string, stringToString> = {\n  add: (a: string): string => {\n    return `atomicAdd(${a},1)`;\n  },\n  sub: (a: string): string => {\n    return `atomicSub(${a},1)`;\n  },\n  max: (a: string): string => {\n    return `atomicMax(${a},1)`;\n  },\n  min: (a: string): string => {\n    return `atomicMin(${a},1)`;\n  },\n  and: (a: string): string => {\n    return `atomicAnd(${a},1)`;\n  },\n  or: (a: string): string => {\n    return `atomicOr(${a},1)`;\n  },\n  xor: (a: string): string => {\n    return `atomicXor(${a},1)`;\n  },\n  load: (a: string): string => {\n    return `atomicLoad(${a})`;\n  },\n  store: (a: string): string => {\n    return `atomicStore(${a},1)`;\n  },\n  exchange: (a: string): string => {\n    return `atomicExchange(${a},1)`;\n  },\n  compareexchangeweak: (a: string): string => {\n    return `atomicCompareExchangeWeak(${a},1,1)`;\n  },\n};\n\ng.test('stage')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-rmw')\n  .desc(\n    `\nAtomic built-in functions must not be used in a vertex shader stage.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', ['fragment', 'vertex', 'compute'] as const) //\n      .combine('atomicOp', keysOf(kAtomicOps))\n  )\n  .fn(t => {\n    const atomicOp = kAtomicOps[t.params.atomicOp](`&a`);\n    let code = `\n@group(0) @binding(0) var<storage, read_write> a: atomic<i32>;\n`;\n\n    switch (t.params.stage) {\n      case 'compute':\n        code += `\n@compute @workgroup_size(1,1,1) fn main() {\n  ${atomicOp};\n}`;\n        break;\n\n      case 'fragment':\n        code += `\n@fragment fn main() -> @location(0) vec4<f32> {\n  ${atomicOp};\n  return vec4<f32>();\n}`;\n        break;\n\n      case 'vertex':\n        code += `\n@vertex fn vmain() -> @builtin(position) vec4<f32> {\n  ${atomicOp};\n  return vec4<f32>();\n}`;\n        break;\n    }\n\n    const pass = t.params.stage !== 'vertex';\n    t.expectCompileResult(pass, code);\n  });\n\nfunction generateAtomicCode(\n  type: string,\n  access: string,\n  aspace: string,\n  style: string,\n  op: string\n): string {\n  let moduleVar = ``;\n  let functionVar = ``;\n  let param = ``;\n  let aParam = ``;\n  if (style === 'var') {\n    aParam = `&a`;\n    switch (aspace) {\n      case 'storage':\n        moduleVar = `@group(0) @binding(0) var<storage, ${access}> a : atomic<${type}>;\\n`;\n        break;\n      case 'workgroup':\n        moduleVar = `var<workgroup> a : atomic<${type}>;\\n`;\n        break;\n      case 'uniform':\n        moduleVar = `@group(0) @binding(0) var<uniform> a : atomic<${type}>;\\n`;\n        break;\n      case 'private':\n        moduleVar = `var<private> a : atomic<${type}>;\\n`;\n        break;\n      case 'function':\n        functionVar = `var a : atomic<${type}>;\\n`;\n        break;\n      default:\n        break;\n    }\n  } else {\n    const aspaceParam = aspace === 'storage' ? `, ${access}` : ``;\n    param = `p : ptr<${aspace}, atomic<${type}>${aspaceParam}>`;\n    aParam = `p`;\n  }\n\n  return `\n${moduleVar}\nfn foo(${param}) {\n  ${functionVar}\n  ${kAtomicOps[op](aParam)};\n}\n`;\n}\n\ng.test('atomic_parameterization')\n  .desc('Tests the valid atomic parameters')\n  .params(u =>\n    u\n      .combine('op', keysOf(kAtomicOps))\n      .beginSubcases()\n      .combine('aspace', ['storage', 'workgroup', 'private', 'uniform', 'function'] as const)\n      .combine('access', ['read', 'read_write'] as const)\n      .combine('type', ['i32', 'u32'] as const)\n      .combine('style', ['param', 'var'] as const)\n      .filter(t => {\n        switch (t.aspace) {\n          case 'uniform':\n            return t.style === 'param' && t.access === 'read';\n          case 'workgroup':\n            return t.access === 'read_write';\n          case 'function':\n          case 'private':\n            return t.style === 'param' && t.access === 'read_write';\n          default:\n            return true;\n        }\n      })\n  )\n  .fn(t => {\n    if (\n      t.params.style === 'param' &&\n      !(t.params.aspace === 'function' || t.params.aspace === 'private')\n    ) {\n      t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n    }\n\n    const aspaceOK = t.params.aspace === 'storage' || t.params.aspace === 'workgroup';\n    const accessOK = t.params.access === 'read_write';\n    t.expectCompileResult(\n      aspaceOK && accessOK,\n      generateAtomicCode(\n        t.params.type,\n        t.params.access,\n        t.params.aspace,\n        t.params.style,\n        t.params.op\n      )\n    );\n  });\n\ng.test('data_parameters')\n  .desc('Validates that data parameters must match atomic type (or be implicitly convertible)')\n  .params(u =>\n    u\n      .combine('op', [\n        'atomicStore',\n        'atomicAdd',\n        'atomicSub',\n        'atomicMax',\n        'atomicMin',\n        'atomicAnd',\n        'atomicOr',\n        'atomicXor',\n        'atomicExchange',\n        'atomicCompareExchangeWeak1',\n        'atomicCompareExchangeWeak2',\n      ] as const)\n      .beginSubcases()\n      .combine('atomicType', ['i32', 'u32'] as const)\n      .combine('dataType', ['i32', 'u32', 'f32', 'AbstractInt'] as const)\n  )\n  .fn(t => {\n    let dataValue = '';\n    switch (t.params.dataType) {\n      case 'i32':\n        dataValue = '1i';\n        break;\n      case 'u32':\n        dataValue = '1u';\n        break;\n      case 'f32':\n        dataValue = '1f';\n        break;\n      case 'AbstractInt':\n        dataValue = '1';\n        break;\n    }\n    let op = '';\n    switch (t.params.op) {\n      case 'atomicCompareExchangeWeak1':\n        op = `atomicCompareExchangeWeak(&a, ${dataValue}, 1)`;\n        break;\n      case 'atomicCompareExchangeWeak2':\n        op = `atomicCompareExchangeWeak(&a, 1, ${dataValue})`;\n        break;\n      default:\n        op = `${t.params.op}(&a, ${dataValue})`;\n        break;\n    }\n    const code = `\nvar<workgroup> a : atomic<${t.params.atomicType}>;\nfn foo() {\n  ${op};\n}\n`;\n\n    const expect = t.params.atomicType === t.params.dataType || t.params.dataType === 'AbstractInt';\n    t.expectCompileResult(expect, code);\n  });\n\ng.test('return_types')\n  .desc('Validates return types of atomics')\n  .params(u =>\n    u\n      .combine('op', keysOf(kAtomicOps))\n      .beginSubcases()\n      .combine('atomicType', ['i32', 'u32'] as const)\n      .combine('returnType', ['i32', 'u32', 'f32'] as const)\n  )\n  .fn(t => {\n    let op = `${kAtomicOps[t.params.op]('&a')}`;\n    switch (t.params.op) {\n      case 'compareexchangeweak':\n        op = `let tmp : ${t.params.returnType} = ${op}.old_value`;\n        break;\n      default:\n        op = `let tmp : ${t.params.returnType} = ${op}`;\n        break;\n    }\n    const code = `\nvar<workgroup> a : atomic<${t.params.atomicType}>;\nfn foo() {\n  ${op};\n}\n`;\n\n    const expect = t.params.atomicType === t.params.returnType && t.params.op !== 'store';\n    t.expectCompileResult(expect, code);\n  });\n\ng.test('non_atomic')\n  .desc('Test that non-atomic integers are rejected by all atomic functions.')\n  .params(u =>\n    u\n      .combine('op', keysOf(kAtomicOps))\n      .combine('addrspace', ['storage', 'workgroup'] as const)\n      .combine('type', ['i32', 'u32'])\n      .combine('atomic', [true, false])\n  )\n  .fn(t => {\n    let type = t.params.type;\n    if (t.params.atomic) {\n      type = `atomic<${type}>`;\n    }\n\n    let decl = '';\n    if (t.params.addrspace === 'storage') {\n      decl = `@group(0) @binding(0) var<storage, read_write> a : ${type}`;\n    } else if (t.params.addrspace === 'workgroup') {\n      decl = `var<workgroup> a : ${type}`;\n    }\n\n    const op = `${kAtomicOps[t.params.op]('&a')}`;\n    const code = `\n${decl};\nfn foo() {\n  ${op};\n}\n`;\n\n    t.expectCompileResult(t.params.atomic, code);\n  });\n"],"mappings":"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"}
{"version":3,"file":"const_override_validation.js","names":["assert","unreachable","kValue","Type","elementTypeOf","isAbstractType","scalarElementsOf","scalarTypeOf","scalarF16Range","scalarF32Range","scalarF64Range","linearRange","linearRangeBigInt","quantizeToF32","quantizeToF16","rangeForType","number_range","bigint_range","type","kind","minusTwoToTwoRangeForType","minusThreePiToThreePiRangeForType","Math","PI","sparseMinusThreePiToThreePiRangeForType","kConstantAndOverrideStages","stageSupportsType","stage","validateConstOrOverrideBuiltinEval","t","builtin","expectedResult","args","returnType","elTys","map","arg","enables","some","ty","f16","optionalVarType","toString","expectCompileResult","wgsl","join","constants","overrideDecls","callArgs","numOverrides","argOverrides","el","name","push","Number","value","expectPipelineResult","code","reference","validateConstOrOverrideBinaryOpEval","binaryOp","leftStage","left","rightStage","right","allArgs","codeLines","addOperand","elName","leftOperand","rightOperand","fullRangeForType","count","undefined","pos_sub","ceil","pos_norm","i32","negative","min","positive","max","f","floor","u32","i64","unique","arrays","set","Set","arr","item","add","ConstantOrOverrideValueChecker","allChecksPassed","floatLimits","quantizeFn","constructor","f32","v","quantize","isAmbiguousOverflow","isFinite","abs","pow","emax","isNearZero","checkedResult","skip","quantizedValue","checkedResultBigInt","isOOB","skipIfCheckFails"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/const_override_validation.ts"],"sourcesContent":["import { assert, unreachable } from '../../../../../../common/util/util.js';\nimport { kValue } from '../../../../../util/constants.js';\nimport {\n  ScalarType,\n  Type,\n  Value,\n  elementTypeOf,\n  isAbstractType,\n  scalarElementsOf,\n  scalarTypeOf,\n} from '../../../../../util/conversion.js';\nimport {\n  scalarF16Range,\n  scalarF32Range,\n  scalarF64Range,\n  linearRange,\n  linearRangeBigInt,\n  quantizeToF32,\n  quantizeToF16,\n  QuantizeFunc,\n} from '../../../../../util/math.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\n/** @returns a function that can select between ranges depending on type */\nexport function rangeForType(\n  number_range: readonly number[],\n  bigint_range: readonly bigint[]\n): (type: Type) => readonly (number | bigint)[] {\n  return (type: Type): readonly (number | bigint)[] => {\n    switch (scalarTypeOf(type).kind) {\n      case 'abstract-float':\n      case 'f32':\n      case 'f16':\n        return number_range;\n      case 'abstract-int':\n        return bigint_range;\n    }\n    unreachable(`Received unexpected type '${type}'`);\n  };\n}\n\n/* @returns a linear sweep between -2 to 2 for type */\n// prettier-ignore\nexport const minusTwoToTwoRangeForType = rangeForType(\n  linearRange(-2, 2, 10),\n  [ -2n, -1n, 0n, 1n, 2n ]\n);\n\n/* @returns array of values ranging from -3π to 3π, with a focus on multiples of π */\nexport const minusThreePiToThreePiRangeForType = rangeForType(\n  [\n    -3 * Math.PI,\n    -2.999 * Math.PI,\n\n    -2.501 * Math.PI,\n    -2.5 * Math.PI,\n    -2.499 * Math.PI,\n\n    -2.001 * Math.PI,\n    -2.0 * Math.PI,\n    -1.999 * Math.PI,\n\n    -1.501 * Math.PI,\n    -1.5 * Math.PI,\n    -1.499 * Math.PI,\n\n    -1.001 * Math.PI,\n    -1.0 * Math.PI,\n    -0.999 * Math.PI,\n\n    -0.501 * Math.PI,\n    -0.5 * Math.PI,\n    -0.499 * Math.PI,\n\n    -0.001,\n    0,\n    0.001,\n\n    0.499 * Math.PI,\n    0.5 * Math.PI,\n    0.501 * Math.PI,\n\n    0.999 * Math.PI,\n    1.0 * Math.PI,\n    1.001 * Math.PI,\n\n    1.499 * Math.PI,\n    1.5 * Math.PI,\n    1.501 * Math.PI,\n\n    1.999 * Math.PI,\n    2.0 * Math.PI,\n    2.001 * Math.PI,\n\n    2.499 * Math.PI,\n    2.5 * Math.PI,\n    2.501 * Math.PI,\n\n    2.999 * Math.PI,\n    3 * Math.PI,\n  ],\n  [-2n, -1n, 0n, 1n, 2n]\n);\n\n/**\n * @returns a minimal array of values ranging from -3π to 3π, with a focus on\n * multiples of π.\n *\n * Used when multiple parameters are being passed in, so the number of cases\n * becomes the square or more of this list. */\nexport const sparseMinusThreePiToThreePiRangeForType = rangeForType(\n  [\n    -3 * Math.PI,\n    -2.5 * Math.PI,\n    -2.0 * Math.PI,\n    -1.5 * Math.PI,\n    -1.0 * Math.PI,\n    -0.5 * Math.PI,\n    0,\n    0.5 * Math.PI,\n    Math.PI,\n    1.5 * Math.PI,\n    2.0 * Math.PI,\n    2.5 * Math.PI,\n    3 * Math.PI,\n  ],\n  [-2n, -1n, 0n, 1n, 2n]\n);\n\n/// The evaluation stages to test\nexport const kConstantAndOverrideStages = ['constant', 'override'] as const;\n\nexport type ConstantOrOverrideStage = 'constant' | 'override';\nexport type ExecutionStage = 'constant' | 'override' | 'runtime';\n\n/**\n * @returns true if evaluation stage `stage` supports expressions of type @p.\n */\nexport function stageSupportsType(stage: ConstantOrOverrideStage, type: Type) {\n  if (stage === 'override' && isAbstractType(elementTypeOf(type))) {\n    // Abstract numerics are concretized before being used in an override expression.\n    return false;\n  }\n  return true;\n}\n\n/**\n * Runs a validation test to check that evaluation of `builtin` either evaluates with or without\n * error at shader creation time or pipeline creation time.\n * @param t the ShaderValidationTest\n * @param builtin the name of the builtin\n * @param expectedResult false if an error is expected, true if no error is expected\n * @param args the arguments to pass to the builtin\n * @param stage the evaluation stage\n * @param returnType the explicit return type of the result variable, if provided (implicit otherwise)\n */\nexport function validateConstOrOverrideBuiltinEval(\n  t: ShaderValidationTest,\n  builtin: string,\n  expectedResult: boolean,\n  args: Value[],\n  stage: ConstantOrOverrideStage,\n  returnType?: Type\n) {\n  const elTys = args.map(arg => elementTypeOf(arg.type));\n  const enables = elTys.some(ty => ty === Type.f16) ? 'enable f16;' : '';\n  const optionalVarType = returnType ? `: ${returnType.toString()}` : '';\n\n  switch (stage) {\n    case 'constant': {\n      t.expectCompileResult(\n        expectedResult,\n        `${enables}\nconst v ${optionalVarType} = ${builtin}(${args.map(arg => arg.wgsl()).join(', ')});`\n      );\n      break;\n    }\n    case 'override': {\n      assert(!elTys.some(ty => isAbstractType(ty)));\n      const constants: Record<string, number> = {};\n      const overrideDecls: string[] = [];\n      const callArgs: string[] = [];\n      let numOverrides = 0;\n      for (const arg of args) {\n        const argOverrides: string[] = [];\n        for (const el of scalarElementsOf(arg)) {\n          const name = `o${numOverrides++}`;\n          overrideDecls.push(`override ${name} : ${el.type};`);\n          argOverrides.push(name);\n          constants[name] = Number(el.value);\n        }\n        callArgs.push(`${arg.type}(${argOverrides.join(', ')})`);\n      }\n      t.expectPipelineResult({\n        expectedResult,\n        code: `${enables}\n${overrideDecls.join('\\n')}\nvar<private> v ${optionalVarType} = ${builtin}(${callArgs.join(', ')});`,\n        constants,\n        reference: ['v'],\n      });\n      break;\n    }\n  }\n}\n\n/**\n * Runs a validation test to check that evaluation of `binaryOp` either evaluates with or without\n * error at shader creation time or pipeline creation time.\n * @param t the ShaderValidationTest\n * @param binaryOp the symbol of the binary operator\n * @param expectedResult false if an error is expected, true if no error is expected\n * @param leftStage the evaluation stage for the left argument\n * @param left the left-hand side of the binary operation\n * @param rightStage the evaluation stage for the right argument\n * @param right the right-hand side of the binary operation\n */\nexport function validateConstOrOverrideBinaryOpEval(\n  t: ShaderValidationTest,\n  binaryOp: string,\n  expectedResult: boolean,\n  leftStage: ExecutionStage,\n  left: Value,\n  rightStage: ExecutionStage,\n  right: Value\n) {\n  const allArgs = [left, right];\n  const elTys = allArgs.map(arg => elementTypeOf(arg.type));\n  const enables = elTys.some(ty => ty === Type.f16) ? 'enable f16;' : '';\n\n  const codeLines = [enables];\n  const constants: Record<string, number> = {};\n  let numOverrides = 0;\n\n  function addOperand(name: string, stage: ExecutionStage, value: Value) {\n    switch (stage) {\n      case 'runtime':\n        assert(!isAbstractType(value.type));\n        codeLines.push(`var<private> ${name} = ${value.wgsl()};`);\n        return name;\n\n      case 'constant':\n        codeLines.push(`const ${name} = ${value.wgsl()};`);\n        return name;\n\n      case 'override': {\n        assert(!isAbstractType(value.type));\n        const argOverrides: string[] = [];\n        for (const el of scalarElementsOf(value)) {\n          const elName = `o${numOverrides++}`;\n          codeLines.push(`override ${elName} : ${el.type};`);\n          constants[elName] = Number(el.value);\n          argOverrides.push(elName);\n        }\n        return `${value.type}(${argOverrides.join(', ')})`;\n      }\n    }\n  }\n\n  const leftOperand = addOperand('left', leftStage, left);\n  const rightOperand = addOperand('right', rightStage, right);\n\n  if (leftStage === 'override' || rightStage === 'override') {\n    t.expectPipelineResult({\n      expectedResult,\n      code: codeLines.join('\\n'),\n      constants,\n      reference: [`${leftOperand} ${binaryOp} ${rightOperand}`],\n    });\n  } else {\n    codeLines.push(`fn f() { _ = ${leftOperand} ${binaryOp} ${rightOperand}; }`);\n    t.expectCompileResult(expectedResult, codeLines.join('\\n'));\n  }\n}\n/** @returns a sweep of the representable values for element type of `type` */\nexport function fullRangeForType(type: Type, count?: number): readonly (number | bigint)[] {\n  if (count === undefined) {\n    count = 25;\n  }\n  switch (scalarTypeOf(type)?.kind) {\n    case 'abstract-float':\n      return scalarF64Range({\n        pos_sub: Math.ceil((count * 1) / 5),\n        pos_norm: Math.ceil((count * 4) / 5),\n      });\n    case 'f32':\n      return scalarF32Range({\n        pos_sub: Math.ceil((count * 1) / 5),\n        pos_norm: Math.ceil((count * 4) / 5),\n      });\n    case 'f16':\n      return scalarF16Range({\n        pos_sub: Math.ceil((count * 1) / 5),\n        pos_norm: Math.ceil((count * 4) / 5),\n      });\n    case 'i32':\n      return linearRange(kValue.i32.negative.min, kValue.i32.positive.max, count).map(f =>\n        Math.floor(f)\n      );\n    case 'u32':\n      return linearRange(0, kValue.u32.max, count).map(f => Math.floor(f));\n    case 'abstract-int':\n      // Returned values are already ints, so don't need to be floored.\n      return linearRangeBigInt(kValue.i64.negative.min, kValue.i64.positive.max, count);\n  }\n  unreachable();\n}\n\n/** @returns all the values in the provided arrays with duplicates removed */\nexport function unique<T>(...arrays: Array<readonly T[]>): T[] {\n  const set = new Set<T>();\n  for (const arr of arrays) {\n    for (const item of arr) {\n      set.add(item);\n    }\n  }\n  return [...set];\n}\n\ninterface FloatLimits {\n  positive: {\n    max: number;\n    min: number;\n  };\n  negative: {\n    max: number;\n    min: number;\n  };\n  emax: number;\n}\n\n/**\n * Provides an easy way to validate steps in an equation that will trigger a validation error with\n * constant or override values due to overflow/underflow. Typical call pattern is:\n *\n * const vCheck = new ConstantOrOverrideValueChecker(t, Type.f32);\n * const c = vCheck.checkedResult(a + b);\n * const d = vCheck.checkedResult(c * c);\n * const expectedResult = vCheck.allChecksPassed();\n */\nexport class ConstantOrOverrideValueChecker {\n  #allChecksPassed = true;\n  #floatLimits?: FloatLimits;\n  #quantizeFn: QuantizeFunc<number>;\n\n  constructor(\n    private t: ShaderValidationTest,\n    type: ScalarType\n  ) {\n    switch (type) {\n      case Type.f32:\n        this.#quantizeFn = quantizeToF32;\n        this.#floatLimits = kValue.f32;\n        break;\n      case Type.f16:\n        this.#quantizeFn = quantizeToF16;\n        this.#floatLimits = kValue.f16;\n        break;\n      default:\n        this.#quantizeFn = (v: number) => v;\n        break;\n    }\n  }\n\n  quantize(value: number): number {\n    return this.#quantizeFn(value);\n  }\n\n  // Some overflow floating point values may fall into an abiguously rounded scenario, where they\n  // can either round up to Infinity or down to the maximum representable value. In these cases the\n  // test should be skipped, because it's valid for implementations to differ.\n  // See: https://www.w3.org/TR/WGSL/#floating-point-overflow\n  isAmbiguousOverflow(value: number): boolean {\n    // Non-finite values are not ambiguous, and can still be validated.\n    if (!Number.isFinite(value)) {\n      return false;\n    }\n\n    // Values within the min/max range for the given type are not ambiguous.\n    if (\n      !this.#floatLimits ||\n      (value <= this.#floatLimits.positive.max && value >= this.#floatLimits.negative.min)\n    ) {\n      return false;\n    }\n\n    // If a value falls outside the min/max range, check to see if it is under\n    // 2^(EMAX(T)+1). If so, the rounding behavior is implementation specific,\n    // and should not be validated.\n    return Math.abs(value) < Math.pow(2, this.#floatLimits.emax + 1);\n  }\n\n  // Returns true if the value may be quantized to zero with the given type.\n  isNearZero(value: number): boolean {\n    if (!Number.isFinite(value)) {\n      return false;\n    }\n    if (!this.#floatLimits) {\n      return value === 0;\n    }\n\n    return value < this.#floatLimits.positive.min && value > this.#floatLimits.negative.max;\n  }\n\n  checkedResult(value: number): number {\n    if (this.isAmbiguousOverflow(value)) {\n      this.t.skip(`Checked value, ${value}, was within the ambiguous overflow rounding range.`);\n    }\n\n    const quantizedValue = this.quantize(value);\n    if (!Number.isFinite(quantizedValue)) {\n      this.#allChecksPassed = false;\n    }\n    return quantizedValue;\n  }\n\n  checkedResultBigInt(value: bigint): bigint {\n    if (kValue.i64.isOOB(value)) {\n      this.#allChecksPassed = false;\n    }\n    return value;\n  }\n\n  skipIfCheckFails(value: number): number {\n    if (this.isAmbiguousOverflow(value)) {\n      this.t.skip(`Checked value, ${value}, was within the ambiguous overflow rounding range.`);\n    }\n\n    const quantizedValue = this.quantize(value);\n    if (!Number.isFinite(quantizedValue)) {\n      this.t.skip(`Checked value, ${value}, was not finite after quantization.`);\n    }\n    return value;\n  }\n\n  allChecksPassed(): boolean {\n    return this.#allChecksPassed;\n  }\n}\n"],"mappings":"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"}
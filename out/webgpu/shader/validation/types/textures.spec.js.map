{"version":3,"file":"textures.spec.js","names":["description","makeTestGroup","isTextureFormatUsableAsStorageFormat","kAllTextureFormats","kColorTextureFormats","kTextureFormatInfo","getPlainTypeInfo","ShaderValidationTest","g","test","desc","params","u","combine","filter","p","format","color","storage","beginSubcases","beforeAllSubcases","t","shaderScalarType","selectDeviceOrSkipTestCase","requiredFeatures","isCompatibility","skip","fn","info","validShaderScalarType","type","shaderValueType","wgsl","expectCompileResult","kValidTextureSampledTypes","textureType","sampledType","includes","kAccessModes","access","isFormatValid","depth","stencil","isAccessValid"],"sources":["../../../../../src/webgpu/shader/validation/types/textures.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for various texture types in shaders.\n\nTODO:\n- Sampled Texture Types\n- Multisampled Texture Types\n- External Sampled Texture Types\n- Depth Texture Types\n- Sampler Types\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  isTextureFormatUsableAsStorageFormat,\n  kAllTextureFormats,\n  kColorTextureFormats,\n  kTextureFormatInfo,\n} from '../../../format_info.js';\nimport { getPlainTypeInfo } from '../../../util/shader.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('texel_formats')\n  .desc(\n    'Test channels and channel format of various texel formats when using as the storage texture format'\n  )\n  .params(u =>\n    u\n      .combine('format', kColorTextureFormats)\n      .filter(p => kTextureFormatInfo[p.format].color.storage)\n      .beginSubcases()\n      .combine('shaderScalarType', ['f32', 'u32', 'i32', 'bool', 'f16'] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.shaderScalarType === 'f16') {\n      t.selectDeviceOrSkipTestCase({ requiredFeatures: ['shader-f16'] });\n    }\n\n    if (!isTextureFormatUsableAsStorageFormat(t.params.format, t.isCompatibility)) {\n      t.skip('storage usage is unsupported');\n    }\n  })\n  .fn(t => {\n    const { format, shaderScalarType } = t.params;\n    const info = kTextureFormatInfo[format];\n    const validShaderScalarType = getPlainTypeInfo(info.color.type);\n    const shaderValueType = `vec4<${shaderScalarType}>`;\n    const wgsl = `\n    @group(0) @binding(0) var tex: texture_storage_2d<${format}, read>;\n    @compute @workgroup_size(1) fn main() {\n        let v : ${shaderValueType} = textureLoad(tex, vec2u(0));\n        _ = v;\n    }\n`;\n    t.expectCompileResult(validShaderScalarType === shaderScalarType, wgsl);\n  });\n\ng.test('texel_formats,as_value')\n  .desc('Test that texel format cannot be used as value')\n  .fn(t => {\n    const wgsl = `\n    @compute @workgroup_size(1) fn main() {\n        var i = rgba8unorm;\n    }\n`;\n    t.expectCompileResult(false, wgsl);\n  });\n\nconst kValidTextureSampledTypes = ['f32', 'i32', 'u32'];\n\ng.test('sampled_texture_types')\n  .desc(\n    `Test that for texture_xx<T>\n- The sampled type T must be f32, i32, or u32\n`\n  )\n  .params(u =>\n    u\n      .combine('textureType', ['texture_2d', 'texture_multisampled_2d'])\n      .beginSubcases()\n      .combine('sampledType', [\n        ...kValidTextureSampledTypes,\n        'bool',\n        'vec2',\n        'mat2x2',\n        '1.0',\n        '1',\n        '1u',\n      ] as const)\n  )\n  .fn(t => {\n    const { textureType, sampledType } = t.params;\n    const wgsl = `@group(0) @binding(0) var tex: ${textureType}<${sampledType}>;`;\n    t.expectCompileResult(kValidTextureSampledTypes.includes(sampledType), wgsl);\n  });\n\nconst kAccessModes = ['read', 'write', 'read_write'];\n\ng.test('storage_texture_types')\n  .desc(\n    `Test that for texture_storage_xx<format, access>\n- format must be an enumerant for one of the texel formats for storage textures\n- access must be an enumerant for one of the access modes\n\nBesides, the shader compilation should always pass regardless of whether the format supports the usage indicated by the access or not.\n`\n  )\n  .params(u =>\n    u.combine('access', [...kAccessModes, 'storage'] as const).combine('format', kAllTextureFormats)\n  )\n  .fn(t => {\n    const { format, access } = t.params;\n    const info = kTextureFormatInfo[format];\n    // bgra8unorm is considered a valid storage format at shader compilation stage\n    const isFormatValid =\n      info.color?.storage ||\n      info.depth?.storage ||\n      info.stencil?.storage ||\n      format === 'bgra8unorm';\n    const isAccessValid = kAccessModes.includes(access);\n    const wgsl = `@group(0) @binding(0) var tex: texture_storage_2d<${format}, ${access}>;`;\n    t.expectCompileResult(isFormatValid && isAccessValid, wgsl);\n  });\n"],"mappings":"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"}
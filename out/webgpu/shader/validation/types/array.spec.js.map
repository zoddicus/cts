{"version":3,"file":"array.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kValidCases","i32","u32","f32","f16","bool","vec2u","vec3i","vec4f","array","struct","mat2x2f","mat4x4h","atomicu","atomici","literal_count","literali_count","literalu_count","const_count","const_expr_count1","const_expr_count2","override_count","override_expr1","override_expr2","override_zero","override_neg","same_const_value1","same_const_value2","same_const_value3","same_override","shadow","test","desc","params","u","combine","beforeAllSubcases","t","code","case","indexOf","selectDeviceOrSkipTestCase","fn","skipIf","hasLanguageFeature","expectCompileResult","kInvalidCases","f16_without_enable","runtime_nested","override_nested","override_nested_struct","zero_size","negative_size","const_zero","const_neg","incompatible_overrides"],"sources":["../../../../../src/webgpu/shader/validation/types/array.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for array types\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kValidCases = {\n  // Basic element types.\n  i32: `alias T = array<i32>;`,\n  u32: `alias T = array<u32>;`,\n  f32: `alias T = array<f32>;`,\n  f16: `enable f16;\\nalias T = array<f16>;`,\n  bool: `alias T = array<bool>;`,\n\n  // Composite elements\n  vec2u: `alias T = array<vec2u>;`,\n  vec3i: `alias T = array<vec3i>;`,\n  vec4f: `alias T = array<vec4f>;`,\n  array: `alias T = array<array<u32, 4>>;`,\n  struct: `struct S { x : u32 }\\nalias T = array<S>;`,\n  mat2x2f: `alias T = array<mat2x2f>;`,\n  mat4x4h: `enable f16;\\nalias T = array<mat4x4h>;`,\n\n  // Atomic elements\n  atomicu: `alias T = array<atomic<u32>>;`,\n  atomici: `alias T = array<atomic<i32>>;`,\n\n  // Count expressions\n  literal_count: `alias T = array<u32, 4>;`,\n  literali_count: `alias T = array<u32, 4i>;`,\n  literalu_count: `alias T = array<u32, 4u>;`,\n  const_count: `const x = 8;\\nalias T = array<u32, x>;`,\n  const_expr_count1: `alias T = array<u32, 1 + 3>;`,\n  const_expr_count2: `const x = 4;\\nalias T = array<u32, x * 2>;`,\n  override_count: `override x : u32;\\nalias T = array<u32, x>;`,\n  override_expr1: `override x = 2;\\nalias T = array<u32, vec2(x,x).x>;`,\n  override_expr2: `override x = 1;\\nalias T = array<u32, x + 1>;`,\n  override_zero: `override x = 0;\\nalias T = array<u32, x>;`,\n  override_neg: `override x = -1;\\nalias T = array<u32, x>;`,\n\n  // Same array types\n  same_const_value1: `\n    const x = 8;\n    const y = 8;\n    var<private> v : array<u32, x> = array<u32, y>();`,\n  same_const_value2: `\n    const x = 8;\n    var<private> v : array<u32, x> = array<u32, 8>();`,\n  same_const_value3: `\n    var<private> v : array<u32, 8i> = array<u32, 8u>();`,\n  same_override: `\n    requires unrestricted_pointer_parameters;\n    override x : u32;\n    var<workgroup> v : array<u32, x>;\n    fn bar(p : ptr<workgroup, array<u32, x>>) { }\n    fn foo() { bar(&v); }`,\n\n  // Shadow\n  shadow: `alias array = vec2f;`,\n};\n\ng.test('valid')\n  .desc('Valid array type tests')\n  .params(u => u.combine('case', keysOf(kValidCases)))\n  .beforeAllSubcases(t => {\n    const code = kValidCases[t.params.case];\n    if (code.indexOf('f16') >= 0) {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const code = kValidCases[t.params.case];\n    t.skipIf(\n      code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n      'Test requires unrestricted_pointer_parameters'\n    );\n    t.expectCompileResult(true, code);\n  });\n\nconst kInvalidCases = {\n  f16_without_enable: `alias T = array<f16>;`,\n  runtime_nested: `alias T = array<array<u32>, 4>;`,\n  override_nested: `\n    override x : u32;\n    alias T = array<array<u32, x>, 4>;`,\n  override_nested_struct: `\n    override x : u32;\n    struct T { x : array<u32, x> }`,\n  zero_size: `alias T = array<u32, 0>;`,\n  negative_size: `alias T = array<u32, 1 - 2>;`,\n  const_zero: `const x = 0;\\nalias T = array<u32, x>;`,\n  const_neg: `const x = 1;\\nconst y = 2;\\nalias T = array<u32, x - y>;`,\n  incompatible_overrides: `\n    requires unrestricted_pointer_parameters;\n    override x = 8;\n    override y = 8;\n    var<workgroup> v : array<u32, x>\n    fn bar(p : ptr<workgroup, array<u32 y>>) { }\n    fn foo() { bar(&v); }`,\n};\n\ng.test('invalid')\n  .desc('Invalid array type tests')\n  .params(u => u.combine('case', keysOf(kInvalidCases)))\n  .beforeAllSubcases(t => {\n    const code = kInvalidCases[t.params.case];\n    if (code.indexOf('f16') >= 0) {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const code = kInvalidCases[t.params.case];\n    t.skipIf(\n      code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n      'Test requires unrestricted_pointer_parameters'\n    );\n    t.expectCompileResult(false, code);\n  });\n"],"mappings":"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"}
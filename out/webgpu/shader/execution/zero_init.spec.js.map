{"version":3,"file":"zero_init.spec.js","names":["description","makeTestGroup","iterRange","unreachable","GPUTest","kVectorContainerTypes","kMatrixContainerTypes","supportedScalarTypes","supportsAtomics","prettyPrint","t","type","containerType","elementType","length","members","map","m","join","scalarType","isAtomic","g","test","desc","params","u","combine","expand","storageClass","beginSubcases","expandWithParams","p","kElementCounts","kMemberCounts","memoizedTypes","generateTypesMemo","depth","undefined","Array","from","generateTypes","access","storageMode","_containerDepth","vectorType","matrixType","innerTypes","elementCount","innerType","memberCount","memberIndices","memberTypes","reverse","seenTypes","Set","typeIndex","prevTypeIndex","serializedT","has","push","shift","add","shaderTypeParam","_type","batch","fn","moduleScope","functionScope","declaredStructTypes","Map","typeDecl","ensureType","typeName","get","member","i","set","checkZeroCode","checkZero","value","indexOf","cols","rows","expected","wgsl","workgroupSize","wg_memory_limits","device","limits","maxComputeWorkgroupStorageSize","wg_x_dim","maxComputeWorkgroupSizeX","fillPipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","x","GPUBufferUsage","STORAGE","COPY_DST","trackForCleanup","outputBuffer","createBuffer","size","usage","COPY_SRC","bg","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","e","createCommandEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","pipeline","resultBuffer","zeroBuffer","UNIFORM","bindGroup","encoder","pass","expectGPUBufferValuesEqual"],"sources":["../../../../src/webgpu/shader/execution/zero_init.spec.ts"],"sourcesContent":["export const description = `Test that variables in the shader are zero initialized`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange, unreachable } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport {\n  ScalarType,\n  kVectorContainerTypes,\n  kVectorContainerTypeInfo,\n  kMatrixContainerTypes,\n  kMatrixContainerTypeInfo,\n  supportedScalarTypes,\n  supportsAtomics,\n} from '../types.js';\n\ntype ShaderTypeInfo =\n  | { type: 'container'; containerType: 'array'; elementType: ShaderTypeInfo; length: number }\n  | { type: 'container'; containerType: 'struct'; members: ShaderTypeInfo[] }\n  | {\n      type: 'container';\n      containerType: keyof typeof kVectorContainerTypeInfo | keyof typeof kMatrixContainerTypeInfo;\n      scalarType: ScalarType;\n    }\n  | { type: 'scalar'; scalarType: ScalarType; isAtomic: boolean };\n\nfunction prettyPrint(t: ShaderTypeInfo): string {\n  switch (t.type) {\n    case 'container':\n      switch (t.containerType) {\n        case 'array':\n          return `array<${prettyPrint(t.elementType)}, ${t.length}>`;\n        case 'struct':\n          return `struct { ${t.members.map(m => prettyPrint(m)).join(', ')} }`;\n        default:\n          return `${t.containerType}<${prettyPrint({\n            type: 'scalar',\n            scalarType: t.scalarType,\n            isAtomic: false,\n          })}>`;\n      }\n      break;\n    case 'scalar':\n      if (t.isAtomic) {\n        return `atomic<${t.scalarType}>`;\n      }\n      return t.scalarType;\n  }\n}\n\nexport const g = makeTestGroup(GPUTest);\ng.test('compute,zero_init')\n  .desc(\n    `Test that uninitialized variables in workgroup, private, and function storage classes are initialized to zero.`\n  )\n  .params(u =>\n    u\n      // Only workgroup, function, and private variables can be declared without data bound to them.\n      // The implementation's shader translator should ensure these values are initialized.\n      .combine('storageClass', ['workgroup', 'private', 'function'] as const)\n      .expand('workgroupSize', ({ storageClass }) => {\n        switch (storageClass) {\n          case 'workgroup':\n            return [\n              [1, 1, 1],\n              [1, 32, 1],\n              [64, 1, 1],\n              [1, 1, 48],\n              [1, 47, 1],\n              [33, 1, 1],\n              [1, 1, 63],\n              [8, 8, 2],\n              [7, 7, 3],\n            ];\n          case 'function':\n          case 'private':\n            return [[1, 1, 1]];\n        }\n      })\n      .beginSubcases()\n      // Fewer subcases: Only 0 and 2. If double-nested containers work, single-nested should too.\n      .combine('_containerDepth', [0, 2])\n      .expandWithParams(function* (p) {\n        const kElementCounts = [\n          [], // Not used. Depth 0 is always scalars.\n          [1, 3, 67], // Test something above the workgroup size.\n          [1, 3],\n        ] as const;\n        const kMemberCounts = [1, 3] as const;\n\n        const memoizedTypes: ShaderTypeInfo[][] = [];\n\n        function generateTypesMemo(depth: number): ShaderTypeInfo[] {\n          if (memoizedTypes[depth] === undefined) {\n            memoizedTypes[depth] = Array.from(generateTypes(depth));\n          }\n          return memoizedTypes[depth];\n        }\n\n        function* generateTypes(depth: number): Generator<ShaderTypeInfo> {\n          if (depth === 0) {\n            for (const isAtomic of supportsAtomics({\n              ...p,\n              access: 'read_write',\n              storageMode: undefined,\n              containerType: 'scalar',\n            })\n              ? [true, false]\n              : [false]) {\n              for (const scalarType of supportedScalarTypes({ isAtomic, ...p })) {\n                // Fewer subcases: For nested types, skip atomic u32 and non-atomic i32.\n                if (p._containerDepth > 0) {\n                  if (scalarType === 'u32' && isAtomic) continue;\n                  if (scalarType === 'i32' && !isAtomic) continue;\n                }\n\n                yield {\n                  type: 'scalar',\n                  scalarType,\n                  isAtomic,\n                };\n                if (!isAtomic) {\n                  // Vector types\n                  for (const vectorType of kVectorContainerTypes) {\n                    // Fewer subcases: For nested types, only include\n                    // vec2<u32>, vec3<i32>, and vec4<f32>\n                    if (p._containerDepth > 0) {\n                      if (\n                        !(\n                          (vectorType === 'vec2' && scalarType === 'u32') ||\n                          (vectorType === 'vec3' && scalarType === 'i32') ||\n                          (vectorType === 'vec4' && scalarType === 'f32')\n                        )\n                      ) {\n                        continue;\n                      }\n                    }\n                    yield {\n                      type: 'container',\n                      containerType: vectorType,\n                      scalarType,\n                    };\n                  }\n                  // Matrices can only be f32.\n                  if (scalarType === 'f32') {\n                    for (const matrixType of kMatrixContainerTypes) {\n                      yield {\n                        type: 'container',\n                        containerType: matrixType,\n                        scalarType,\n                      };\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n\n          for (const containerType of ['array', 'struct']) {\n            const innerTypes = generateTypesMemo(depth - 1);\n            switch (containerType) {\n              case 'array':\n                for (const elementCount of kElementCounts[depth]) {\n                  for (const innerType of innerTypes) {\n                    yield {\n                      type: 'container',\n                      containerType,\n                      elementType: innerType,\n                      length: elementCount,\n                    };\n                  }\n                }\n                break;\n              case 'struct':\n                for (const memberCount of kMemberCounts) {\n                  const memberIndices = new Array(memberCount);\n                  for (let m = 0; m < memberCount; ++m) {\n                    memberIndices[m] = m;\n                  }\n\n                  // Don't generate all possible combinations of inner struct members,\n                  // because that's in the millions. Instead, just round-robin through\n                  // to pick member types. Loop through the types, concatenated forward\n                  // and backward, three times to produce a bounded but variable set of\n                  // types.\n                  const memberTypes = [...innerTypes, ...[...innerTypes].reverse()];\n                  const seenTypes = new Set();\n                  let typeIndex = 0;\n                  while (typeIndex < memberTypes.length * 3) {\n                    const prevTypeIndex = typeIndex;\n                    const members: ShaderTypeInfo[] = [];\n                    for (const m of memberIndices) {\n                      members[m] = memberTypes[typeIndex % memberTypes.length];\n                      typeIndex += 1;\n                    }\n\n                    const t: ShaderTypeInfo = {\n                      type: 'container',\n                      containerType,\n                      members,\n                    };\n                    const serializedT = prettyPrint(t);\n                    if (seenTypes.has(serializedT)) {\n                      // We produced an identical type. shuffle the member indices,\n                      // \"revert\" typeIndex back to where it was before this loop, and\n                      // shift it by one. This helps ensure we don't loop forever, and\n                      // that we produce a different type on the next iteration.\n                      memberIndices.push(memberIndices.shift());\n                      typeIndex = prevTypeIndex + 1;\n                      continue;\n                    }\n                    seenTypes.add(serializedT);\n                    yield t;\n                  }\n                }\n                break;\n            }\n          }\n        }\n\n        for (const t of generateTypesMemo(p._containerDepth)) {\n          yield {\n            shaderTypeParam: prettyPrint(t),\n            _type: t,\n          };\n        }\n      })\n  )\n  .batch(15)\n  .fn(t => {\n    let moduleScope = `\n      struct Output {\n        failed : atomic<u32>\n      }\n      @group(0) @binding(0) var<storage, read_write> output : Output;\n\n      // This uniform value that's a zero is used to prevent the shader compilers from trying to\n      // unroll the massive loops generated by these tests.\n      @group(0) @binding(1) var<uniform> zero : u32;\n    `;\n    let functionScope = '';\n\n    const declaredStructTypes = new Map<ShaderTypeInfo, string>();\n    const typeDecl = (function ensureType(\n      typeName: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `array<${ensureType(\n                `${typeName}_ArrayElement`,\n                type.elementType,\n                depth + 1\n              )}, ${type.length}>`;\n            case 'struct': {\n              if (declaredStructTypes.has(type)) {\n                return declaredStructTypes.get(type)!;\n              }\n\n              const members = type.members\n                .map((member, i) => {\n                  return `\\n    member${i} : ${ensureType(\n                    `${typeName}_Member${i}`,\n                    member,\n                    depth + 1\n                  )},`;\n                })\n                .join('');\n              declaredStructTypes.set(type, typeName);\n              moduleScope += `\\nstruct ${typeName} {`;\n              moduleScope += members;\n              moduleScope += '\\n};';\n\n              return typeName;\n            }\n            default:\n              return `${type.containerType}<${ensureType(\n                typeName,\n                {\n                  type: 'scalar',\n                  scalarType: type.scalarType,\n                  isAtomic: false,\n                },\n                depth + 1\n              )}>`;\n          }\n          break;\n        case 'scalar':\n          return type.isAtomic ? `atomic<${type.scalarType}>` : type.scalarType;\n      }\n    })('TestType', t.params._type);\n\n    switch (t.params.storageClass) {\n      case 'workgroup':\n      case 'private':\n        moduleScope += `\\nvar<${t.params.storageClass}> testVar: ${typeDecl};`;\n        break;\n      case 'function':\n        functionScope += `\\nvar testVar: ${typeDecl};`;\n        break;\n    }\n\n    const checkZeroCode = (function checkZero(\n      value: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `\\nfor (var i${depth} = 0u; i${depth} < ${\n                type.length\n              }u + zero; i${depth} = i${depth} + 1u) {\n                ${checkZero(`${value}[i${depth}]`, type.elementType, depth + 1)}\n              }`;\n            case 'struct':\n              return type.members\n                .map((member, i) => {\n                  return checkZero(`${value}.member${i}`, member, depth + 1);\n                })\n                .join('\\n');\n            default:\n              if (type.containerType.indexOf('vec') !== -1) {\n                const length = type.containerType[3];\n                return `\\nfor (var i${depth} = 0u; i${depth} < ${length}u + zero; i${depth} = i${depth} + 1u) {\n                  ${checkZero(\n                    `${value}[i${depth}]`,\n                    {\n                      type: 'scalar',\n                      scalarType: type.scalarType,\n                      isAtomic: false,\n                    },\n                    depth + 1\n                  )}\n                }`;\n              } else if (type.containerType.indexOf('mat') !== -1) {\n                const cols = type.containerType[3];\n                const rows = type.containerType[5];\n                return `\\nfor (var c${depth} = 0u; c${depth} < ${cols}u + zero; c${depth} = c${depth} + 1u) {\n                  for (var r${depth} = 0u; r${depth} < ${rows}u; r${depth} = r${depth} + 1u) {\n                    ${checkZero(\n                      `${value}[c${depth}][r${depth}]`,\n                      {\n                        type: 'scalar',\n                        scalarType: type.scalarType,\n                        isAtomic: false,\n                      },\n                      depth + 1\n                    )}\n                  }\n                }`;\n              } else {\n                unreachable();\n              }\n          }\n          break;\n        case 'scalar': {\n          let expected;\n          switch (type.scalarType) {\n            case 'bool':\n              expected = 'false';\n              break;\n            case 'f32':\n              expected = '0.0';\n              break;\n            case 'i32':\n              expected = '0';\n              break;\n            case 'u32':\n              expected = '0u';\n              break;\n          }\n          if (type.isAtomic) {\n            value = `atomicLoad(&${value})`;\n          }\n\n          // Note: this could have an early return, but we omit it because it makes\n          // the tests fail cause with DXGI_ERROR_DEVICE_HUNG on Windows.\n          return `\\nif (${value} != ${expected}) { atomicStore(&output.failed, 1u); }`;\n        }\n      }\n    })('testVar', t.params._type);\n\n    const wgsl = `\n      ${moduleScope}\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main() {\n        ${functionScope}\n        ${checkZeroCode}\n        _ = zero;\n      }\n    `;\n\n    if (t.params.storageClass === 'workgroup') {\n      // Populate the maximum amount of workgroup memory with known values to\n      // ensure initialization overrides in another shader.\n      const wg_memory_limits = t.device.limits.maxComputeWorkgroupStorageSize;\n      const wg_x_dim = t.device.limits.maxComputeWorkgroupSizeX;\n\n      const wgsl = `\n      @group(0) @binding(0) var<storage, read> inputs : array<u32>;\n      @group(0) @binding(1) var<storage, read_write> outputs : array<u32>;\n      var<workgroup> wg_mem : array<u32, ${wg_memory_limits} / 4>;\n\n      @compute @workgroup_size(${wg_x_dim})\n      fn fill(@builtin(local_invocation_index) lid : u32) {\n        const num_u32_per_invocation = ${wg_memory_limits} / (4 * ${wg_x_dim});\n\n        for (var i = 0u; i < num_u32_per_invocation; i++) {\n          let idx = num_u32_per_invocation * lid + i;\n          wg_mem[idx] = inputs[idx];\n        }\n        workgroupBarrier();\n        // Copy out to avoid wg_mem being elided.\n        for (var i = 0u; i < num_u32_per_invocation; i++) {\n          let idx = num_u32_per_invocation * lid + i;\n          outputs[idx] = wg_mem[idx];\n        }\n      }\n      `;\n\n      const fillPipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: {\n          module: t.device.createShaderModule({\n            code: wgsl,\n          }),\n          entryPoint: 'fill',\n        },\n      });\n\n      const inputBuffer = t.makeBufferWithContents(\n        new Uint32Array([...iterRange(wg_memory_limits / 4, x => 0xdeadbeef)]),\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n      );\n      t.trackForCleanup(inputBuffer);\n      const outputBuffer = t.device.createBuffer({\n        size: wg_memory_limits,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });\n      t.trackForCleanup(outputBuffer);\n\n      const bg = t.device.createBindGroup({\n        layout: fillPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: inputBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: {\n              buffer: outputBuffer,\n            },\n          },\n        ],\n      });\n\n      const e = t.device.createCommandEncoder();\n      const p = e.beginComputePass();\n      p.setPipeline(fillPipeline);\n      p.setBindGroup(0, bg);\n      p.dispatchWorkgroups(1);\n      p.end();\n      t.queue.submit([e.finish()]);\n    }\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const resultBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(resultBuffer);\n\n    const zeroBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n    t.trackForCleanup(zeroBuffer);\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: resultBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: zeroBuffer,\n          },\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n  });\n"],"mappings":"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"}
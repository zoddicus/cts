{"version":3,"file":"coherence.spec.js","names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildTestShader","MemoryType","TestType","buildResultShader","ResultType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numBehaviors","storageMemoryCorrTestCode","workgroupStorageMemoryCorrTestCode","storageMemoryCorrRMWTestCode","workgroupStorageMemoryCorrRMWTestCode","workgroupMemoryCorrTestCode","workgroupMemoryCorrRMWTestCode","test","desc","paramsSimple","memType","AtomicStorageClass","testType","InterWorkgroup","_testCode","extraFlags","IntraWorkgroup","AtomicWorkgroupClass","fn","t","resultCode","testShader","params","resultShader","FourBehavior","memModelTester","run","storageMemoryCowwTestCode","storageMemoryCowwRMWTestCode","workgroupMemoryCowwTestCode","workgroupMemoryCowwRMWTestCode","TwoBehavior","storageMemoryCowrTestCode","workgroupStorageMemoryCowrTestCode","storageMemoryCowrRMWTestCode","workgroupStorageMemoryCowrRMWTestCode","workgroupMemoryCowrTestCode","workgroupMemoryCowrRMWTestCode","storageMemoryCorw1TestCode","workgroupStorageMemoryCorw1TestCode","workgroupMemoryCorw1TestCode","storageMemoryCorw2TestCode","workgroupStorageMemoryCorw2TestCode","storageMemoryCorw2RMWTestCode","workgroupStorageMemoryCorw2RMWTestCode","workgroupMemoryCorw2TestCode","workgroupMemoryCorw2RMWTestCode"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/coherence.spec.ts"],"sourcesContent":["export const description = `\nTests that all threads see a sequentially consistent view of the order of memory\naccesses to a single memory location. Uses a parallel testing strategy along with stressing\nthreads to increase coverage of possible bugs.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildTestShader,\n  MemoryType,\n  TestType,\n  buildResultShader,\n  ResultType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 39,\n  maxWorkgroups: 952,\n  shufflePct: 0,\n  barrierPct: 0,\n  memStressPct: 0,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 0,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 1,\n  memStride: 1,\n  aliasedMemory: true,\n  numBehaviors: 4,\n};\n\nconst storageMemoryCorrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicLoad(&test_locations.value[y_1]);\n  atomicStore(&results.value[id_1].r0, r0);\n  atomicStore(&results.value[id_1].r1, r1);\n`;\n\nconst workgroupStorageMemoryCorrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicLoad(&test_locations.value[y_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst storageMemoryCorrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicAdd(&test_locations.value[y_1], 0u);\n  atomicStore(&results.value[id_1].r0, r0);\n  atomicStore(&results.value[id_1].r1, r1);\n`;\n\nconst workgroupStorageMemoryCorrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  let r1 = atomicAdd(&test_locations.value[y_1], 0u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst workgroupMemoryCorrTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  let r1 = atomicLoad(&wg_test_locations[y_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst workgroupMemoryCorrRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  let r1 = atomicAdd(&wg_test_locations[y_1], 0u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\ng.test('corr')\n  .desc(\n    `Ensures two reads on one thread cannot observe an inconsistent view of a write on a second thread.\n     The first thread writes the value 1 some location x, and the second thread reads x twice in a row.\n     If the first read returns 1 but the second read returns 0, then there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n\nconst storageMemoryCowwTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  atomicStore(&test_locations.value[y_0], 2u);\n`;\n\nconst storageMemoryCowwRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  atomicStore(&test_locations.value[y_0], 2u);\n`;\n\nconst workgroupMemoryCowwTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  atomicStore(&wg_test_locations[y_0], 2u);\n  workgroupBarrier();\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_0], atomicLoad(&wg_test_locations[x_0]));\n`;\n\nconst workgroupMemoryCowwRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  atomicStore(&wg_test_locations[y_0], 2u);\n  workgroupBarrier();\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_0], atomicLoad(&wg_test_locations[x_0]));\n`;\n\ng.test('coww')\n  .desc(\n    `Ensures two writes on one thread do not lead to incoherent results. The thread first writes 1 to\n     some location x and then writes 2 to the same location. If the value in memory after the test finishes\n     is 1, then there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowwTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowwRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if (mem_x_0 == 2u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (mem_x_0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.TwoBehavior);\n    const params = {\n      ...memoryModelTestParams,\n      numBehaviors: 2,\n    };\n    const memModelTester = new MemoryModelTester(t, params, testShader, resultShader);\n    await memModelTester.run(60, 1);\n  });\n\nconst storageMemoryCowrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_0]);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCowrTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_0]);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst storageMemoryCowrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicAdd(&test_locations.value[y_0], 0u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCowrRMWTestCode = `\n  atomicExchange(&test_locations.value[x_0], 1u);\n  let r0 = atomicAdd(&test_locations.value[y_0], 0u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCowrTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[y_0]);\n  atomicStore(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst workgroupMemoryCowrRMWTestCode = `\n  atomicExchange(&wg_test_locations[x_0], 1u);\n  let r0 = atomicAdd(&wg_test_locations[y_0], 0u);\n  atomicExchange(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\ng.test('cowr')\n  .desc(\n    `The first thread first writes 1 to some location x and then reads x. The second thread writes 2 to x.\n     If the first thread reads the value 2 and the value in memory at the end of the test is 1, then the read\n     and write on the first thread have been reordered, a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowrTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCowrRMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 1u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n\nconst storageMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[x_0], 1u);\n  workgroupBarrier();\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCorw1TestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\ng.test('corw1')\n  .desc(\n    `One thread first reads from a memory location x and then writes 1 to x. If the read observes the subsequent\n     write, there has been a coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw1TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw1TestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw1TestCode,\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if (r0 == 0u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (r0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.TwoBehavior);\n    const params = {\n      ...memoryModelTestParams,\n      numBehaviors: 2,\n    };\n    const memModelTester = new MemoryModelTester(t, params, testShader, resultShader);\n    await memModelTester.run(60, 1);\n  });\n\nconst storageMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst storageMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupStorageMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&test_locations.value[x_0]);\n  atomicStore(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryCorw2TestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicStore(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst workgroupMemoryCorw2RMWTestCode = `\n  let r0 = atomicLoad(&wg_test_locations[x_0]);\n  atomicStore(&wg_test_locations[y_0], 1u);\n  atomicExchange(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\ng.test('corw2')\n  .desc(\n    `The first thread reads from some memory location x, and then writes 1 to x. The second thread\n     writes 2 to x. If the first thread reads the value 2, but the value in memory after the test\n     completes is 1, then the instructions on the first thread have been re-ordered, leading to a\n     coherence violation.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupStorageMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw2TestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryCorw2RMWTestCode,\n      extraFlags: 'rmw_variant',\n    },\n  ])\n  .fn(async t => {\n    const resultCode = `\n      if ((r0 == 0u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 2u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(60, 3);\n  });\n"],"mappings":"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"}
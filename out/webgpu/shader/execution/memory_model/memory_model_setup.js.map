{"version":3,"file":"memory_model_setup.js","names":["checkElementsPassPredicate","align","kAccessValueTypes","numMemLocations","numReadOutputs","numStressParams","barrierParamIndex","memStressIndex","memStressIterationsIndex","memStressPatternIndex","preStressIndex","preStressIterationsIndex","preStressPatternIndex","permuteFirstIndex","permuteSecondIndex","testingWorkgroupsIndex","memStrideIndex","memLocationOffsetIndex","bytesPerWord","shaderPreamble","accessValueType","constants","MemoryModelTester","constructor","t","params","testShader","resultShader","test","workgroupXSize","Math","min","workgroupSize","device","limits","maxComputeWorkgroupSizeX","maxWorkgroups","scratchMemorySize","testingThreads","testingWorkgroups","testLocationsSize","memStride","testLocationsBuffer","deviceBuf","createBuffer","label","size","usage","GPUBufferUsage","COPY_DST","STORAGE","srcBuf","COPY_SRC","readResultsSize","readResultsBuffer","testResultsSize","numBehaviors","testResultsBuffer","shuffledWorkgroupsSize","shuffledWorkgroupsBuffer","MAP_WRITE","falseSharingAvoidanceQuantum","barrierSize","scratchpadSize","scratchMemoryLocationsSize","comboSize","comboBuffer","barrierBuffer","offset","scratchpadBuffer","scratchMemoryLocationsBuffer","stressParamsSize","stressParamsBuffer","UNIFORM","buffers","testLocations","readResults","testResults","shuffledWorkgroups","barrier","scratchpad","scratchMemoryLocations","stressParams","testLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","testPipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","testBindGroup","createBindGroup","resource","resultLayout","resultPipeline","resultBindGroup","run","iterations","weakIndex","i","numWorkgroups","getRandomInRange","setShuffledWorkgroups","setScratchLocations","setStressParams","encoder","createCommandEncoder","copyBufferToBuffer","testPass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","resultPass","queue","submit","finish","expectGPUBufferValuesPassCheck","checkWeakIndex","Uint32Array","typedLength","checkResult","resultPrinter","a","predicatePrinter","leftHeader","getValueForCell","v","getRandomInt","max","floor","random","shuffleArray","length","toSwap","temp","mapAsync","GPUMapMode","WRITE","getMappedRange","shuffledWorkgroupsArray","shufflePct","x","unmap","scratchLocationsArrayBuffer","scratchLocationsArray","scratchNumRegions","stressLineSize","scratchRegions","Array","keys","stressTargetLines","region","locInRegion","stressStrategyBalancePct","j","workgroupsPerLocation","stressParamsArrayBuffer","stressParamsArray","barrierPct","memStressPct","memStressIterations","memStressStoreFirst","memStressStoreFirstPct","memStressStoreSecond","memStressStoreSecondPct","memStressPattern","preStressPct","preStressIterations","preStressStoreFirst","preStressStoreFirstPct","preStressStoreSecond","preStressStoreSecondPct","preStressPattern","permuteFirst","permuteSecond","aliasedMemory","shaderMemStructures","fourBehaviorTestResultStructure","twoBehaviorTestResultStructure","commonTestShaderBindings","atomicTestShaderBindings","join","nonAtomicTestShaderBindings","resultShaderBindings","atomicWorkgroupMemory","nonAtomicWorkgroupMemory","memoryLocationFunctions","testShaderFunctions","shaderEntryPoint","testShaderCommonHeader","testShaderCommonCalculations","interWorkgroupTestShaderCode","intraWorkgroupTestShaderCode","storageIntraWorkgroupTestShaderCode","testShaderCommonFooter","resultShaderCommonCalculations","interWorkgroupResultShaderCode","intraWorkgroupResultShaderCode","resultShaderCommonFooter","storageMemoryAtomicTestShaderCode","storageMemoryNonAtomicTestShaderCode","workgroupMemoryAtomicTestShaderCode","workgroupMemoryNonAtomicTestShaderCode","resultShaderCommonCode","MemoryType","TestType","ResultType","buildTestShader","testCode","memoryType","testType","memoryTypeCode","isStorageAS","AtomicStorageClass","NonAtomicStorageClass","AtomicWorkgroupClass","NonAtomicWorkgroupClass","testTypeCode","InterWorkgroup","IntraWorkgroup","buildResultShader","resultCode","resultType","resultStructure","TwoBehavior","FourBehavior"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/memory_model_setup.ts"],"sourcesContent":["import { GPUTest } from '../../../gpu_test';\nimport { checkElementsPassPredicate } from '../../../util/check_contents.js';\nimport { align } from '../../../util/math.js';\n\n/* All buffer sizes are counted in units of 4-byte words. */\n\n/**\n * The value type loaded and stored from memory.\n * This is what the WGSL spec calls 'store type' for the locations being accessed.\n * The GPU buffers are sized assuming this type is at most 4 bytes.\n *\n * 'u32' is the default case; it can be atomically loaded and stored.\n * 'f16' is interesting because it is not 32-bits, and can't be the store type\n * for atomic accesses.\n */\nexport type AccessValueType = 'f16' | 'u32';\nexport const kAccessValueTypes = ['f16', 'u32'] as const;\n\n/* Parameter values are set heuristically, typically by a time-intensive search. */\nexport type MemoryModelTestParams = {\n  /* Number of invocations per workgroup. The workgroups are 1-dimensional. */\n  workgroupSize: number;\n  /** The number of workgroups to assign to running the test. */\n  testingWorkgroups: number;\n  /**\n   * Run no more than this many workgroups. Must be >= the number of testing workgroups. Non-testing workgroups are used\n   * to stress other memory locations.\n   */\n  maxWorkgroups: number;\n  /** The percentage of iterations to shuffle the workgroup ids. */\n  shufflePct: number;\n  /** The percentage of iterations to run the bounded spin-loop barrier. */\n  barrierPct: number;\n  /** The percentage of iterations to run memory stress using non-testing workgroups. */\n  memStressPct: number;\n  /** The number of iterations to run the memory stress pattern. */\n  memStressIterations: number;\n  /** The percentage of iterations the first instruction in the stress pattern should be a store. */\n  memStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the stress pattern should be a store. */\n  memStressStoreSecondPct: number;\n  /** The percentage of iterations for testing threads to run stress before running the test. */\n  preStressPct: number;\n  /** Same as for memStressIterations. */\n  preStressIterations: number;\n  /** The percentage of iterations the first instruction in the pre-stress pattern should be a store. */\n  preStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the pre-stress pattern should be a store. */\n  preStressStoreSecondPct: number;\n  /** The size of the scratch memory region, used for stressing threads. */\n  scratchMemorySize: number;\n  /** The size of each block of memory stressing threads access. */\n  stressLineSize: number;\n  /** The number of blocks of memory to assign stressing threads to. */\n  stressTargetLines: number;\n  /** How non-testing threads are assigned to stressing locations. 100 means all iterations use a round robin approach, 0 means all use a chunking approach. */\n  stressStrategyBalancePct: number;\n  /** Used to permute thread ids within a workgroup, so more random pairings are created between threads coordinating on a test. */\n  permuteFirst: number;\n  /** Used to create distance between memory locations used in a test. Set this to 1 for memory that should be aliased. */\n  permuteSecond: number;\n  /** The distance (in number of 4 byte intervals) between any two memory locations used for testing. */\n  memStride: number;\n  /** For tests that access one memory location, but use dynamic addresses to avoid compiler optimization, aliased memory should be set to true. */\n  aliasedMemory: boolean;\n  /** The number of possible behaviors that a test can have. */\n  numBehaviors: number;\n};\n\n/** The number of memory locations accessed by a test. Currently, only tests with up to 2 memory locations are supported. */\nconst numMemLocations = 2;\n\n/** The number of read outputs per test that need to be analyzed in the result aggregation shader. Currently, only tests with up to 2 read outputs are supported. */\nconst numReadOutputs = 2;\n\n/** Represents a device buffer and a utility buffer for resetting memory and copying parameters. */\ntype BufferWithSource = {\n  /** Buffer used by shader code. */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host side, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of the buffer. */\n  size: number;\n};\n\ntype SubBufferWithSource = {\n  /** Buffer used by shader code. This buffer is shared for multiple used */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host side, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of this portion of the buffer. */\n  size: number;\n  /** Offset in bytes of this portion of the buffer */\n  offset: number;\n};\n\n/** Specifies the buffers used during a memory model test. */\ntype MemoryModelBuffers = {\n  /** This is the memory region that testing threads read from and write to. */\n  testLocations: BufferWithSource;\n  /** This buffer collects the results of reads for analysis in the result aggregation shader. */\n  readResults: BufferWithSource;\n  /** This buffer is the aggregated results of every testing thread, and is used to check for test success/failure. */\n  testResults: BufferWithSource;\n  /** This buffer stores the shuffled workgroup ids for use during testing. Read-only in the shader. */\n  shuffledWorkgroups: BufferWithSource;\n  /** This is the bounded spin-loop barrier, used to temporally align testing threads. */\n  barrier: BufferWithSource;\n  /** Memory region for stressing threads to read to and write from. */\n  scratchpad: BufferWithSource;\n  /** The memory locations in the scratch region that stressing threads access. */\n  scratchMemoryLocations: BufferWithSource;\n  /** Parameters that are used by the shader to calculate memory locations and perform stress. */\n  stressParams: BufferWithSource;\n};\n\n/** The number of stress params to add to the stress params buffer. */\nconst numStressParams = 12;\nconst barrierParamIndex = 0;\nconst memStressIndex = 1;\nconst memStressIterationsIndex = 2;\nconst memStressPatternIndex = 3;\nconst preStressIndex = 4;\nconst preStressIterationsIndex = 5;\nconst preStressPatternIndex = 6;\nconst permuteFirstIndex = 7;\nconst permuteSecondIndex = 8;\nconst testingWorkgroupsIndex = 9;\nconst memStrideIndex = 10;\nconst memLocationOffsetIndex = 11;\n\n/**\n * All memory used in these consists of a four byte word, so this value is used to correctly set the byte size of buffers that\n * are read to/written from during tests and for storing test results.\n */\nconst bytesPerWord = 4;\n\n/**\n * Returns the shader preamble based on the access value type:\n *  - enable directives, if necessary\n *  - the type alias for AccessValueType\n */\nfunction shaderPreamble(accessValueType: AccessValueType, constants: string): string {\n  if (accessValueType === 'f16') {\n    return `enable f16;\\nalias AccessValueTy = f16;\\n${constants}\\n`;\n  }\n  return `alias AccessValueTy = ${accessValueType};\\n${constants}\\n`;\n}\n\n/**\n * Implements setup code necessary to run a memory model test. A test consists of two parts:\n *  1.) A test shader that runs a specified memory model litmus test and attempts to reveal a weak (disallowed) behavior.\n *      At a high level, a test shader consists of a set of testing workgroups where every invocation executes the litmus test\n *      on a set of test locations, and a set of stressing workgroups where every invocation accesses a specified memory location\n *      in a random pattern.\n *\n *      The main buffer variables are:\n *\n *        `test_locations`: invocations access entries in this array, trying to\n *          evoke weak behaviours.\n *\n *          This is array<AccessValueTy> or array<atomic<u32>>.\n *          AccessValueTy is either f16 or u32.\n *          Note that atomic<u32> is only used when AccessValueTy is u32.\n *\n *        `results`: holds the observed values, which is where we can see\n *          whether a weak behaviour was observed.\n *\n *          This is an array<atomic<u32>>.\n *\n *      The others are used to parameterize and stress the main activity.\n *\n *  2.) A result shader that takes the output of the test shader, which consists of the memory locations accessed during the test\n *      and the results of any reads made during the test, and aggregate the results based on the possible behaviors of the test.\n *\n *      The first two buffer variables are the same buffers as for the test shader:\n *\n *        `test_locations` is the same as `test_locations` from the test shader,\n *        but is mapped as array<AccessValueTy>.\n *\n *        `read_results` is the same buffer as `results` from the test shader.\n *\n *      The other variables are used to accumulate a summary that counts the weak behaviours stimulated and recorded by the\n *      test shader.\n */\nexport class MemoryModelTester {\n  protected test: GPUTest;\n  protected params: MemoryModelTestParams;\n  protected buffers: MemoryModelBuffers;\n  protected testPipeline: GPUComputePipeline;\n  protected testBindGroup: GPUBindGroup;\n  protected resultPipeline: GPUComputePipeline;\n  protected resultBindGroup: GPUBindGroup;\n\n  /** Sets up a memory model test by initializing buffers and pipeline layouts. */\n  constructor(\n    t: GPUTest,\n    params: MemoryModelTestParams,\n    testShader: string,\n    resultShader: string,\n    accessValueType: AccessValueType = 'u32'\n  ) {\n    this.test = t;\n    this.params = params;\n\n    const workgroupXSize = Math.min(params.workgroupSize, t.device.limits.maxComputeWorkgroupSizeX);\n    const constants = `\n      const kNumBarriers = 1u;  // MAINTENANCE_TODO: make barrier not an array\n      const kMaxWorkgroups = ${params.maxWorkgroups}u;\n      const kScratchMemorySize = ${params.scratchMemorySize}u;\n      const kWorkgroupXSize = ${workgroupXSize}u;\n    `;\n    testShader = shaderPreamble(accessValueType, constants) + testShader;\n    resultShader = shaderPreamble(accessValueType, constants) + resultShader;\n\n    // set up buffers\n    const testingThreads = workgroupXSize * this.params.testingWorkgroups;\n    const testLocationsSize =\n      testingThreads * numMemLocations * this.params.memStride * bytesPerWord;\n    const testLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'testLocationsBuffer',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'testLocationsSrcBuf',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: testLocationsSize,\n    };\n\n    const readResultsSize = testingThreads * numReadOutputs * bytesPerWord;\n    const readResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'readResultsBuffer',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'readResultsSrcBuf',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: readResultsSize,\n    };\n\n    const testResultsSize = this.params.numBehaviors * bytesPerWord;\n    const testResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'testResultsBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'testResultsSrcBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: testResultsSize,\n    };\n\n    const shuffledWorkgroupsSize = this.params.maxWorkgroups * bytesPerWord;\n    const shuffledWorkgroupsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: shuffledWorkgroupsSize,\n    };\n\n    // Combine 3 arrays into 1 buffer as we need to keep the number of storage buffers to 4 for compat.\n    const falseSharingAvoidanceQuantum = 4096;\n    const barrierSize = align(bytesPerWord, falseSharingAvoidanceQuantum);\n    const scratchpadSize = align(\n      this.params.scratchMemorySize * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const scratchMemoryLocationsSize = align(\n      this.params.maxWorkgroups * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const comboSize = barrierSize + scratchpadSize + scratchMemoryLocationsSize;\n\n    const comboBuffer = this.test.device.createBuffer({\n      label: 'comboBuffer',\n      size: comboSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n\n    const barrierBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'barrierSrcBuf',\n        size: barrierSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: barrierSize,\n      offset: 0,\n    };\n\n    const scratchpadBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'scratchpadSrcBuf',\n        size: scratchpadSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: scratchpadSize,\n      offset: barrierSize,\n    };\n\n    const scratchMemoryLocationsBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'scratchMemoryLocationsSrcBuf',\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: scratchMemoryLocationsSize,\n      offset: barrierSize + scratchpadSize,\n    };\n\n    const stressParamsSize = numStressParams * bytesPerWord;\n    const stressParamsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'stressParamsBuffer',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'stressParamsSrcBuf',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: stressParamsSize,\n    };\n\n    this.buffers = {\n      testLocations: testLocationsBuffer,\n      readResults: readResultsBuffer,\n      testResults: testResultsBuffer,\n      shuffledWorkgroups: shuffledWorkgroupsBuffer,\n      barrier: barrierBuffer,\n      scratchpad: scratchpadBuffer,\n      scratchMemoryLocations: scratchMemoryLocationsBuffer,\n      stressParams: stressParamsBuffer,\n    };\n\n    // set up pipeline layouts\n    const testLayout = this.test.device.createBindGroupLayout({\n      label: 'testLayout',\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.testPipeline = this.test.device.createComputePipeline({\n      label: 'testPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [testLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: testShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.testBindGroup = this.test.device.createBindGroup({\n      label: 'testBindGroup',\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.shuffledWorkgroups.deviceBuf } },\n        { binding: 3, resource: { buffer: comboBuffer } },\n        { binding: 4, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: testLayout,\n    });\n\n    const resultLayout = this.test.device.createBindGroupLayout({\n      label: 'resultLayout',\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.resultPipeline = this.test.device.createComputePipeline({\n      label: 'resultPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [resultLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: resultShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.resultBindGroup = this.test.device.createBindGroup({\n      label: 'resultBindGroup',\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.testResults.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: resultLayout,\n    });\n  }\n\n  /**\n   * Run the test for the specified number of iterations. Checks the testResults buffer on the weakIndex; if\n   * this value is not 0 then the test has failed. The number of iterations is chosen per test so that the\n   * full set of tests meets some time budget while still being reasonably effective at uncovering issues.\n   * Currently, we aim for each test to complete in under one second.\n   */\n  async run(iterations: number, weakIndex: number): Promise<void> {\n    for (let i = 0; i < iterations; i++) {\n      const numWorkgroups = this.getRandomInRange(\n        this.params.testingWorkgroups,\n        this.params.maxWorkgroups\n      );\n      await this.setShuffledWorkgroups(numWorkgroups);\n      await this.setScratchLocations(numWorkgroups);\n      await this.setStressParams();\n      const encoder = this.test.device.createCommandEncoder();\n      this.copyBufferToBuffer(encoder, this.buffers.testLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.readResults);\n      this.copyBufferToBuffer(encoder, this.buffers.testResults);\n      this.copyBufferToBuffer(encoder, this.buffers.barrier);\n      this.copyBufferToBuffer(encoder, this.buffers.shuffledWorkgroups);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchpad);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchMemoryLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.stressParams);\n\n      const testPass = encoder.beginComputePass();\n      testPass.setPipeline(this.testPipeline);\n      testPass.setBindGroup(0, this.testBindGroup);\n      testPass.dispatchWorkgroups(numWorkgroups);\n      testPass.end();\n\n      const resultPass = encoder.beginComputePass();\n      resultPass.setPipeline(this.resultPipeline);\n      resultPass.setBindGroup(0, this.resultBindGroup);\n      resultPass.dispatchWorkgroups(this.params.testingWorkgroups);\n      resultPass.end();\n\n      this.test.device.queue.submit([encoder.finish()]);\n      this.test.expectGPUBufferValuesPassCheck(\n        this.buffers.testResults.deviceBuf,\n        this.checkWeakIndex(weakIndex),\n        {\n          type: Uint32Array,\n          typedLength: this.params.numBehaviors,\n        }\n      );\n    }\n  }\n\n  /** Returns a function that checks whether the test passes, given a weak index and the test results buffer. */\n  protected checkWeakIndex(weakIndex: number): (a: Uint32Array) => Error | undefined {\n    const checkResult = this.checkResult(weakIndex);\n    const resultPrinter = this.resultPrinter(weakIndex);\n    return function (a: Uint32Array): Error | undefined {\n      return checkElementsPassPredicate(a, checkResult, {\n        predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: resultPrinter }],\n      });\n    };\n  }\n\n  /**\n   * Returns a function that checks whether the specified weak index's value is not equal to 0.\n   * If the weak index's value is not 0, it means the test has observed a behavior disallowed by the memory model and\n   * is considered a test failure.\n   */\n  protected checkResult(weakIndex: number): (i: number, v: number) => boolean {\n    return function (i: number, v: number): boolean {\n      if (i === weakIndex && v > 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /** Returns a printer function that visualizes the results of checking the test results. */\n  protected resultPrinter(weakIndex: number): (i: number) => string | number {\n    return function (i: number): string | number {\n      if (i === weakIndex) {\n        return 0;\n      } else {\n        return 'any value';\n      }\n    };\n  }\n\n  /** Utility method that simplifies copying source buffers to device buffers. */\n  protected copyBufferToBuffer(\n    encoder: GPUCommandEncoder,\n    buffer: BufferWithSource | SubBufferWithSource\n  ): void {\n    encoder.copyBufferToBuffer(\n      buffer.srcBuf,\n      0,\n      buffer.deviceBuf,\n      (buffer as SubBufferWithSource).offset || 0,\n      buffer.size\n    );\n  }\n\n  /** Returns a random integer between 0 and the max. */\n  protected getRandomInt(max: number): number {\n    return Math.floor(Math.random() * max);\n  }\n\n  /** Returns a random number in between the min and max values. */\n  protected getRandomInRange(min: number, max: number): number {\n    if (min === max) {\n      return min;\n    } else {\n      const offset = this.getRandomInt(max - min);\n      return min + offset;\n    }\n  }\n\n  /** Returns a permuted array using a simple Fisher-Yates shuffle algorithm. */\n  protected shuffleArray(a: number[]): void {\n    for (let i = a.length - 1; i >= 0; i--) {\n      const toSwap = this.getRandomInt(i + 1);\n      const temp = a[toSwap];\n      a[toSwap] = a[i];\n      a[i] = temp;\n    }\n  }\n\n  /**\n   * Shuffles the order of workgroup ids, so that threads operating on the same memory location are not always in\n   * consecutive workgroups.\n   */\n  protected async setShuffledWorkgroups(numWorkgroups: number): Promise<void> {\n    await this.buffers.shuffledWorkgroups.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const shuffledWorkgroupsBuffer = this.buffers.shuffledWorkgroups.srcBuf.getMappedRange();\n    const shuffledWorkgroupsArray = new Uint32Array(shuffledWorkgroupsBuffer);\n    for (let i = 0; i < numWorkgroups; i++) {\n      shuffledWorkgroupsArray[i] = i;\n    }\n    if (this.getRandomInt(100) < this.params.shufflePct) {\n      for (let i = numWorkgroups - 1; i > 0; i--) {\n        const x = this.getRandomInt(i + 1);\n        const temp = shuffledWorkgroupsArray[i];\n        shuffledWorkgroupsArray[i] = shuffledWorkgroupsArray[x];\n        shuffledWorkgroupsArray[x] = temp;\n      }\n    }\n    this.buffers.shuffledWorkgroups.srcBuf.unmap();\n  }\n\n  /** Sets the memory locations that stressing workgroups will access. Uses either a chunking or round robin assignment strategy. */\n  protected async setScratchLocations(numWorkgroups: number): Promise<void> {\n    await this.buffers.scratchMemoryLocations.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const scratchLocationsArrayBuffer = this.buffers.scratchMemoryLocations.srcBuf.getMappedRange();\n    const scratchLocationsArray = new Uint32Array(scratchLocationsArrayBuffer);\n    const scratchNumRegions = this.params.scratchMemorySize / this.params.stressLineSize;\n    const scratchRegions = [...Array(scratchNumRegions).keys()];\n    this.shuffleArray(scratchRegions);\n    for (let i = 0; i < this.params.stressTargetLines; i++) {\n      const region = scratchRegions[i];\n      const locInRegion = this.getRandomInt(this.params.stressLineSize);\n      if (this.getRandomInt(100) < this.params.stressStrategyBalancePct) {\n        // In the round-robin case, the current scratch location is striped across all workgroups.\n        for (let j = i; j < numWorkgroups; j += this.params.stressTargetLines) {\n          scratchLocationsArray[j] = region * this.params.stressLineSize + locInRegion;\n        }\n      } else {\n        // In the chunking case, the current scratch location is assigned to a block of workgroups. The final scratch\n        // location may be assigned to more workgroups, if the number of scratch locations does not cleanly divide the\n        // number of workgroups.\n        const workgroupsPerLocation = numWorkgroups / this.params.stressTargetLines;\n        for (let j = 0; j < workgroupsPerLocation; j++) {\n          scratchLocationsArray[i * workgroupsPerLocation + j] =\n            region * this.params.stressLineSize + locInRegion;\n        }\n        if (\n          i === this.params.stressTargetLines - 1 &&\n          numWorkgroups % this.params.stressTargetLines !== 0\n        ) {\n          for (let j = 0; j < numWorkgroups % this.params.stressTargetLines; j++) {\n            scratchLocationsArray[numWorkgroups - j - 1] =\n              region * this.params.stressLineSize + locInRegion;\n          }\n        }\n      }\n    }\n    this.buffers.scratchMemoryLocations.srcBuf.unmap();\n  }\n\n  /** Sets the parameters that are used by the shader to calculate memory locations and perform stress. */\n  protected async setStressParams(): Promise<void> {\n    await this.buffers.stressParams.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const stressParamsArrayBuffer = this.buffers.stressParams.srcBuf.getMappedRange();\n    const stressParamsArray = new Uint32Array(stressParamsArrayBuffer);\n    if (this.getRandomInt(100) < this.params.barrierPct) {\n      stressParamsArray[barrierParamIndex] = 1;\n    } else {\n      stressParamsArray[barrierParamIndex] = 0;\n    }\n    if (this.getRandomInt(100) < this.params.memStressPct) {\n      stressParamsArray[memStressIndex] = 1;\n    } else {\n      stressParamsArray[memStressIndex] = 0;\n    }\n    stressParamsArray[memStressIterationsIndex] = this.params.memStressIterations;\n    const memStressStoreFirst = this.getRandomInt(100) < this.params.memStressStoreFirstPct;\n    const memStressStoreSecond = this.getRandomInt(100) < this.params.memStressStoreSecondPct;\n    let memStressPattern;\n    if (memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 0;\n    } else if (memStressStoreFirst && !memStressStoreSecond) {\n      memStressPattern = 1;\n    } else if (!memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 2;\n    } else {\n      memStressPattern = 3;\n    }\n    stressParamsArray[memStressPatternIndex] = memStressPattern;\n    if (this.getRandomInt(100) < this.params.preStressPct) {\n      stressParamsArray[preStressIndex] = 1;\n    } else {\n      stressParamsArray[preStressIndex] = 0;\n    }\n    stressParamsArray[preStressIterationsIndex] = this.params.preStressIterations;\n    const preStressStoreFirst = this.getRandomInt(100) < this.params.preStressStoreFirstPct;\n    const preStressStoreSecond = this.getRandomInt(100) < this.params.preStressStoreSecondPct;\n    let preStressPattern;\n    if (preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 0;\n    } else if (preStressStoreFirst && !preStressStoreSecond) {\n      preStressPattern = 1;\n    } else if (!preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 2;\n    } else {\n      preStressPattern = 3;\n    }\n    stressParamsArray[preStressPatternIndex] = preStressPattern;\n    stressParamsArray[permuteFirstIndex] = this.params.permuteFirst;\n    stressParamsArray[permuteSecondIndex] = this.params.permuteSecond;\n    stressParamsArray[testingWorkgroupsIndex] = this.params.testingWorkgroups;\n    stressParamsArray[memStrideIndex] = this.params.memStride;\n    if (this.params.aliasedMemory) {\n      stressParamsArray[memLocationOffsetIndex] = 0;\n    } else {\n      stressParamsArray[memLocationOffsetIndex] = this.params.memStride;\n    }\n    this.buffers.stressParams.srcBuf.unmap();\n  }\n}\n\n/** Defines common data structures used in memory model test shaders. */\nconst shaderMemStructures = `\n  struct Memory {\n    value: array<AccessValueTy>\n  };\n\n  struct AtomicMemory {\n    value: array<atomic<u32>>\n  };\n\n  struct IndexMemory {\n    value: array<u32>,\n  };\n\n  struct AtomicMemoryBarrier {\n    value: array<atomic<u32>, kNumBarriers>\n  };\n\n  struct IndexMemoryScratchpad {\n    value: array<u32, kMaxWorkgroups>,\n  };\n\n  struct IndexMemoryScratchLocations {\n    value: array<u32, kScratchMemorySize>,\n  };\n\n  struct ReadResult {\n    r0: atomic<u32>,\n    r1: atomic<u32>,\n  };\n\n  struct ReadResults {\n    value: array<ReadResult>,\n  };\n\n  // These arrays are combine into 1 buffer because compat mode only supports 4 storage buffers by default.\n  struct CombinedData {\n    barrier: AtomicMemoryBarrier,\n    scratchpad: IndexMemoryScratchpad,\n    scratch_locations: IndexMemoryScratchLocations,\n  };\n\n  struct StressParamsMemory {\n    do_barrier: u32,\n    mem_stress: u32,\n    mem_stress_iterations: u32,\n    mem_stress_pattern: u32,\n    pre_stress: u32,\n    pre_stress_iterations: u32,\n    pre_stress_pattern: u32,\n    permute_first: u32,\n    permute_second: u32,\n    testing_workgroups: u32,\n    mem_stride: u32,\n    location_offset: u32,\n  };\n`;\n\n/**\n * Structure to hold the counts of occurrences of the possible behaviors of a two-thread, four-instruction test.\n * \"seq0\" means the first invocation's instructions are observed to have occurred before the second invocation's instructions.\n * \"seq1\" means the second invocation's instructions are observed to have occurred before the first invocation's instructions.\n * \"interleaved\" means there was an observation of some interleaving of instructions between the two invocations.\n * \"weak\" means there was an observation of some ordering of instructions that is inconsistent with the WebGPU memory model.\n */\nconst fourBehaviorTestResultStructure = `\n  struct TestResults {\n    seq0: atomic<u32>,\n    seq1: atomic<u32>,\n    interleaved: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/**\n * Defines the possible behaviors of a two instruction test. Used to test the behavior of non-atomic memory with barriers and\n * one-thread coherence tests.\n * \"seq\" means that the expected, sequential behavior occurred.\n * \"weak\" means that an unexpected, inconsistent behavior occurred.\n */\nconst twoBehaviorTestResultStructure = `\n  struct TestResults {\n    seq: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/** Common bindings used in the test shader phase of a test. */\nconst commonTestShaderBindings = `\n  @group(0) @binding(1) var<storage, read_write> results : ReadResults;\n  @group(0) @binding(2) var<storage, read> shuffled_workgroups : IndexMemory;\n  @group(0) @binding(3) var<storage, read_write> combo : CombinedData;\n  @group(0) @binding(4) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/** The combined bindings for a test on atomic memory. */\nconst atomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** The combined bindings for a test on non-atomic memory. */\nconst nonAtomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** Bindings used in the result aggregation phase of the test. */\nconst resultShaderBindings = `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n  @group(0) @binding(1) var<storage, read_write> read_results : ReadResults;\n  @group(0) @binding(2) var<storage, read_write> test_results : TestResults;\n  @group(0) @binding(3) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/**\n * For tests that operate on workgroup memory, include this definition. 3584 memory locations is\n * large enough to accommodate the maximum memory size needed per workgroup for testing, which is\n * 256 invocations per workgroup x 2 memory locations x 7 (memStride, or max stride between successive memory locations).\n * Should change to a pipeline overridable constant when possible.\n */\nconst atomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<atomic<u32>, 3584>;\n`;\n\n/**\n * For tests that operate on non-atomic workgroup memory, include this definition. 3584 memory locations\n * is large enough to accommodate the maximum memory size needed per workgroup for testing.\n */\nconst nonAtomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<AccessValueTy, 3584>;\n`;\n\n/**\n * Functions used to calculate memory locations for each invocation, for both testing and result aggregation.\n * The permute function ensures a random permutation based on multiplying and modding by coprime numbers. The stripe\n * workgroup function ensures that invocations coordinating on a test are spread out across different workgroups.\n */\nconst memoryLocationFunctions = `\n  fn permute_id(id: u32, factor: u32, mask: u32) -> u32 {\n    return (id * factor) % mask;\n  }\n\n  fn stripe_workgroup(workgroup_id: u32, local_id: u32) -> u32 {\n    return (workgroup_id + 1u + local_id % (stress_params.testing_workgroups - 1u)) % stress_params.testing_workgroups;\n  }\n`;\n\n/** Functions that help add stress to the test. */\nconst testShaderFunctions = `\n  //Force the invocations in the workgroup to wait for each other, but without the general memory ordering\n  // effects of a control barrier. The barrier spins until either all invocations have incremented the atomic\n  // variable or 1024 loops have occurred. 1024 was chosen because it gives more time for invocations to enter\n  // the barrier but does not overly reduce testing throughput.\n  fn spin(limit: u32) {\n    var i : u32 = 0u;\n    var bar_val : u32 = atomicAdd(&combo.barrier.value[0], 1u);\n    loop {\n      if (i == 1024u || bar_val >= limit) {\n        break;\n      }\n      bar_val = atomicAdd(&combo.barrier.value[0], 0u);\n      i = i + 1u;\n    }\n  }\n\n  // Perform iterations of stress, depending on the specified pattern. Pattern 0 is store-store, pattern 1 is store-load,\n  // pattern 2 is load-store, and pattern 3 is load-load. The extra if condition (if tmpX > 100000u), is used to avoid\n  // the compiler optimizing out unused loads, where 100,000 is larger than the maximum number of stress iterations used\n  // in any test.\n  fn do_stress(iterations: u32, pattern: u32, workgroup_id: u32) {\n    let addr = combo.scratch_locations.value[workgroup_id];\n    switch(pattern) {\n      case 0u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          combo.scratchpad.value[addr] = i + 1u;\n        }\n      }\n      case 1u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      case 2u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          combo.scratchpad.value[addr] = i;\n        }\n      }\n      case 3u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          let tmp2: u32 = combo.scratchpad.value[addr];\n          if (tmp2 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      default: {\n      }\n    }\n  }\n`;\n\n/**\n * Entry point to both test and result shaders. One-dimensional workgroup size is hardcoded to 256, until\n * pipeline overridable constants are supported.\n */\nconst shaderEntryPoint = `\n  // Change to pipeline overridable constant when possible.\n  const workgroupXSize = kWorkgroupXSize;\n  @compute @workgroup_size(workgroupXSize) fn main(\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>) {\n`;\n\n/** All test shaders first calculate the shuffled workgroup. */\nconst testShaderCommonHeader = `\n    let shuffled_workgroup = shuffled_workgroups.value[workgroup_id[0]];\n    if (shuffled_workgroup < stress_params.testing_workgroups) {\n`;\n\n/**\n * All test shaders must calculate addresses for memory locations used in the test. Not all these addresses are\n * used in every test, but no test uses more than these addresses.\n */\nconst testShaderCommonCalculations = `\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = id_1 * stress_params.mem_stride * 2u;\n  let y_1 = permute_id(id_1, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n`;\n\n/**\n * An inter-workgroup test calculates two sets of memory locations that are guaranteed to be in separate workgroups.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in all workgroups.\n */\nconst interWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let id_0 = shuffled_workgroup * workgroupXSize + local_invocation_id[0];\n  let new_workgroup = stripe_workgroup(shuffled_workgroup, local_invocation_id[0]);\n  let id_1 = new_workgroup * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize * stress_params.testing_workgroups);\n  }\n`,\n].join('\\n');\n\n/**\n * An intra-workgroup test calculates two set of memory locations that are guaranteed to be in the same workgroup.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in the same workgroup.\n */\nconst intraWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`,\n].join('\\n');\n\n/**\n * Tests that operate on storage memory and communicate with invocations in the same workgroup must offset their locations\n * relative to global memory.\n */\nconst storageIntraWorkgroupTestShaderCode = `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n  let x_0 = (shuffled_workgroup * workgroupXSize + id_0) * stress_params.mem_stride * 2u;\n  let y_0 = (shuffled_workgroup * workgroupXSize + permute_id(id_0, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = (shuffled_workgroup * workgroupXSize + id_1) * stress_params.mem_stride * 2u;\n  let y_1 = (shuffled_workgroup * workgroupXSize + permute_id(id_1, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`;\n\n/** All test shaders may perform stress with non-testing threads. */\nconst testShaderCommonFooter = `\n    } else if (stress_params.mem_stress == 1u) {\n      do_stress(stress_params.mem_stress_iterations, stress_params.mem_stress_pattern, shuffled_workgroup);\n    }\n  }\n`;\n\n/**\n * All result shaders must calculate memory locations used in the test. Not all these locations are\n * used in every result shader, but no result shader uses more than these locations.\n *\n * Each value read from test_locations is converted from AccessValueTy to u32\n * before storing it in the read result.  This assumes u32(AccessValueTy)\n * is either an identity function u32(u32) or a value-converting overload such\n * as u32(f16).\n */\nconst resultShaderCommonCalculations = `\n  let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let mem_x_0 = u32(test_locations.value[x_0]);\n  let r0 = atomicLoad(&read_results.value[id_0].r0);\n  let r1 = atomicLoad(&read_results.value[id_0].r1);\n`;\n\n/** Common result shader code for an inter-workgroup test. */\nconst interWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Common result shader code for an intra-workgroup test. */\nconst intraWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize;\n  let y_0 = (workgroup_id[0] * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Ending bracket for result shaders. */\nconst resultShaderCommonFooter = `\n}\n`;\n\n/** The common shader code for test shaders that perform atomic storage class memory litmus tests. */\nconst storageMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic storage class memory litmus tests. */\nconst storageMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform atomic workgroup class memory litmus tests. */\nconst workgroupMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  atomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic workgroup class memory litmus tests. */\nconst workgroupMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  nonAtomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for all result shaders. */\nconst resultShaderCommonCode = [\n  shaderMemStructures,\n  resultShaderBindings,\n  memoryLocationFunctions,\n  shaderEntryPoint,\n].join('\\n');\n\n/**\n * Defines the types of possible memory a test is operating on. Used as part of the process of building shader code from\n * its composite parts.\n */\nexport enum MemoryType {\n  /** Atomic memory in the storage address space. */\n  AtomicStorageClass = 'atomic_storage',\n  /** Non-atomic memory in the storage address space. */\n  NonAtomicStorageClass = 'non_atomic_storage',\n  /** Atomic memory in the workgroup address space. */\n  AtomicWorkgroupClass = 'atomic_workgroup',\n  /** Non-atomic memory in the workgroup address space. */\n  NonAtomicWorkgroupClass = 'non_atomic_workgroup',\n}\n\n/**\n * Defines the relative positions of two invocations coordinating on a test. Used as part of the process of building shader\n * code from its composite parts.\n */\nexport enum TestType {\n  /** A test consists of two invocations in different workgroups. */\n  InterWorkgroup = 'inter_workgroup',\n  /** A test consists of two invocations in the same workgroup. */\n  IntraWorkgroup = 'intra_workgroup',\n}\n\n/** Defines the number of behaviors a test may have. */\nexport enum ResultType {\n  TwoBehavior,\n  FourBehavior,\n}\n\n/**\n * Given test code that performs the actual sequence of loads and stores, as well as a memory type and test type, returns\n * a complete test shader.\n */\nexport function buildTestShader(\n  testCode: string,\n  memoryType: MemoryType,\n  testType: TestType\n): string {\n  let memoryTypeCode;\n  let isStorageAS = false;\n  switch (memoryType) {\n    case MemoryType.AtomicStorageClass:\n      memoryTypeCode = storageMemoryAtomicTestShaderCode;\n      isStorageAS = true;\n      break;\n    case MemoryType.NonAtomicStorageClass:\n      memoryTypeCode = storageMemoryNonAtomicTestShaderCode;\n      isStorageAS = true;\n      break;\n    case MemoryType.AtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryNonAtomicTestShaderCode;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupTestShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      if (isStorageAS) {\n        testTypeCode = storageIntraWorkgroupTestShaderCode;\n      } else {\n        testTypeCode = intraWorkgroupTestShaderCode;\n      }\n  }\n  return [memoryTypeCode, testTypeCode, testCode, testShaderCommonFooter].join('\\n');\n}\n\n/**\n * Given result code that aggregates the possible behaviors of a test across all instances, as well as a test type and\n * number of behaviors, returns a complete result shader.\n */\nexport function buildResultShader(\n  resultCode: string,\n  testType: TestType,\n  resultType: ResultType\n): string {\n  let resultStructure;\n  switch (resultType) {\n    case ResultType.TwoBehavior:\n      resultStructure = twoBehaviorTestResultStructure;\n      break;\n    case ResultType.FourBehavior:\n      resultStructure = fourBehaviorTestResultStructure;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupResultShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupResultShaderCode;\n  }\n  return [\n    resultStructure,\n    resultShaderCommonCode,\n    testTypeCode,\n    resultCode,\n    resultShaderCommonFooter,\n  ].join('\\n');\n}\n"],"mappings":"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ACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAG;AAC9B;AACH;AACA,CAAC;AACCD,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMC,2BAA2B,GAAG;AACjC;AACH;AACA,CAAC;AACCH,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAME,oBAAoB,GAAI;AAC9B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAI;AAC/B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAI;AAChC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;A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"}
{"version":3,"file":"memory_model_setup.js","names":["checkElementsPassPredicate","align","PRNG","kAccessValueTypes","kWidth","numMemLocations","numReadOutputs","numStressParams","barrierParamIndex","memStressIndex","memStressIterationsIndex","memStressPatternIndex","preStressIndex","preStressIterationsIndex","preStressPatternIndex","permuteFirstIndex","permuteSecondIndex","testingWorkgroupsIndex","memStrideIndex","memLocationOffsetIndex","bytesPerWord","shaderPreamble","accessValueType","constants","MemoryModelTester","constructor","t","params","testShader","resultShader","useTexture","prng","test","workgroupXSize","Math","min","workgroupSize","device","limits","maxComputeWorkgroupSizeX","maxWorkgroups","scratchMemorySize","testingThreads","testingWorkgroups","testLocationsSize","memStride","testLocationsBuffer","deviceBuf","createBuffer","label","size","usage","GPUBufferUsage","COPY_DST","STORAGE","srcBuf","COPY_SRC","readResultsSize","readResultsBuffer","testResultsSize","numBehaviors","testResultsBuffer","shuffledWorkgroupsSize","shuffledWorkgroupsBuffer","MAP_WRITE","numTexels","width","height","textureSize","textureLocations","deviceTex","createTexture","format","dimension","GPUTextureUsage","STORAGE_BINDING","textures","testLocations","falseSharingAvoidanceQuantum","barrierSize","scratchpadSize","scratchMemoryLocationsSize","comboSize","comboBuffer","barrierBuffer","offset","scratchpadBuffer","scratchMemoryLocationsBuffer","stressParamsSize","stressParamsBuffer","UNIFORM","buffers","readResults","testResults","shuffledWorkgroups","barrier","scratchpad","scratchMemoryLocations","stressParams","testLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","layouts","textureLayout","storageTexture","access","viewDimension","texLocations","textureBindGroup","createBindGroup","resource","createView","layout","testPipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","testBindGroup","resultLayout","resultPipeline","resultBindGroup","run","iterations","weakIndex","i","numWorkgroups","getRandomInRange","setShuffledWorkgroups","setScratchLocations","setStressParams","encoder","createCommandEncoder","copyBufferToBuffer","copyBufferToTexture","testPass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","resultPass","queue","submit","finish","expectGPUBufferValuesPassCheck","checkWeakIndex","Uint32Array","typedLength","checkResult","resultPrinter","a","predicatePrinter","leftHeader","getValueForCell","v","texture","bytesPerRow","rowsPerImage","getRandomInt","max","randomU32","shuffleArray","length","toSwap","temp","mapAsync","GPUMapMode","WRITE","getMappedRange","shuffledWorkgroupsArray","shufflePct","x","unmap","scratchLocationsArrayBuffer","scratchLocationsArray","scratchNumRegions","stressLineSize","scratchRegions","Array","keys","stressTargetLines","region","locInRegion","stressStrategyBalancePct","j","workgroupsPerLocation","stressParamsArrayBuffer","stressParamsArray","barrierPct","memStressPct","memStressIterations","memStressStoreFirst","memStressStoreFirstPct","memStressStoreSecond","memStressStoreSecondPct","memStressPattern","preStressPct","preStressIterations","preStressStoreFirst","preStressStoreFirstPct","preStressStoreSecond","preStressStoreSecondPct","preStressPattern","permuteFirst","permuteSecond","aliasedMemory","shaderMemStructures","fourBehaviorTestResultStructure","twoBehaviorTestResultStructure","commonTestShaderBindings","atomicTestShaderBindings","join","nonAtomicTestShaderBindings","textureBindings","resultShaderBindings","atomicWorkgroupMemory","nonAtomicWorkgroupMemory","memoryLocationFunctions","textureFunctions","testShaderFunctions","shaderEntryPoint","testShaderCommonHeader","testShaderCommonCalculations","interWorkgroupTestShaderCode","intraWorkgroupTestShaderCode","storageIntraWorkgroupTestShaderCode","testShaderCommonFooter","resultShaderCommonCalculations","interWorkgroupResultShaderCode","intraWorkgroupResultShaderCode","resultShaderCommonFooter","storageMemoryAtomicTestShaderCode","storageMemoryNonAtomicTestShaderCode","textureMemoryNonAtomicTestShaderCode","workgroupMemoryAtomicTestShaderCode","workgroupMemoryNonAtomicTestShaderCode","resultShaderCommonCode","MemoryType","TestType","ResultType","buildTestShader","testCode","memoryType","testType","memoryTypeCode","isGlobalSpace","AtomicStorageClass","NonAtomicStorageClass","AtomicWorkgroupClass","NonAtomicWorkgroupClass","NonAtomicTextureClass","testTypeCode","InterWorkgroup","IntraWorkgroup","buildResultShader","resultCode","resultType","resultStructure","TwoBehavior","FourBehavior"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/memory_model_setup.ts"],"sourcesContent":["import { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsPassPredicate } from '../../../util/check_contents.js';\nimport { align } from '../../../util/math.js';\nimport { PRNG } from '../../../util/prng.js';\n\n/* All buffer sizes are counted in units of 4-byte words. */\n\n/**\n * The value type loaded and stored from memory.\n * This is what the WGSL spec calls 'store type' for the locations being accessed.\n * The GPU buffers are sized assuming this type is at most 4 bytes.\n *\n * 'u32' is the default case; it can be atomically loaded and stored.\n * 'f16' is interesting because it is not 32-bits, and can't be the store type\n * for atomic accesses.\n */\nexport type AccessValueType = 'f16' | 'u32';\nexport const kAccessValueTypes = ['f16', 'u32'] as const;\n\n/** The width used for textures (default compat limit in WebGPU). */\nconst kWidth = 4096;\n\n/* Parameter values are set heuristically, typically by a time-intensive search. */\nexport type MemoryModelTestParams = {\n  /* Number of invocations per workgroup. The workgroups are 1-dimensional. */\n  workgroupSize: number;\n  /** The number of workgroups to assign to running the test. */\n  testingWorkgroups: number;\n  /**\n   * Run no more than this many workgroups. Must be >= the number of testing workgroups. Non-testing workgroups are used\n   * to stress other memory locations.\n   */\n  maxWorkgroups: number;\n  /** The percentage of iterations to shuffle the workgroup ids. */\n  shufflePct: number;\n  /** The percentage of iterations to run the bounded spin-loop barrier. */\n  barrierPct: number;\n  /** The percentage of iterations to run memory stress using non-testing workgroups. */\n  memStressPct: number;\n  /** The number of iterations to run the memory stress pattern. */\n  memStressIterations: number;\n  /** The percentage of iterations the first instruction in the stress pattern should be a store. */\n  memStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the stress pattern should be a store. */\n  memStressStoreSecondPct: number;\n  /** The percentage of iterations for testing threads to run stress before running the test. */\n  preStressPct: number;\n  /** Same as for memStressIterations. */\n  preStressIterations: number;\n  /** The percentage of iterations the first instruction in the pre-stress pattern should be a store. */\n  preStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the pre-stress pattern should be a store. */\n  preStressStoreSecondPct: number;\n  /** The size of the scratch memory region, used for stressing threads. */\n  scratchMemorySize: number;\n  /** The size of each block of memory stressing threads access. */\n  stressLineSize: number;\n  /** The number of blocks of memory to assign stressing threads to. */\n  stressTargetLines: number;\n  /** How non-testing threads are assigned to stressing locations. 100 means all iterations use a round robin approach, 0 means all use a chunking approach. */\n  stressStrategyBalancePct: number;\n  /** Used to permute thread ids within a workgroup, so more random pairings are created between threads coordinating on a test. */\n  permuteFirst: number;\n  /** Used to create distance between memory locations used in a test. Set this to 1 for memory that should be aliased. */\n  permuteSecond: number;\n  /** The distance (in number of 4 byte intervals) between any two memory locations used for testing. */\n  memStride: number;\n  /** For tests that access one memory location, but use dynamic addresses to avoid compiler optimization, aliased memory should be set to true. */\n  aliasedMemory: boolean;\n  /** The number of possible behaviors that a test can have. */\n  numBehaviors: number;\n};\n\n/** The number of memory locations accessed by a test. Currently, only tests with up to 2 memory locations are supported. */\nconst numMemLocations = 2;\n\n/** The number of read outputs per test that need to be analyzed in the result aggregation shader. Currently, only tests with up to 2 read outputs are supported. */\nconst numReadOutputs = 2;\n\n/** Represents a device buffer and a utility buffer for resetting memory and copying parameters. */\ntype BufferWithSource = {\n  /** Buffer used by shader code. */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host side, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of the buffer. */\n  size: number;\n};\n\n/** Represents a device texture and a utility buffer for resetting memory and copying parameters. */\ntype TextureWithSource = {\n  /** Texture used by shader code. */\n  deviceTex: GPUTexture;\n  /** Buffer populated from the host side, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of the buffer. */\n  size: number;\n};\n\ntype SubBufferWithSource = {\n  /** Buffer used by shader code. This buffer is shared for multiple used */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host side, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of this portion of the buffer. */\n  size: number;\n  /** Offset in bytes of this portion of the buffer */\n  offset: number;\n};\n\n/** Specifies the buffers used during a memory model test. */\ntype MemoryModelBuffers = {\n  /** This is the memory region that testing threads read from and write to. */\n  testLocations: BufferWithSource;\n  /** This buffer collects the results of reads for analysis in the result aggregation shader. */\n  readResults: BufferWithSource;\n  /** This buffer is the aggregated results of every testing thread, and is used to check for test success/failure. */\n  testResults: BufferWithSource;\n  /** This buffer stores the shuffled workgroup ids for use during testing. Read-only in the shader. */\n  shuffledWorkgroups: BufferWithSource;\n  /** This is the bounded spin-loop barrier, used to temporally align testing threads. */\n  barrier: BufferWithSource;\n  /** Memory region for stressing threads to read to and write from. */\n  scratchpad: BufferWithSource;\n  /** The memory locations in the scratch region that stressing threads access. */\n  scratchMemoryLocations: BufferWithSource;\n  /** Parameters that are used by the shader to calculate memory locations and perform stress. */\n  stressParams: BufferWithSource;\n};\n\ntype MemoryModelTextures = {\n  testLocations: TextureWithSource;\n};\n\n/** The number of stress params to add to the stress params buffer. */\nconst numStressParams = 12;\nconst barrierParamIndex = 0;\nconst memStressIndex = 1;\nconst memStressIterationsIndex = 2;\nconst memStressPatternIndex = 3;\nconst preStressIndex = 4;\nconst preStressIterationsIndex = 5;\nconst preStressPatternIndex = 6;\nconst permuteFirstIndex = 7;\nconst permuteSecondIndex = 8;\nconst testingWorkgroupsIndex = 9;\nconst memStrideIndex = 10;\nconst memLocationOffsetIndex = 11;\n\n/**\n * All memory used in these consists of a four byte word, so this value is used to correctly set the byte size of buffers that\n * are read to/written from during tests and for storing test results.\n */\nconst bytesPerWord = 4;\n\n/**\n * Returns the shader preamble based on the access value type:\n *  - enable directives, if necessary\n *  - the type alias for AccessValueType\n */\nfunction shaderPreamble(accessValueType: AccessValueType, constants: string): string {\n  if (accessValueType === 'f16') {\n    return `enable f16;\\nalias AccessValueTy = f16;\\n${constants}\\n`;\n  }\n  return `alias AccessValueTy = ${accessValueType};\\n${constants}\\n`;\n}\n\n/**\n * Implements setup code necessary to run a memory model test. A test consists of two parts:\n *  1.) A test shader that runs a specified memory model litmus test and attempts to reveal a weak (disallowed) behavior.\n *      At a high level, a test shader consists of a set of testing workgroups where every invocation executes the litmus test\n *      on a set of test locations, and a set of stressing workgroups where every invocation accesses a specified memory location\n *      in a random pattern.\n *\n *      The main buffer variables are:\n *\n *        `test_locations`: invocations access entries in this array, trying to\n *          evoke weak behaviours.\n *\n *          This is array<AccessValueTy> or array<atomic<u32>>.\n *          AccessValueTy is either f16 or u32.\n *          Note that atomic<u32> is only used when AccessValueTy is u32.\n *\n *        `results`: holds the observed values, which is where we can see\n *          whether a weak behaviour was observed.\n *\n *          This is an array<atomic<u32>>.\n *\n *      The others are used to parameterize and stress the main activity.\n *\n *  2.) A result shader that takes the output of the test shader, which consists of the memory locations accessed during the test\n *      and the results of any reads made during the test, and aggregate the results based on the possible behaviors of the test.\n *\n *      The first two buffer variables are the same buffers as for the test shader:\n *\n *        `test_locations` is the same as `test_locations` from the test shader,\n *        but is mapped as array<AccessValueTy>.\n *\n *        `read_results` is the same buffer as `results` from the test shader.\n *\n *      The other variables are used to accumulate a summary that counts the weak behaviours stimulated and recorded by the\n *      test shader.\n */\nexport class MemoryModelTester {\n  protected test: GPUTest;\n  protected params: MemoryModelTestParams;\n  protected buffers: MemoryModelBuffers;\n  protected textures: MemoryModelTextures | undefined;\n  protected testPipeline: GPUComputePipeline;\n  protected testBindGroup: GPUBindGroup;\n  protected textureBindGroup: GPUBindGroup | undefined;\n  protected resultPipeline: GPUComputePipeline;\n  protected resultBindGroup: GPUBindGroup;\n  protected prng: PRNG;\n  protected useTexture: boolean;\n\n  /** Sets up a memory model test by initializing buffers and pipeline layouts. */\n  constructor(\n    t: GPUTest,\n    params: MemoryModelTestParams,\n    testShader: string,\n    resultShader: string,\n    accessValueType: AccessValueType = 'u32',\n    useTexture: boolean = false\n  ) {\n    this.prng = new PRNG(1);\n    this.test = t;\n    this.params = params;\n    this.useTexture = useTexture;\n\n    const workgroupXSize = Math.min(params.workgroupSize, t.device.limits.maxComputeWorkgroupSizeX);\n    const constants = `\n      const kNumBarriers = 1u;  // MAINTENANCE_TODO: make barrier not an array\n      const kMaxWorkgroups = ${params.maxWorkgroups}u;\n      const kScratchMemorySize = ${params.scratchMemorySize}u;\n      const kWorkgroupXSize = ${workgroupXSize}u;\n    `;\n    testShader = shaderPreamble(accessValueType, constants) + testShader;\n    resultShader = shaderPreamble(accessValueType, constants) + resultShader;\n\n    // set up buffers\n    const testingThreads = workgroupXSize * this.params.testingWorkgroups;\n    const testLocationsSize =\n      testingThreads * numMemLocations * this.params.memStride * bytesPerWord;\n    const testLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'testLocationsBuffer',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'testLocationsSrcBuf',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: testLocationsSize,\n    };\n\n    const readResultsSize = testingThreads * numReadOutputs * bytesPerWord;\n    const readResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'readResultsBuffer',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'readResultsSrcBuf',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: readResultsSize,\n    };\n\n    const testResultsSize = this.params.numBehaviors * bytesPerWord;\n    const testResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'testResultsBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'testResultsSrcBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: testResultsSize,\n    };\n\n    const shuffledWorkgroupsSize = this.params.maxWorkgroups * bytesPerWord;\n    const shuffledWorkgroupsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: shuffledWorkgroupsSize,\n    };\n\n    if (this.useTexture) {\n      const numTexels = testLocationsSize / bytesPerWord;\n      const width = kWidth;\n      const height = numTexels / width;\n      const textureSize: GPUExtent3D = { width, height };\n      const textureLocations: TextureWithSource = {\n        deviceTex: this.test.device.createTexture({\n          format: 'r32uint',\n          dimension: '2d',\n          size: textureSize,\n          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n        }),\n        srcBuf: testLocationsBuffer.srcBuf,\n        size: testLocationsSize,\n      };\n      this.textures = {\n        testLocations: textureLocations,\n      };\n    }\n\n    // Combine 3 arrays into 1 buffer as we need to keep the number of storage buffers to 4 for compat.\n    const falseSharingAvoidanceQuantum = 4096;\n    const barrierSize = align(bytesPerWord, falseSharingAvoidanceQuantum);\n    const scratchpadSize = align(\n      this.params.scratchMemorySize * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const scratchMemoryLocationsSize = align(\n      this.params.maxWorkgroups * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const comboSize = barrierSize + scratchpadSize + scratchMemoryLocationsSize;\n\n    const comboBuffer = this.test.device.createBuffer({\n      label: 'comboBuffer',\n      size: comboSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n\n    const barrierBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'barrierSrcBuf',\n        size: barrierSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: barrierSize,\n      offset: 0,\n    };\n\n    const scratchpadBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'scratchpadSrcBuf',\n        size: scratchpadSize,\n        usage: GPUBufferUsage.COPY_SRC,\n      }),\n      size: scratchpadSize,\n      offset: barrierSize,\n    };\n\n    const scratchMemoryLocationsBuffer: SubBufferWithSource = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.device.createBuffer({\n        label: 'scratchMemoryLocationsSrcBuf',\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: scratchMemoryLocationsSize,\n      offset: barrierSize + scratchpadSize,\n    };\n\n    const stressParamsSize = numStressParams * bytesPerWord;\n    const stressParamsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        label: 'stressParamsBuffer',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        label: 'stressParamsSrcBuf',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: stressParamsSize,\n    };\n\n    this.buffers = {\n      testLocations: testLocationsBuffer,\n      readResults: readResultsBuffer,\n      testResults: testResultsBuffer,\n      shuffledWorkgroups: shuffledWorkgroupsBuffer,\n      barrier: barrierBuffer,\n      scratchpad: scratchpadBuffer,\n      scratchMemoryLocations: scratchMemoryLocationsBuffer,\n      stressParams: stressParamsBuffer,\n    };\n\n    // set up pipeline layouts\n    const testLayout = this.test.device.createBindGroupLayout({\n      label: 'testLayout',\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n\n    let layouts: GPUBindGroupLayout[] = [testLayout];\n    if (this.useTexture) {\n      const textureLayout = this.test.device.createBindGroupLayout({\n        label: 'textureLayout',\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n              access: 'read-write',\n              format: 'r32uint',\n              viewDimension: '2d',\n            },\n          },\n        ],\n      });\n      layouts = [testLayout, textureLayout];\n\n      const texLocations = (this.textures as MemoryModelTextures).testLocations.deviceTex;\n      this.textureBindGroup = this.test.device.createBindGroup({\n        label: 'textureBindGroup',\n        entries: [\n          {\n            binding: 0,\n            resource: texLocations.createView(),\n          },\n        ],\n        layout: textureLayout,\n      });\n    }\n    this.testPipeline = this.test.device.createComputePipeline({\n      label: 'testPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: layouts,\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: testShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.testBindGroup = this.test.device.createBindGroup({\n      label: 'testBindGroup',\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.shuffledWorkgroups.deviceBuf } },\n        { binding: 3, resource: { buffer: comboBuffer } },\n        { binding: 4, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: testLayout,\n    });\n\n    const resultLayout = this.test.device.createBindGroupLayout({\n      label: 'resultLayout',\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.resultPipeline = this.test.device.createComputePipeline({\n      label: 'resultPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [resultLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: resultShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.resultBindGroup = this.test.device.createBindGroup({\n      label: 'resultBindGroup',\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.testResults.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: resultLayout,\n    });\n  }\n\n  /**\n   * Run the test for the specified number of iterations. Checks the testResults buffer on the weakIndex; if\n   * this value is not 0 then the test has failed. The number of iterations is chosen per test so that the\n   * full set of tests meets some time budget while still being reasonably effective at uncovering issues.\n   * Currently, we aim for each test to complete in under one second.\n   */\n  async run(iterations: number, weakIndex: number): Promise<void> {\n    for (let i = 0; i < iterations; i++) {\n      const numWorkgroups = this.getRandomInRange(\n        this.params.testingWorkgroups,\n        this.params.maxWorkgroups\n      );\n      await this.setShuffledWorkgroups(numWorkgroups);\n      await this.setScratchLocations(numWorkgroups);\n      await this.setStressParams();\n      const encoder = this.test.device.createCommandEncoder();\n      this.copyBufferToBuffer(encoder, this.buffers.testLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.readResults);\n      this.copyBufferToBuffer(encoder, this.buffers.testResults);\n      this.copyBufferToBuffer(encoder, this.buffers.barrier);\n      this.copyBufferToBuffer(encoder, this.buffers.shuffledWorkgroups);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchpad);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchMemoryLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.stressParams);\n      if (this.useTexture) {\n        this.copyBufferToTexture(encoder, (this.textures as MemoryModelTextures).testLocations);\n      }\n\n      const testPass = encoder.beginComputePass();\n      testPass.setPipeline(this.testPipeline);\n      testPass.setBindGroup(0, this.testBindGroup);\n      if (this.useTexture) {\n        testPass.setBindGroup(1, this.textureBindGroup as GPUBindGroup);\n      }\n      testPass.dispatchWorkgroups(numWorkgroups);\n      testPass.end();\n\n      const resultPass = encoder.beginComputePass();\n      resultPass.setPipeline(this.resultPipeline);\n      resultPass.setBindGroup(0, this.resultBindGroup);\n      resultPass.dispatchWorkgroups(this.params.testingWorkgroups);\n      resultPass.end();\n\n      this.test.device.queue.submit([encoder.finish()]);\n      this.test.expectGPUBufferValuesPassCheck(\n        this.buffers.testResults.deviceBuf,\n        this.checkWeakIndex(weakIndex),\n        {\n          type: Uint32Array,\n          typedLength: this.params.numBehaviors,\n        }\n      );\n    }\n  }\n\n  /** Returns a function that checks whether the test passes, given a weak index and the test results buffer. */\n  protected checkWeakIndex(weakIndex: number): (a: Uint32Array) => Error | undefined {\n    const checkResult = this.checkResult(weakIndex);\n    const resultPrinter = this.resultPrinter(weakIndex);\n    return function (a: Uint32Array): Error | undefined {\n      return checkElementsPassPredicate(a, checkResult, {\n        predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: resultPrinter }],\n      });\n    };\n  }\n\n  /**\n   * Returns a function that checks whether the specified weak index's value is not equal to 0.\n   * If the weak index's value is not 0, it means the test has observed a behavior disallowed by the memory model and\n   * is considered a test failure.\n   */\n  protected checkResult(weakIndex: number): (i: number, v: number | bigint) => boolean {\n    return function (i: number, v: number | bigint): boolean {\n      if (i === weakIndex && v > 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /** Returns a printer function that visualizes the results of checking the test results. */\n  protected resultPrinter(weakIndex: number): (i: number) => string | number | bigint {\n    return function (i: number): string | number {\n      if (i === weakIndex) {\n        return 0;\n      } else {\n        return 'any value';\n      }\n    };\n  }\n\n  /** Utility method that simplifies copying source buffers to device buffers. */\n  protected copyBufferToBuffer(\n    encoder: GPUCommandEncoder,\n    buffer: BufferWithSource | SubBufferWithSource\n  ): void {\n    encoder.copyBufferToBuffer(\n      buffer.srcBuf,\n      0,\n      buffer.deviceBuf,\n      (buffer as SubBufferWithSource).offset || 0,\n      buffer.size\n    );\n  }\n\n  /** Utility method that simplifies copying source buffers to device textures. */\n  protected copyBufferToTexture(encoder: GPUCommandEncoder, texture: TextureWithSource): void {\n    const bytesPerWord = 4; // always uses r32uint format.\n    const numTexels = texture.size / bytesPerWord;\n    const size: GPUExtent3D = { width: kWidth, height: numTexels / kWidth };\n    encoder.copyBufferToTexture(\n      {\n        buffer: texture.srcBuf,\n        offset: 0,\n        bytesPerRow: kWidth * bytesPerWord,\n        rowsPerImage: size.height,\n      },\n      { texture: texture.deviceTex },\n      size\n    );\n  }\n\n  /** Returns a random integer in the range [0, max). */\n  protected getRandomInt(max: number): number {\n    return this.prng.randomU32() % max;\n  }\n\n  /** Returns a random number in the range [min, max). */\n  protected getRandomInRange(min: number, max: number): number {\n    if (min === max) {\n      return min;\n    } else {\n      const offset = this.getRandomInt(max - min);\n      return min + offset;\n    }\n  }\n\n  /** Returns a permuted array using a simple Fisher-Yates shuffle algorithm. */\n  protected shuffleArray(a: number[]): void {\n    for (let i = a.length - 1; i >= 0; i--) {\n      const toSwap = this.getRandomInt(i + 1);\n      const temp = a[toSwap];\n      a[toSwap] = a[i];\n      a[i] = temp;\n    }\n  }\n\n  /**\n   * Shuffles the order of workgroup ids, so that threads operating on the same memory location are not always in\n   * consecutive workgroups.\n   */\n  protected async setShuffledWorkgroups(numWorkgroups: number): Promise<void> {\n    await this.buffers.shuffledWorkgroups.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const shuffledWorkgroupsBuffer = this.buffers.shuffledWorkgroups.srcBuf.getMappedRange();\n    const shuffledWorkgroupsArray = new Uint32Array(shuffledWorkgroupsBuffer);\n    for (let i = 0; i < numWorkgroups; i++) {\n      shuffledWorkgroupsArray[i] = i;\n    }\n    if (this.getRandomInt(100) < this.params.shufflePct) {\n      for (let i = numWorkgroups - 1; i > 0; i--) {\n        const x = this.getRandomInt(i + 1);\n        const temp = shuffledWorkgroupsArray[i];\n        shuffledWorkgroupsArray[i] = shuffledWorkgroupsArray[x];\n        shuffledWorkgroupsArray[x] = temp;\n      }\n    }\n    this.buffers.shuffledWorkgroups.srcBuf.unmap();\n  }\n\n  /** Sets the memory locations that stressing workgroups will access. Uses either a chunking or round robin assignment strategy. */\n  protected async setScratchLocations(numWorkgroups: number): Promise<void> {\n    await this.buffers.scratchMemoryLocations.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const scratchLocationsArrayBuffer = this.buffers.scratchMemoryLocations.srcBuf.getMappedRange();\n    const scratchLocationsArray = new Uint32Array(scratchLocationsArrayBuffer);\n    const scratchNumRegions = this.params.scratchMemorySize / this.params.stressLineSize;\n    const scratchRegions = [...Array(scratchNumRegions).keys()];\n    this.shuffleArray(scratchRegions);\n    for (let i = 0; i < this.params.stressTargetLines; i++) {\n      const region = scratchRegions[i];\n      const locInRegion = this.getRandomInt(this.params.stressLineSize);\n      if (this.getRandomInt(100) < this.params.stressStrategyBalancePct) {\n        // In the round-robin case, the current scratch location is striped across all workgroups.\n        for (let j = i; j < numWorkgroups; j += this.params.stressTargetLines) {\n          scratchLocationsArray[j] = region * this.params.stressLineSize + locInRegion;\n        }\n      } else {\n        // In the chunking case, the current scratch location is assigned to a block of workgroups. The final scratch\n        // location may be assigned to more workgroups, if the number of scratch locations does not cleanly divide the\n        // number of workgroups.\n        const workgroupsPerLocation = numWorkgroups / this.params.stressTargetLines;\n        for (let j = 0; j < workgroupsPerLocation; j++) {\n          scratchLocationsArray[i * workgroupsPerLocation + j] =\n            region * this.params.stressLineSize + locInRegion;\n        }\n        if (\n          i === this.params.stressTargetLines - 1 &&\n          numWorkgroups % this.params.stressTargetLines !== 0\n        ) {\n          for (let j = 0; j < numWorkgroups % this.params.stressTargetLines; j++) {\n            scratchLocationsArray[numWorkgroups - j - 1] =\n              region * this.params.stressLineSize + locInRegion;\n          }\n        }\n      }\n    }\n    this.buffers.scratchMemoryLocations.srcBuf.unmap();\n  }\n\n  /** Sets the parameters that are used by the shader to calculate memory locations and perform stress. */\n  protected async setStressParams(): Promise<void> {\n    await this.buffers.stressParams.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const stressParamsArrayBuffer = this.buffers.stressParams.srcBuf.getMappedRange();\n    const stressParamsArray = new Uint32Array(stressParamsArrayBuffer);\n    if (this.getRandomInt(100) < this.params.barrierPct) {\n      stressParamsArray[barrierParamIndex] = 1;\n    } else {\n      stressParamsArray[barrierParamIndex] = 0;\n    }\n    if (this.getRandomInt(100) < this.params.memStressPct) {\n      stressParamsArray[memStressIndex] = 1;\n    } else {\n      stressParamsArray[memStressIndex] = 0;\n    }\n    stressParamsArray[memStressIterationsIndex] = this.params.memStressIterations;\n    const memStressStoreFirst = this.getRandomInt(100) < this.params.memStressStoreFirstPct;\n    const memStressStoreSecond = this.getRandomInt(100) < this.params.memStressStoreSecondPct;\n    let memStressPattern;\n    if (memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 0;\n    } else if (memStressStoreFirst && !memStressStoreSecond) {\n      memStressPattern = 1;\n    } else if (!memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 2;\n    } else {\n      memStressPattern = 3;\n    }\n    stressParamsArray[memStressPatternIndex] = memStressPattern;\n    if (this.getRandomInt(100) < this.params.preStressPct) {\n      stressParamsArray[preStressIndex] = 1;\n    } else {\n      stressParamsArray[preStressIndex] = 0;\n    }\n    stressParamsArray[preStressIterationsIndex] = this.params.preStressIterations;\n    const preStressStoreFirst = this.getRandomInt(100) < this.params.preStressStoreFirstPct;\n    const preStressStoreSecond = this.getRandomInt(100) < this.params.preStressStoreSecondPct;\n    let preStressPattern;\n    if (preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 0;\n    } else if (preStressStoreFirst && !preStressStoreSecond) {\n      preStressPattern = 1;\n    } else if (!preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 2;\n    } else {\n      preStressPattern = 3;\n    }\n    stressParamsArray[preStressPatternIndex] = preStressPattern;\n    stressParamsArray[permuteFirstIndex] = this.params.permuteFirst;\n    stressParamsArray[permuteSecondIndex] = this.params.permuteSecond;\n    stressParamsArray[testingWorkgroupsIndex] = this.params.testingWorkgroups;\n    stressParamsArray[memStrideIndex] = this.params.memStride;\n    if (this.params.aliasedMemory) {\n      stressParamsArray[memLocationOffsetIndex] = 0;\n    } else {\n      stressParamsArray[memLocationOffsetIndex] = this.params.memStride;\n    }\n    this.buffers.stressParams.srcBuf.unmap();\n  }\n}\n\n/** Defines common data structures used in memory model test shaders. */\nconst shaderMemStructures = `\n  struct Memory {\n    value: array<AccessValueTy>\n  };\n\n  struct AtomicMemory {\n    value: array<atomic<u32>>\n  };\n\n  struct IndexMemory {\n    value: array<u32>,\n  };\n\n  struct AtomicMemoryBarrier {\n    value: array<atomic<u32>, kNumBarriers>\n  };\n\n  struct IndexMemoryScratchpad {\n    value: array<u32, kMaxWorkgroups>,\n  };\n\n  struct IndexMemoryScratchLocations {\n    value: array<u32, kScratchMemorySize>,\n  };\n\n  struct ReadResult {\n    r0: atomic<u32>,\n    r1: atomic<u32>,\n  };\n\n  struct ReadResults {\n    value: array<ReadResult>,\n  };\n\n  // These arrays are combine into 1 buffer because compat mode only supports 4 storage buffers by default.\n  struct CombinedData {\n    barrier: AtomicMemoryBarrier,\n    scratchpad: IndexMemoryScratchpad,\n    scratch_locations: IndexMemoryScratchLocations,\n  };\n\n  struct StressParamsMemory {\n    do_barrier: u32,\n    mem_stress: u32,\n    mem_stress_iterations: u32,\n    mem_stress_pattern: u32,\n    pre_stress: u32,\n    pre_stress_iterations: u32,\n    pre_stress_pattern: u32,\n    permute_first: u32,\n    permute_second: u32,\n    testing_workgroups: u32,\n    mem_stride: u32,\n    location_offset: u32,\n  };\n`;\n\n/**\n * Structure to hold the counts of occurrences of the possible behaviors of a two-thread, four-instruction test.\n * \"seq0\" means the first invocation's instructions are observed to have occurred before the second invocation's instructions.\n * \"seq1\" means the second invocation's instructions are observed to have occurred before the first invocation's instructions.\n * \"interleaved\" means there was an observation of some interleaving of instructions between the two invocations.\n * \"weak\" means there was an observation of some ordering of instructions that is inconsistent with the WebGPU memory model.\n */\nconst fourBehaviorTestResultStructure = `\n  struct TestResults {\n    seq0: atomic<u32>,\n    seq1: atomic<u32>,\n    interleaved: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/**\n * Defines the possible behaviors of a two instruction test. Used to test the behavior of non-atomic memory with barriers and\n * one-thread coherence tests.\n * \"seq\" means that the expected, sequential behavior occurred.\n * \"weak\" means that an unexpected, inconsistent behavior occurred.\n */\nconst twoBehaviorTestResultStructure = `\n  struct TestResults {\n    seq: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/** Common bindings used in the test shader phase of a test. */\nconst commonTestShaderBindings = `\n  @group(0) @binding(1) var<storage, read_write> results : ReadResults;\n  @group(0) @binding(2) var<storage, read> shuffled_workgroups : IndexMemory;\n  @group(0) @binding(3) var<storage, read_write> combo : CombinedData;\n  @group(0) @binding(4) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/** The combined bindings for a test on atomic memory. */\nconst atomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** The combined bindings for a test on non-atomic memory. */\nconst nonAtomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** The extra binding for texture non-atomic texture tests. */\nconst textureBindings = `\n@group(1) @binding(0) var texture_locations : texture_storage_2d<r32uint, read_write>;\n`;\n\n/** Bindings used in the result aggregation phase of the test. */\nconst resultShaderBindings = `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n  @group(0) @binding(1) var<storage, read_write> read_results : ReadResults;\n  @group(0) @binding(2) var<storage, read_write> test_results : TestResults;\n  @group(0) @binding(3) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/**\n * For tests that operate on workgroup memory, include this definition. 3584 memory locations is\n * large enough to accommodate the maximum memory size needed per workgroup for testing, which is\n * 256 invocations per workgroup x 2 memory locations x 7 (memStride, or max stride between successive memory locations).\n * Should change to a pipeline overridable constant when possible.\n */\nconst atomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<atomic<u32>, 3584>;\n`;\n\n/**\n * For tests that operate on non-atomic workgroup memory, include this definition. 3584 memory locations\n * is large enough to accommodate the maximum memory size needed per workgroup for testing.\n */\nconst nonAtomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<AccessValueTy, 3584>;\n`;\n\n/**\n * Functions used to calculate memory locations for each invocation, for both testing and result aggregation.\n * The permute function ensures a random permutation based on multiplying and modding by coprime numbers. The stripe\n * workgroup function ensures that invocations coordinating on a test are spread out across different workgroups.\n */\nconst memoryLocationFunctions = `\n  fn permute_id(id: u32, factor: u32, mask: u32) -> u32 {\n    return (id * factor) % mask;\n  }\n\n  fn stripe_workgroup(workgroup_id: u32, local_id: u32) -> u32 {\n    return (workgroup_id + 1u + local_id % (stress_params.testing_workgroups - 1u)) % stress_params.testing_workgroups;\n  }\n`;\n\n/**\n * Function to convert an index into an equivalent 2D coordinate for the texture.\n */\nconst textureFunctions = `\n  const kWidth = ${kWidth};\n  fn indexToCoord(idx : u32) -> vec2u {\n    return vec2u(idx % kWidth, idx / kWidth);\n  }\n`;\n\n/** Functions that help add stress to the test. */\nconst testShaderFunctions = `\n  //Force the invocations in the workgroup to wait for each other, but without the general memory ordering\n  // effects of a control barrier. The barrier spins until either all invocations have incremented the atomic\n  // variable or 1024 loops have occurred. 1024 was chosen because it gives more time for invocations to enter\n  // the barrier but does not overly reduce testing throughput.\n  fn spin(limit: u32) {\n    var i : u32 = 0u;\n    var bar_val : u32 = atomicAdd(&combo.barrier.value[0], 1u);\n    loop {\n      if (i == 1024u || bar_val >= limit) {\n        break;\n      }\n      bar_val = atomicAdd(&combo.barrier.value[0], 0u);\n      i = i + 1u;\n    }\n  }\n\n  // Perform iterations of stress, depending on the specified pattern. Pattern 0 is store-store, pattern 1 is store-load,\n  // pattern 2 is load-store, and pattern 3 is load-load. The extra if condition (if tmpX > 100000u), is used to avoid\n  // the compiler optimizing out unused loads, where 100,000 is larger than the maximum number of stress iterations used\n  // in any test.\n  fn do_stress(iterations: u32, pattern: u32, workgroup_id: u32) {\n    let addr = combo.scratch_locations.value[workgroup_id];\n    switch(pattern) {\n      case 0u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          combo.scratchpad.value[addr] = i + 1u;\n        }\n      }\n      case 1u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      case 2u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          combo.scratchpad.value[addr] = i;\n        }\n      }\n      case 3u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          let tmp2: u32 = combo.scratchpad.value[addr];\n          if (tmp2 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      default: {\n      }\n    }\n  }\n`;\n\n/**\n * Entry point to both test and result shaders. One-dimensional workgroup size is hardcoded to 256, until\n * pipeline overridable constants are supported.\n */\nconst shaderEntryPoint = `\n  // Change to pipeline overridable constant when possible.\n  const workgroupXSize = kWorkgroupXSize;\n  @compute @workgroup_size(workgroupXSize) fn main(\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>) {\n`;\n\n/** All test shaders first calculate the shuffled workgroup. */\nconst testShaderCommonHeader = `\n    let shuffled_workgroup = shuffled_workgroups.value[workgroup_id[0]];\n    if (shuffled_workgroup < stress_params.testing_workgroups) {\n`;\n\n/**\n * All test shaders must calculate addresses for memory locations used in the test. Not all these addresses are\n * used in every test, but no test uses more than these addresses.\n */\nconst testShaderCommonCalculations = `\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = id_1 * stress_params.mem_stride * 2u;\n  let y_1 = permute_id(id_1, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n`;\n\n/**\n * An inter-workgroup test calculates two sets of memory locations that are guaranteed to be in separate workgroups.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in all workgroups.\n */\nconst interWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let id_0 = shuffled_workgroup * workgroupXSize + local_invocation_id[0];\n  let new_workgroup = stripe_workgroup(shuffled_workgroup, local_invocation_id[0]);\n  let id_1 = new_workgroup * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize * stress_params.testing_workgroups);\n  }\n`,\n].join('\\n');\n\n/**\n * An intra-workgroup test calculates two set of memory locations that are guaranteed to be in the same workgroup.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in the same workgroup.\n */\nconst intraWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`,\n].join('\\n');\n\n/**\n * Tests that operate on storage memory and communicate with invocations in the same workgroup must offset their locations\n * relative to global memory.\n */\nconst storageIntraWorkgroupTestShaderCode = `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n  let x_0 = (shuffled_workgroup * workgroupXSize + id_0) * stress_params.mem_stride * 2u;\n  let y_0 = (shuffled_workgroup * workgroupXSize + permute_id(id_0, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = (shuffled_workgroup * workgroupXSize + id_1) * stress_params.mem_stride * 2u;\n  let y_1 = (shuffled_workgroup * workgroupXSize + permute_id(id_1, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`;\n\n/** All test shaders may perform stress with non-testing threads. */\nconst testShaderCommonFooter = `\n    } else if (stress_params.mem_stress == 1u) {\n      do_stress(stress_params.mem_stress_iterations, stress_params.mem_stress_pattern, shuffled_workgroup);\n    }\n  }\n`;\n\n/**\n * All result shaders must calculate memory locations used in the test. Not all these locations are\n * used in every result shader, but no result shader uses more than these locations.\n *\n * Each value read from test_locations is converted from AccessValueTy to u32\n * before storing it in the read result.  This assumes u32(AccessValueTy)\n * is either an identity function u32(u32) or a value-converting overload such\n * as u32(f16).\n */\nconst resultShaderCommonCalculations = `\n  let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let mem_x_0 = u32(test_locations.value[x_0]);\n  let r0 = atomicLoad(&read_results.value[id_0].r0);\n  let r1 = atomicLoad(&read_results.value[id_0].r1);\n`;\n\n/** Common result shader code for an inter-workgroup test. */\nconst interWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Common result shader code for an intra-workgroup test. */\nconst intraWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize;\n  let y_0 = (workgroup_id[0] * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Ending bracket for result shaders. */\nconst resultShaderCommonFooter = `\n}\n`;\n\n/** The common shader code for test shaders that perform atomic storage class memory litmus tests. */\nconst storageMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic storage class memory litmus tests. */\nconst storageMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for the test shaders that perform non-atomic texture memory litmus tests. */\nconst textureMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  textureBindings,\n  memoryLocationFunctions,\n  textureFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform atomic workgroup class memory litmus tests. */\nconst workgroupMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  atomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic workgroup class memory litmus tests. */\nconst workgroupMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  nonAtomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for all result shaders. */\nconst resultShaderCommonCode = [\n  shaderMemStructures,\n  resultShaderBindings,\n  memoryLocationFunctions,\n  shaderEntryPoint,\n].join('\\n');\n\n/**\n * Defines the types of possible memory a test is operating on. Used as part of the process of building shader code from\n * its composite parts.\n */\nexport enum MemoryType {\n  /** Atomic memory in the storage address space. */\n  AtomicStorageClass = 'atomic_storage',\n  /** Non-atomic memory in the storage address space. */\n  NonAtomicStorageClass = 'non_atomic_storage',\n  /** Atomic memory in the workgroup address space. */\n  AtomicWorkgroupClass = 'atomic_workgroup',\n  /** Non-atomic memory in the workgroup address space. */\n  NonAtomicWorkgroupClass = 'non_atomic_workgroup',\n  /** Non-atomic memory in a texture. */\n  NonAtomicTextureClass = 'non_atomic_texture',\n}\n\n/**\n * Defines the relative positions of two invocations coordinating on a test. Used as part of the process of building shader\n * code from its composite parts.\n */\nexport enum TestType {\n  /** A test consists of two invocations in different workgroups. */\n  InterWorkgroup = 'inter_workgroup',\n  /** A test consists of two invocations in the same workgroup. */\n  IntraWorkgroup = 'intra_workgroup',\n}\n\n/** Defines the number of behaviors a test may have. */\nexport enum ResultType {\n  TwoBehavior,\n  FourBehavior,\n}\n\n/**\n * Given test code that performs the actual sequence of loads and stores, as well as a memory type and test type, returns\n * a complete test shader.\n */\nexport function buildTestShader(\n  testCode: string,\n  memoryType: MemoryType,\n  testType: TestType\n): string {\n  let memoryTypeCode;\n  let isGlobalSpace = false;\n  switch (memoryType) {\n    case MemoryType.AtomicStorageClass:\n      memoryTypeCode = storageMemoryAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n    case MemoryType.NonAtomicStorageClass:\n      memoryTypeCode = storageMemoryNonAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n    case MemoryType.AtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryNonAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicTextureClass:\n      memoryTypeCode = textureMemoryNonAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupTestShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      if (isGlobalSpace) {\n        testTypeCode = storageIntraWorkgroupTestShaderCode;\n      } else {\n        testTypeCode = intraWorkgroupTestShaderCode;\n      }\n  }\n  return [memoryTypeCode, testTypeCode, testCode, testShaderCommonFooter].join('\\n');\n}\n\n/**\n * Given result code that aggregates the possible behaviors of a test across all instances, as well as a test type and\n * number of behaviors, returns a complete result shader.\n */\nexport function buildResultShader(\n  resultCode: string,\n  testType: TestType,\n  resultType: ResultType\n): string {\n  let resultStructure;\n  switch (resultType) {\n    case ResultType.TwoBehavior:\n      resultStructure = twoBehaviorTestResultStructure;\n      break;\n    case ResultType.FourBehavior:\n      resultStructure = fourBehaviorTestResultStructure;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupResultShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupResultShaderCode;\n  }\n  return [\n    resultStructure,\n    resultShaderCommonCode,\n    testTypeCode,\n    resultCode,\n    resultShaderCommonFooter,\n  ].join('\\n');\n}\n"],"mappings":";;GACA,SAASA,0BAA0B,QAAQ,iCAAiC,CAC5E,SAASC,KAAK,QAAQ,uBAAuB;AAC7C,SAASC,IAAI,QAAQ,uBAAuB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,iBAAiB,GAAG,CAAC,KAAK,EAAE,KAAK,CAAU;;AAExD;AACA,MAAMC,MAAM,GAAG,IAAI;;AAEnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA;AACA,MAAMC,eAAe,GAAG,CAAC;;AAEzB;AACA,MAAMC,cAAc,GAAG,CAAC;;AAExB;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA,MAAMC,eAAe,GAAG,EAAE;AAC1B,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,cAAc,GAAG,CAAC;AACxB,MAAMC,wBAAwB,GAAG,CAAC;AAClC,MAAMC,qBAAqB,GAAG,CAAC;AAC/B,MAAMC,cAAc,GAAG,CAAC;AACxB,MAAMC,wBAAwB,GAAG,CAAC;AAClC,MAAMC,qBAAqB,GAAG,CAAC;AAC/B,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,sBAAsB,GAAG,CAAC;AAChC,MAAMC,cAAc,GAAG,EAAE;AACzB,MAAMC,sBAAsB,GAAG,EAAE;;AAEjC;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,eAAgC,EAAEC,SAAiB,EAAU;EACnF,IAAID,eAAe,KAAK,KAAK,EAAE;IAC7B,OAAQ,4CAA2CC,SAAU,IAAG;EAClE;EACA,OAAQ,yBAAwBD,eAAgB,MAAKC,SAAU,IAAG;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;;;;;;;;;;;;;EAa7B;EACAC,WAAWA;EACTC,CAAU;EACVC,MAA6B;EAC7BC,UAAkB;EAClBC,YAAoB;EACpBP,eAAgC,GAAG,KAAK;EACxCQ,UAAmB,GAAG,KAAK;EAC3B;IACA,IAAI,CAACC,IAAI,GAAG,IAAI7B,IAAI,CAAC,CAAC,CAAC;IACvB,IAAI,CAAC8B,IAAI,GAAGN,CAAC;IACb,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACG,UAAU,GAAGA,UAAU;;IAE5B,MAAMG,cAAc,GAAGC,IAAI,CAACC,GAAG,CAACR,MAAM,CAACS,aAAa,EAAEV,CAAC,CAACW,MAAM,CAACC,MAAM,CAACC,wBAAwB,CAAC;IAC/F,MAAMhB,SAAS,GAAI;AACvB;AACA,+BAA+BI,MAAM,CAACa,aAAc;AACpD,mCAAmCb,MAAM,CAACc,iBAAkB;AAC5D,gCAAgCR,cAAe;AAC/C,KAAK;IACDL,UAAU,GAAGP,cAAc,CAACC,eAAe,EAAEC,SAAS,CAAC,GAAGK,UAAU;IACpEC,YAAY,GAAGR,cAAc,CAACC,eAAe,EAAEC,SAAS,CAAC,GAAGM,YAAY;;IAExE;IACA,MAAMa,cAAc,GAAGT,cAAc,GAAG,IAAI,CAACN,MAAM,CAACgB,iBAAiB;IACrE,MAAMC,iBAAiB;IACrBF,cAAc,GAAGrC,eAAe,GAAG,IAAI,CAACsB,MAAM,CAACkB,SAAS,GAAGzB,YAAY;IACzE,MAAM0B,mBAAqC,GAAG;MAC5CC,SAAS,EAAE,IAAI,CAACf,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACvCC,KAAK,EAAE,qBAAqB;QAC5BC,IAAI,EAAEN,iBAAiB;QACvBO,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE;MAClD,CAAC,CAAC;MACFC,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,qBAAqB;QAC5BC,IAAI,EAAEN,iBAAiB;QACvBO,KAAK,EAAEC,cAAc,CAACI;MACxB,CAAC,CAAC;MACFN,IAAI,EAAEN;IACR,CAAC;;IAED,MAAMa,eAAe,GAAGf,cAAc,GAAGpC,cAAc,GAAGc,YAAY;IACtE,MAAMsC,iBAAmC,GAAG;MAC1CX,SAAS,EAAE,IAAI,CAACf,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACvCC,KAAK,EAAE,mBAAmB;QAC1BC,IAAI,EAAEO,eAAe;QACrBN,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE;MAClD,CAAC,CAAC;MACFC,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,mBAAmB;QAC1BC,IAAI,EAAEO,eAAe;QACrBN,KAAK,EAAEC,cAAc,CAACI;MACxB,CAAC,CAAC;MACFN,IAAI,EAAEO;IACR,CAAC;;IAED,MAAME,eAAe,GAAG,IAAI,CAAChC,MAAM,CAACiC,YAAY,GAAGxC,YAAY;IAC/D,MAAMyC,iBAAmC,GAAG;MAC1Cd,SAAS,EAAE,IAAI,CAACf,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACvCC,KAAK,EAAE,mBAAmB;QAC1BC,IAAI,EAAES,eAAe;QACrBR,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE,OAAO,GAAGF,cAAc,CAACI;MAC3E,CAAC,CAAC;MACFD,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,sBAAsB;QAC7BC,IAAI,EAAES,eAAe;QACrBR,KAAK,EAAEC,cAAc,CAACI;MACxB,CAAC,CAAC;MACFN,IAAI,EAAES;IACR,CAAC;;IAED,MAAMG,sBAAsB,GAAG,IAAI,CAACnC,MAAM,CAACa,aAAa,GAAGpB,YAAY;IACvE,MAAM2C,wBAA0C,GAAG;MACjDhB,SAAS,EAAE,IAAI,CAACf,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACvCE,IAAI,EAAEY,sBAAsB;QAC5BX,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE;MAClD,CAAC,CAAC;MACFC,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCE,IAAI,EAAEY,sBAAsB;QAC5BX,KAAK,EAAEC,cAAc,CAACI,QAAQ,GAAGJ,cAAc,CAACY;MAClD,CAAC,CAAC;MACFd,IAAI,EAAEY;IACR,CAAC;;IAED,IAAI,IAAI,CAAChC,UAAU,EAAE;MACnB,MAAMmC,SAAS,GAAGrB,iBAAiB,GAAGxB,YAAY;MAClD,MAAM8C,KAAK,GAAG9D,MAAM;MACpB,MAAM+D,MAAM,GAAGF,SAAS,GAAGC,KAAK;MAChC,MAAME,WAAwB,GAAG,EAAEF,KAAK,EAAEC,MAAM,CAAC,CAAC;MAClD,MAAME,gBAAmC,GAAG;QAC1CC,SAAS,EAAE,IAAI,CAACtC,IAAI,CAACK,MAAM,CAACkC,aAAa,CAAC;UACxCC,MAAM,EAAE,SAAS;UACjBC,SAAS,EAAE,IAAI;UACfvB,IAAI,EAAEkB,WAAW;UACjBjB,KAAK,EAAEuB,eAAe,CAACrB,QAAQ,GAAGqB,eAAe,CAACC;QACpD,CAAC,CAAC;QACFpB,MAAM,EAAET,mBAAmB,CAACS,MAAM;QAClCL,IAAI,EAAEN;MACR,CAAC;MACD,IAAI,CAACgC,QAAQ,GAAG;QACdC,aAAa,EAAER;MACjB,CAAC;IACH;;IAEA;IACA,MAAMS,4BAA4B,GAAG,IAAI;IACzC,MAAMC,WAAW,GAAG9E,KAAK,CAACmB,YAAY,EAAE0D,4BAA4B,CAAC;IACrE,MAAME,cAAc,GAAG/E,KAAK;MAC1B,IAAI,CAAC0B,MAAM,CAACc,iBAAiB,GAAGrB,YAAY;MAC5C0D;IACF,CAAC;IACD,MAAMG,0BAA0B,GAAGhF,KAAK;MACtC,IAAI,CAAC0B,MAAM,CAACa,aAAa,GAAGpB,YAAY;MACxC0D;IACF,CAAC;IACD,MAAMI,SAAS,GAAGH,WAAW,GAAGC,cAAc,GAAGC,0BAA0B;;IAE3E,MAAME,WAAW,GAAG,IAAI,CAACnD,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;MAChDC,KAAK,EAAE,aAAa;MACpBC,IAAI,EAAEgC,SAAS;MACf/B,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE;IAClD,CAAC,CAAC;;IAEF,MAAM8B,aAAkC,GAAG;MACzCrC,SAAS,EAAEoC,WAAW;MACtB5B,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,eAAe;QACtBC,IAAI,EAAE6B,WAAW;QACjB5B,KAAK,EAAEC,cAAc,CAACI;MACxB,CAAC,CAAC;MACFN,IAAI,EAAE6B,WAAW;MACjBM,MAAM,EAAE;IACV,CAAC;;IAED,MAAMC,gBAAqC,GAAG;MAC5CvC,SAAS,EAAEoC,WAAW;MACtB5B,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,kBAAkB;QACzBC,IAAI,EAAE8B,cAAc;QACpB7B,KAAK,EAAEC,cAAc,CAACI;MACxB,CAAC,CAAC;MACFN,IAAI,EAAE8B,cAAc;MACpBK,MAAM,EAAEN;IACV,CAAC;;IAED,MAAMQ,4BAAiD,GAAG;MACxDxC,SAAS,EAAEoC,WAAW;MACtB5B,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,8BAA8B;QACrCC,IAAI,EAAE+B,0BAA0B;QAChC9B,KAAK,EAAEC,cAAc,CAACI,QAAQ,GAAGJ,cAAc,CAACY;MAClD,CAAC,CAAC;MACFd,IAAI,EAAE+B,0BAA0B;MAChCI,MAAM,EAAEN,WAAW,GAAGC;IACxB,CAAC;;IAED,MAAMQ,gBAAgB,GAAGjF,eAAe,GAAGa,YAAY;IACvD,MAAMqE,kBAAoC,GAAG;MAC3C1C,SAAS,EAAE,IAAI,CAACf,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACvCC,KAAK,EAAE,oBAAoB;QAC3BC,IAAI,EAAEsC,gBAAgB;QACtBrC,KAAK,EAAEC,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACsC;MAClD,CAAC,CAAC;MACFnC,MAAM,EAAE,IAAI,CAACvB,IAAI,CAACK,MAAM,CAACW,YAAY,CAAC;QACpCC,KAAK,EAAE,oBAAoB;QAC3BC,IAAI,EAAEsC,gBAAgB;QACtBrC,KAAK,EAAEC,cAAc,CAACI,QAAQ,GAAGJ,cAAc,CAACY;MAClD,CAAC,CAAC;MACFd,IAAI,EAAEsC;IACR,CAAC;;IAED,IAAI,CAACG,OAAO,GAAG;MACbd,aAAa,EAAE/B,mBAAmB;MAClC8C,WAAW,EAAElC,iBAAiB;MAC9BmC,WAAW,EAAEhC,iBAAiB;MAC9BiC,kBAAkB,EAAE/B,wBAAwB;MAC5CgC,OAAO,EAAEX,aAAa;MACtBY,UAAU,EAAEV,gBAAgB;MAC5BW,sBAAsB,EAAEV,4BAA4B;MACpDW,YAAY,EAAET;IAChB,CAAC;;IAED;IACA,MAAMU,UAAU,GAAG,IAAI,CAACnE,IAAI,CAACK,MAAM,CAAC+D,qBAAqB,CAAC;MACxDnD,KAAK,EAAE,YAAY;MACnBoD,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAC;MACzF,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;;IAEnF,CAAC,CAAC;;IAEF,IAAIC,OAA6B,GAAG,CAACT,UAAU,CAAC;IAChD,IAAI,IAAI,CAACrE,UAAU,EAAE;MACnB,MAAM+E,aAAa,GAAG,IAAI,CAAC7E,IAAI,CAACK,MAAM,CAAC+D,qBAAqB,CAAC;QAC3DnD,KAAK,EAAE,eAAe;QACtBoD,OAAO,EAAE;QACP;UACEC,OAAO,EAAE,CAAC;UACVC,UAAU,EAAEC,cAAc,CAACC,OAAO;UAClCK,cAAc,EAAE;YACdC,MAAM,EAAE,YAAY;YACpBvC,MAAM,EAAE,SAAS;YACjBwC,aAAa,EAAE;UACjB;QACF,CAAC;;MAEL,CAAC,CAAC;MACFJ,OAAO,GAAG,CAACT,UAAU,EAAEU,aAAa,CAAC;;MAErC,MAAMI,YAAY,GAAI,IAAI,CAACrC,QAAQ,CAAyBC,aAAa,CAACP,SAAS;MACnF,IAAI,CAAC4C,gBAAgB,GAAG,IAAI,CAAClF,IAAI,CAACK,MAAM,CAAC8E,eAAe,CAAC;QACvDlE,KAAK,EAAE,kBAAkB;QACzBoD,OAAO,EAAE;QACP;UACEC,OAAO,EAAE,CAAC;UACVc,QAAQ,EAAEH,YAAY,CAACI,UAAU,CAAC;QACpC,CAAC,CACF;;QACDC,MAAM,EAAET;MACV,CAAC,CAAC;IACJ;IACA,IAAI,CAACU,YAAY,GAAG,IAAI,CAACvF,IAAI,CAACK,MAAM,CAACmF,qBAAqB,CAAC;MACzDvE,KAAK,EAAE,cAAc;MACrBqE,MAAM,EAAE,IAAI,CAACtF,IAAI,CAACK,MAAM,CAACoF,oBAAoB,CAAC;QAC5CC,gBAAgB,EAAEd;MACpB,CAAC,CAAC;MACFe,OAAO,EAAE;QACPC,MAAM,EAAE,IAAI,CAAC5F,IAAI,CAACK,MAAM,CAACwF,kBAAkB,CAAC;UAC1CC,IAAI,EAAElG;QACR,CAAC,CAAC;QACFmG,UAAU,EAAE;MACd;IACF,CAAC,CAAC;IACF,IAAI,CAACC,aAAa,GAAG,IAAI,CAAChG,IAAI,CAACK,MAAM,CAAC8E,eAAe,CAAC;MACpDlE,KAAK,EAAE,eAAe;MACtBoD,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACd,aAAa,CAAC9B,SAAS,CAAC,CAAC,CAAC,CAAC;MAC1E,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACC,WAAW,CAAC7C,SAAS,CAAC,CAAC,CAAC,CAAC;MACxE,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACG,kBAAkB,CAAC/C,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAEvB,WAAW,CAAC,CAAC,CAAC,CAAC;MACjD,EAAEmB,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACO,YAAY,CAACnD,SAAS,CAAC,CAAC,CAAC,CAAC,CAC1E;;MACDuE,MAAM,EAAEnB;IACV,CAAC,CAAC;;IAEF,MAAM8B,YAAY,GAAG,IAAI,CAACjG,IAAI,CAACK,MAAM,CAAC+D,qBAAqB,CAAC;MAC1DnD,KAAK,EAAE,cAAc;MACrBoD,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MAC/E,EAAEL,OAAO,EAAE,CAAC,EAAEC,UAAU,EAAEC,cAAc,CAACC,OAAO,EAAEC,MAAM,EAAE,EAAEC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;;IAEnF,CAAC,CAAC;IACF,IAAI,CAACuB,cAAc,GAAG,IAAI,CAAClG,IAAI,CAACK,MAAM,CAACmF,qBAAqB,CAAC;MAC3DvE,KAAK,EAAE,gBAAgB;MACvBqE,MAAM,EAAE,IAAI,CAACtF,IAAI,CAACK,MAAM,CAACoF,oBAAoB,CAAC;QAC5CC,gBAAgB,EAAE,CAACO,YAAY;MACjC,CAAC,CAAC;MACFN,OAAO,EAAE;QACPC,MAAM,EAAE,IAAI,CAAC5F,IAAI,CAACK,MAAM,CAACwF,kBAAkB,CAAC;UAC1CC,IAAI,EAAEjG;QACR,CAAC,CAAC;QACFkG,UAAU,EAAE;MACd;IACF,CAAC,CAAC;IACF,IAAI,CAACI,eAAe,GAAG,IAAI,CAACnG,IAAI,CAACK,MAAM,CAAC8E,eAAe,CAAC;MACtDlE,KAAK,EAAE,iBAAiB;MACxBoD,OAAO,EAAE;MACP,EAAEC,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACd,aAAa,CAAC9B,SAAS,CAAC,CAAC,CAAC,CAAC;MAC1E,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACC,WAAW,CAAC7C,SAAS,CAAC,CAAC,CAAC,CAAC;MACxE,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACE,WAAW,CAAC9C,SAAS,CAAC,CAAC,CAAC,CAAC;MACxE,EAAEuD,OAAO,EAAE,CAAC,EAAEc,QAAQ,EAAE,EAAEV,MAAM,EAAE,IAAI,CAACf,OAAO,CAACO,YAAY,CAACnD,SAAS,CAAC,CAAC,CAAC,CAAC,CAC1E;;MACDuE,MAAM,EAAEW;IACV,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,GAAGA,CAACC,UAAkB,EAAEC,SAAiB,EAAiB;IAC9D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,EAAEE,CAAC,EAAE,EAAE;MACnC,MAAMC,aAAa,GAAG,IAAI,CAACC,gBAAgB;QACzC,IAAI,CAAC9G,MAAM,CAACgB,iBAAiB;QAC7B,IAAI,CAAChB,MAAM,CAACa;MACd,CAAC;MACD,MAAM,IAAI,CAACkG,qBAAqB,CAACF,aAAa,CAAC;MAC/C,MAAM,IAAI,CAACG,mBAAmB,CAACH,aAAa,CAAC;MAC7C,MAAM,IAAI,CAACI,eAAe,CAAC,CAAC;MAC5B,MAAMC,OAAO,GAAG,IAAI,CAAC7G,IAAI,CAACK,MAAM,CAACyG,oBAAoB,CAAC,CAAC;MACvD,IAAI,CAACC,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACd,aAAa,CAAC;MAC5D,IAAI,CAACkE,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACC,WAAW,CAAC;MAC1D,IAAI,CAACmD,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACE,WAAW,CAAC;MAC1D,IAAI,CAACkD,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACI,OAAO,CAAC;MACtD,IAAI,CAACgD,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACG,kBAAkB,CAAC;MACjE,IAAI,CAACiD,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACK,UAAU,CAAC;MACzD,IAAI,CAAC+C,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACM,sBAAsB,CAAC;MACrE,IAAI,CAAC8C,kBAAkB,CAACF,OAAO,EAAE,IAAI,CAAClD,OAAO,CAACO,YAAY,CAAC;MAC3D,IAAI,IAAI,CAACpE,UAAU,EAAE;QACnB,IAAI,CAACkH,mBAAmB,CAACH,OAAO,EAAG,IAAI,CAACjE,QAAQ,CAAyBC,aAAa,CAAC;MACzF;;MAEA,MAAMoE,QAAQ,GAAGJ,OAAO,CAACK,gBAAgB,CAAC,CAAC;MAC3CD,QAAQ,CAACE,WAAW,CAAC,IAAI,CAAC5B,YAAY,CAAC;MACvC0B,QAAQ,CAACG,YAAY,CAAC,CAAC,EAAE,IAAI,CAACpB,aAAa,CAAC;MAC5C,IAAI,IAAI,CAAClG,UAAU,EAAE;QACnBmH,QAAQ,CAACG,YAAY,CAAC,CAAC,EAAE,IAAI,CAAClC,gBAAgC,CAAC;MACjE;MACA+B,QAAQ,CAACI,kBAAkB,CAACb,aAAa,CAAC;MAC1CS,QAAQ,CAACK,GAAG,CAAC,CAAC;;MAEd,MAAMC,UAAU,GAAGV,OAAO,CAACK,gBAAgB,CAAC,CAAC;MAC7CK,UAAU,CAACJ,WAAW,CAAC,IAAI,CAACjB,cAAc,CAAC;MAC3CqB,UAAU,CAACH,YAAY,CAAC,CAAC,EAAE,IAAI,CAACjB,eAAe,CAAC;MAChDoB,UAAU,CAACF,kBAAkB,CAAC,IAAI,CAAC1H,MAAM,CAACgB,iBAAiB,CAAC;MAC5D4G,UAAU,CAACD,GAAG,CAAC,CAAC;;MAEhB,IAAI,CAACtH,IAAI,CAACK,MAAM,CAACmH,KAAK,CAACC,MAAM,CAAC,CAACZ,OAAO,CAACa,MAAM,CAAC,CAAC,CAAC,CAAC;MACjD,IAAI,CAAC1H,IAAI,CAAC2H,8BAA8B;QACtC,IAAI,CAAChE,OAAO,CAACE,WAAW,CAAC9C,SAAS;QAClC,IAAI,CAAC6G,cAAc,CAACtB,SAAS,CAAC;QAC9B;UACE3B,IAAI,EAAEkD,WAAW;UACjBC,WAAW,EAAE,IAAI,CAACnI,MAAM,CAACiC;QAC3B;MACF,CAAC;IACH;EACF;;EAEA;EACUgG,cAAcA,CAACtB,SAAiB,EAAyC;IACjF,MAAMyB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACzB,SAAS,CAAC;IAC/C,MAAM0B,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC1B,SAAS,CAAC;IACnD,OAAO,UAAU2B,CAAc,EAAqB;MAClD,OAAOjK,0BAA0B,CAACiK,CAAC,EAAEF,WAAW,EAAE;QAChDG,gBAAgB,EAAE,CAAC,EAAEC,UAAU,EAAE,aAAa,EAAEC,eAAe,EAAEJ,aAAa,CAAC,CAAC;MAClF,CAAC,CAAC;IACJ,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACYD,WAAWA,CAACzB,SAAiB,EAA8C;IACnF,OAAO,UAAUC,CAAS,EAAE8B,CAAkB,EAAW;MACvD,IAAI9B,CAAC,KAAKD,SAAS,IAAI+B,CAAC,GAAG,CAAC,EAAE;QAC5B,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC;EACH;;EAEA;EACUL,aAAaA,CAAC1B,SAAiB,EAA2C;IAClF,OAAO,UAAUC,CAAS,EAAmB;MAC3C,IAAIA,CAAC,KAAKD,SAAS,EAAE;QACnB,OAAO,CAAC;MACV,CAAC,MAAM;QACL,OAAO,WAAW;MACpB;IACF,CAAC;EACH;;EAEA;EACUS,kBAAkBA;EAC1BF,OAA0B;EAC1BnC,MAA8C;EACxC;IACNmC,OAAO,CAACE,kBAAkB;MACxBrC,MAAM,CAACnD,MAAM;MACb,CAAC;MACDmD,MAAM,CAAC3D,SAAS;MACf2D,MAAM,CAAyBrB,MAAM,IAAI,CAAC;MAC3CqB,MAAM,CAACxD;IACT,CAAC;EACH;;EAEA;EACU8F,mBAAmBA,CAACH,OAA0B,EAAEyB,OAA0B,EAAQ;IAC1F,MAAMlJ,YAAY,GAAG,CAAC,CAAC,CAAC;IACxB,MAAM6C,SAAS,GAAGqG,OAAO,CAACpH,IAAI,GAAG9B,YAAY;IAC7C,MAAM8B,IAAiB,GAAG,EAAEgB,KAAK,EAAE9D,MAAM,EAAE+D,MAAM,EAAEF,SAAS,GAAG7D,MAAM,CAAC,CAAC;IACvEyI,OAAO,CAACG,mBAAmB;MACzB;QACEtC,MAAM,EAAE4D,OAAO,CAAC/G,MAAM;QACtB8B,MAAM,EAAE,CAAC;QACTkF,WAAW,EAAEnK,MAAM,GAAGgB,YAAY;QAClCoJ,YAAY,EAAEtH,IAAI,CAACiB;MACrB,CAAC;MACD,EAAEmG,OAAO,EAAEA,OAAO,CAAChG,SAAS,CAAC,CAAC;MAC9BpB;IACF,CAAC;EACH;;EAEA;EACUuH,YAAYA,CAACC,GAAW,EAAU;IAC1C,OAAO,IAAI,CAAC3I,IAAI,CAAC4I,SAAS,CAAC,CAAC,GAAGD,GAAG;EACpC;;EAEA;EACUjC,gBAAgBA,CAACtG,GAAW,EAAEuI,GAAW,EAAU;IAC3D,IAAIvI,GAAG,KAAKuI,GAAG,EAAE;MACf,OAAOvI,GAAG;IACZ,CAAC,MAAM;MACL,MAAMkD,MAAM,GAAG,IAAI,CAACoF,YAAY,CAACC,GAAG,GAAGvI,GAAG,CAAC;MAC3C,OAAOA,GAAG,GAAGkD,MAAM;IACrB;EACF;;EAEA;EACUuF,YAAYA,CAACX,CAAW,EAAQ;IACxC,KAAK,IAAI1B,CAAC,GAAG0B,CAAC,CAACY,MAAM,GAAG,CAAC,EAAEtC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACtC,MAAMuC,MAAM,GAAG,IAAI,CAACL,YAAY,CAAClC,CAAC,GAAG,CAAC,CAAC;MACvC,MAAMwC,IAAI,GAAGd,CAAC,CAACa,MAAM,CAAC;MACtBb,CAAC,CAACa,MAAM,CAAC,GAAGb,CAAC,CAAC1B,CAAC,CAAC;MAChB0B,CAAC,CAAC1B,CAAC,CAAC,GAAGwC,IAAI;IACb;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAgBrC,qBAAqBA,CAACF,aAAqB,EAAiB;IAC1E,MAAM,IAAI,CAAC7C,OAAO,CAACG,kBAAkB,CAACvC,MAAM,CAACyH,QAAQ,CAACC,UAAU,CAACC,KAAK,CAAC;IACvE,MAAMnH,wBAAwB,GAAG,IAAI,CAAC4B,OAAO,CAACG,kBAAkB,CAACvC,MAAM,CAAC4H,cAAc,CAAC,CAAC;IACxF,MAAMC,uBAAuB,GAAG,IAAIvB,WAAW,CAAC9F,wBAAwB,CAAC;IACzE,KAAK,IAAIwE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,aAAa,EAAED,CAAC,EAAE,EAAE;MACtC6C,uBAAuB,CAAC7C,CAAC,CAAC,GAAGA,CAAC;IAChC;IACA,IAAI,IAAI,CAACkC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAAC0J,UAAU,EAAE;MACnD,KAAK,IAAI9C,CAAC,GAAGC,aAAa,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1C,MAAM+C,CAAC,GAAG,IAAI,CAACb,YAAY,CAAClC,CAAC,GAAG,CAAC,CAAC;QAClC,MAAMwC,IAAI,GAAGK,uBAAuB,CAAC7C,CAAC,CAAC;QACvC6C,uBAAuB,CAAC7C,CAAC,CAAC,GAAG6C,uBAAuB,CAACE,CAAC,CAAC;QACvDF,uBAAuB,CAACE,CAAC,CAAC,GAAGP,IAAI;MACnC;IACF;IACA,IAAI,CAACpF,OAAO,CAACG,kBAAkB,CAACvC,MAAM,CAACgI,KAAK,CAAC,CAAC;EAChD;;EAEA;EACA,MAAgB5C,mBAAmBA,CAACH,aAAqB,EAAiB;IACxE,MAAM,IAAI,CAAC7C,OAAO,CAACM,sBAAsB,CAAC1C,MAAM,CAACyH,QAAQ,CAACC,UAAU,CAACC,KAAK,CAAC;IAC3E,MAAMM,2BAA2B,GAAG,IAAI,CAAC7F,OAAO,CAACM,sBAAsB,CAAC1C,MAAM,CAAC4H,cAAc,CAAC,CAAC;IAC/F,MAAMM,qBAAqB,GAAG,IAAI5B,WAAW,CAAC2B,2BAA2B,CAAC;IAC1E,MAAME,iBAAiB,GAAG,IAAI,CAAC/J,MAAM,CAACc,iBAAiB,GAAG,IAAI,CAACd,MAAM,CAACgK,cAAc;IACpF,MAAMC,cAAc,GAAG,CAAC,GAAGC,KAAK,CAACH,iBAAiB,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;IAC3D,IAAI,CAAClB,YAAY,CAACgB,cAAc,CAAC;IACjC,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5G,MAAM,CAACoK,iBAAiB,EAAExD,CAAC,EAAE,EAAE;MACtD,MAAMyD,MAAM,GAAGJ,cAAc,CAACrD,CAAC,CAAC;MAChC,MAAM0D,WAAW,GAAG,IAAI,CAACxB,YAAY,CAAC,IAAI,CAAC9I,MAAM,CAACgK,cAAc,CAAC;MACjE,IAAI,IAAI,CAAClB,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACuK,wBAAwB,EAAE;QACjE;QACA,KAAK,IAAIC,CAAC,GAAG5D,CAAC,EAAE4D,CAAC,GAAG3D,aAAa,EAAE2D,CAAC,IAAI,IAAI,CAACxK,MAAM,CAACoK,iBAAiB,EAAE;UACrEN,qBAAqB,CAACU,CAAC,CAAC,GAAGH,MAAM,GAAG,IAAI,CAACrK,MAAM,CAACgK,cAAc,GAAGM,WAAW;QAC9E;MACF,CAAC,MAAM;QACL;QACA;QACA;QACA,MAAMG,qBAAqB,GAAG5D,aAAa,GAAG,IAAI,CAAC7G,MAAM,CAACoK,iBAAiB;QAC3E,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,qBAAqB,EAAED,CAAC,EAAE,EAAE;UAC9CV,qBAAqB,CAAClD,CAAC,GAAG6D,qBAAqB,GAAGD,CAAC,CAAC;UAClDH,MAAM,GAAG,IAAI,CAACrK,MAAM,CAACgK,cAAc,GAAGM,WAAW;QACrD;QACA;QACE1D,CAAC,KAAK,IAAI,CAAC5G,MAAM,CAACoK,iBAAiB,GAAG,CAAC;QACvCvD,aAAa,GAAG,IAAI,CAAC7G,MAAM,CAACoK,iBAAiB,KAAK,CAAC;QACnD;UACA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3D,aAAa,GAAG,IAAI,CAAC7G,MAAM,CAACoK,iBAAiB,EAAEI,CAAC,EAAE,EAAE;YACtEV,qBAAqB,CAACjD,aAAa,GAAG2D,CAAC,GAAG,CAAC,CAAC;YAC1CH,MAAM,GAAG,IAAI,CAACrK,MAAM,CAACgK,cAAc,GAAGM,WAAW;UACrD;QACF;MACF;IACF;IACA,IAAI,CAACtG,OAAO,CAACM,sBAAsB,CAAC1C,MAAM,CAACgI,KAAK,CAAC,CAAC;EACpD;;EAEA;EACA,MAAgB3C,eAAeA,CAAA,EAAkB;IAC/C,MAAM,IAAI,CAACjD,OAAO,CAACO,YAAY,CAAC3C,MAAM,CAACyH,QAAQ,CAACC,UAAU,CAACC,KAAK,CAAC;IACjE,MAAMmB,uBAAuB,GAAG,IAAI,CAAC1G,OAAO,CAACO,YAAY,CAAC3C,MAAM,CAAC4H,cAAc,CAAC,CAAC;IACjF,MAAMmB,iBAAiB,GAAG,IAAIzC,WAAW,CAACwC,uBAAuB,CAAC;IAClE,IAAI,IAAI,CAAC5B,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAAC4K,UAAU,EAAE;MACnDD,iBAAiB,CAAC9L,iBAAiB,CAAC,GAAG,CAAC;IAC1C,CAAC,MAAM;MACL8L,iBAAiB,CAAC9L,iBAAiB,CAAC,GAAG,CAAC;IAC1C;IACA,IAAI,IAAI,CAACiK,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAAC6K,YAAY,EAAE;MACrDF,iBAAiB,CAAC7L,cAAc,CAAC,GAAG,CAAC;IACvC,CAAC,MAAM;MACL6L,iBAAiB,CAAC7L,cAAc,CAAC,GAAG,CAAC;IACvC;IACA6L,iBAAiB,CAAC5L,wBAAwB,CAAC,GAAG,IAAI,CAACiB,MAAM,CAAC8K,mBAAmB;IAC7E,MAAMC,mBAAmB,GAAG,IAAI,CAACjC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACgL,sBAAsB;IACvF,MAAMC,oBAAoB,GAAG,IAAI,CAACnC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACkL,uBAAuB;IACzF,IAAIC,gBAAgB;IACpB,IAAIJ,mBAAmB,IAAIE,oBAAoB,EAAE;MAC/CE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM,IAAIJ,mBAAmB,IAAI,CAACE,oBAAoB,EAAE;MACvDE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM,IAAI,CAACJ,mBAAmB,IAAIE,oBAAoB,EAAE;MACvDE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM;MACLA,gBAAgB,GAAG,CAAC;IACtB;IACAR,iBAAiB,CAAC3L,qBAAqB,CAAC,GAAGmM,gBAAgB;IAC3D,IAAI,IAAI,CAACrC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACoL,YAAY,EAAE;MACrDT,iBAAiB,CAAC1L,cAAc,CAAC,GAAG,CAAC;IACvC,CAAC,MAAM;MACL0L,iBAAiB,CAAC1L,cAAc,CAAC,GAAG,CAAC;IACvC;IACA0L,iBAAiB,CAACzL,wBAAwB,CAAC,GAAG,IAAI,CAACc,MAAM,CAACqL,mBAAmB;IAC7E,MAAMC,mBAAmB,GAAG,IAAI,CAACxC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACuL,sBAAsB;IACvF,MAAMC,oBAAoB,GAAG,IAAI,CAAC1C,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC9I,MAAM,CAACyL,uBAAuB;IACzF,IAAIC,gBAAgB;IACpB,IAAIJ,mBAAmB,IAAIE,oBAAoB,EAAE;MAC/CE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM,IAAIJ,mBAAmB,IAAI,CAACE,oBAAoB,EAAE;MACvDE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM,IAAI,CAACJ,mBAAmB,IAAIE,oBAAoB,EAAE;MACvDE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM;MACLA,gBAAgB,GAAG,CAAC;IACtB;IACAf,iBAAiB,CAACxL,qBAAqB,CAAC,GAAGuM,gBAAgB;IAC3Df,iBAAiB,CAACvL,iBAAiB,CAAC,GAAG,IAAI,CAACY,MAAM,CAAC2L,YAAY;IAC/DhB,iBAAiB,CAACtL,kBAAkB,CAAC,GAAG,IAAI,CAACW,MAAM,CAAC4L,aAAa;IACjEjB,iBAAiB,CAACrL,sBAAsB,CAAC,GAAG,IAAI,CAACU,MAAM,CAACgB,iBAAiB;IACzE2J,iBAAiB,CAACpL,cAAc,CAAC,GAAG,IAAI,CAACS,MAAM,CAACkB,SAAS;IACzD,IAAI,IAAI,CAAClB,MAAM,CAAC6L,aAAa,EAAE;MAC7BlB,iBAAiB,CAACnL,sBAAsB,CAAC,GAAG,CAAC;IAC/C,CAAC,MAAM;MACLmL,iBAAiB,CAACnL,sBAAsB,CAAC,GAAG,IAAI,CAACQ,MAAM,CAACkB,SAAS;IACnE;IACA,IAAI,CAAC8C,OAAO,CAACO,YAAY,CAAC3C,MAAM,CAACgI,KAAK,CAAC,CAAC;EAC1C;AACF;;AAEA;AACA,MAAMkC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAG;AAC9B;AACH;AACA,CAAC;AACCD,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMC,2BAA2B,GAAG;AACjC;AACH;AACA,CAAC;AACCH,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAME,eAAe,GAAI;AACzB;AACA,CAAC;;AAED;AACA,MAAMC,oBAAoB,GAAI;AAC9B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAI;AAC/B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,MAAMC,gBAAgB,GAAI;AAC1B,mBAAmBjO,MAAO;AAC1B;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMkO,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAI;AAChC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAG;AAClC;AACH;AACA;AACA;AACA;AACA,CAAC;AACCD,4BAA4B;AAC3B;AACH;AACA;AACA;AACA,CAAC,CACA;AAACX,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA;AACA;AACA;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"}
{"version":3,"file":"atomicity.spec.js","names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildTestShader","TestType","buildResultShader","ResultType","MemoryType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numBehaviors","storageMemoryTestCode","workgroupMemoryTestCode","resultCode","test","desc","paramsSimple","memType","AtomicStorageClass","testType","InterWorkgroup","_testCode","IntraWorkgroup","AtomicWorkgroupClass","fn","t","testShader","params","resultShader","FourBehavior","memModelTester","run"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/atomicity.spec.ts"],"sourcesContent":["export const description = `Tests for the atomicity of atomic read-modify-write instructions.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildTestShader,\n  TestType,\n  buildResultShader,\n  ResultType,\n  MemoryType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 512,\n  maxWorkgroups: 1024,\n  shufflePct: 100,\n  barrierPct: 100,\n  memStressPct: 100,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 100,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 419,\n  memStride: 4,\n  aliasedMemory: false,\n  numBehaviors: 4,\n};\n\nconst storageMemoryTestCode = `\n  let r0 = atomicAdd(&test_locations.value[x_0], 0u);\n  atomicStore(&test_locations.value[x_1], 2u);\n  atomicStore(&results.value[id_0].r0, r0);\n`;\n\nconst workgroupMemoryTestCode = `\n  let r0 = atomicAdd(&wg_test_locations[x_0], 0u);\n  atomicStore(&wg_test_locations[x_1], 2u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst resultCode = `\n  if ((r0 == 0u && mem_x_0 == 2u)) {\n    atomicAdd(&test_results.seq0, 1u);\n  } else if ((r0 == 2u && mem_x_0 == 1u)) {\n    atomicAdd(&test_results.seq1, 1u);\n  } else if ((r0 == 0u && mem_x_0 == 1u)) {\n    atomicAdd(&test_results.weak, 1u);\n  }\n`;\n\ng.test('atomicity')\n  .desc(\n    `Checks whether a store on one thread can interrupt an atomic RMW on a second thread. If the read returned by\n    the RMW instruction is the initial value of memory (0), but the final value in memory is 1, then the atomic write\n    in the second thread occurred in between the read and the write of the RMW.\n    `\n  )\n  .paramsSimple([\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.InterWorkgroup,\n      _testCode: storageMemoryTestCode,\n    },\n    {\n      memType: MemoryType.AtomicStorageClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: storageMemoryTestCode,\n    },\n    {\n      memType: MemoryType.AtomicWorkgroupClass,\n      testType: TestType.IntraWorkgroup,\n      _testCode: workgroupMemoryTestCode,\n    },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(t.params._testCode, t.params.memType, t.params.testType);\n    const resultShader = buildResultShader(resultCode, t.params.testType, ResultType.FourBehavior);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(10, 3);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI,mEAAkE,CAE9F,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SAASC,OAAO,QAAQ,sBAAsB;;AAE9C;;EAEEC,iBAAiB;EACjBC,eAAe;EACfC,QAAQ;EACRC,iBAAiB;EACjBC,UAAU;EACVC,UAAU;AACL,yBAAyB;;AAEhC,OAAO,MAAMC,CAAC,GAAGR,aAAa,CAACC,OAAO,CAAC;;AAEvC;AACA,MAAMQ,qBAA4C,GAAG;EACnDC,aAAa,EAAE,GAAG;EAClBC,iBAAiB,EAAE,GAAG;EACtBC,aAAa,EAAE,IAAI;EACnBC,UAAU,EAAE,GAAG;EACfC,UAAU,EAAE,GAAG;EACfC,YAAY,EAAE,GAAG;EACjBC,mBAAmB,EAAE,IAAI;EACzBC,sBAAsB,EAAE,EAAE;EAC1BC,uBAAuB,EAAE,EAAE;EAC3BC,YAAY,EAAE,GAAG;EACjBC,mBAAmB,EAAE,IAAI;EACzBC,sBAAsB,EAAE,EAAE;EAC1BC,uBAAuB,EAAE,EAAE;EAC3BC,iBAAiB,EAAE,IAAI;EACvBC,cAAc,EAAE,EAAE;EAClBC,iBAAiB,EAAE,CAAC;EACpBC,wBAAwB,EAAE,EAAE;EAC5BC,YAAY,EAAE,GAAG;EACjBC,aAAa,EAAE,GAAG;EAClBC,SAAS,EAAE,CAAC;EACZC,aAAa,EAAE,KAAK;EACpBC,YAAY,EAAE;AAChB,CAAC;;AAED,MAAMC,qBAAqB,GAAI;AAC/B;AACA;AACA;AACA,CAAC;;AAED,MAAMC,uBAAuB,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,MAAMC,UAAU,GAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED1B,CAAC,CAAC2B,IAAI,CAAC,WAAW,CAAC;AAChBC,IAAI;EACF;AACL;AACA;AACA;AACE,CAAC;AACAC,YAAY,CAAC;AACZ;EACEC,OAAO,EAAE/B,UAAU,CAACgC,kBAAkB;EACtCC,QAAQ,EAAEpC,QAAQ,CAACqC,cAAc;EACjCC,SAAS,EAAEV;AACb,CAAC;AACD;EACEM,OAAO,EAAE/B,UAAU,CAACgC,kBAAkB;EACtCC,QAAQ,EAAEpC,QAAQ,CAACuC,cAAc;EACjCD,SAAS,EAAEV;AACb,CAAC;AACD;EACEM,OAAO,EAAE/B,UAAU,CAACqC,oBAAoB;EACxCJ,QAAQ,EAAEpC,QAAQ,CAACuC,cAAc;EACjCD,SAAS,EAAET;AACb,CAAC;AACF,CAAC;AACDY,EAAE,CAAC,OAAMC,CAAC,KAAI;EACb,MAAMC,UAAU,GAAG5C,eAAe,CAAC2C,CAAC,CAACE,MAAM,CAACN,SAAS,EAAEI,CAAC,CAACE,MAAM,CAACV,OAAO,EAAEQ,CAAC,CAACE,MAAM,CAACR,QAAQ,CAAC;EAC3F,MAAMS,YAAY,GAAG5C,iBAAiB,CAAC6B,UAAU,EAAEY,CAAC,CAACE,MAAM,CAACR,QAAQ,EAAElC,UAAU,CAAC4C,YAAY,CAAC;EAC9F,MAAMC,cAAc,GAAG,IAAIjD,iBAAiB;IAC1C4C,CAAC;IACDrC,qBAAqB;IACrBsC,UAAU;IACVE;EACF,CAAC;EACD,MAAME,cAAc,CAACC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACjC,CAAC,CAAC"}
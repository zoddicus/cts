{"version":3,"file":"barrier.spec.js","names":["description","makeTestGroup","GPUTest","MemoryModelTester","kAccessValueTypes","buildTestShader","MemoryType","TestType","buildResultShader","ResultType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numBehaviors","kMemTypes","NonAtomicStorageClass","NonAtomicWorkgroupClass","storageMemoryBarrierStoreLoadTestCode","workgroupMemoryBarrierStoreLoadTestCode","storageMemoryBarrierLoadStoreTestCode","workgroupMemoryBarrierLoadStoreTestCode","storageMemoryBarrierStoreStoreTestCode","workgroupMemoryBarrierStoreStoreTestCode","getTestCode","p","accessPair","memType","test","desc","params","u","combine","beforeAllSubcases","t","accessValueType","selectDeviceOrSkipTestCase","fn","resultCode","testShader","IntraWorkgroup","resultShader","TwoBehavior","memModelTester","run"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/barrier.spec.ts"],"sourcesContent":["export const description = `\nTests for non-atomic memory synchronization within a workgroup in the presence of a WebGPU barrier`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  kAccessValueTypes,\n  buildTestShader,\n  MemoryType,\n  TestType,\n  buildResultShader,\n  ResultType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 512,\n  maxWorkgroups: 1024,\n  shufflePct: 100,\n  barrierPct: 100,\n  memStressPct: 100,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 100,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 419,\n  memStride: 4,\n  aliasedMemory: false,\n  numBehaviors: 2,\n};\n\n// The two kinds of non-atomic accesses tested.\n//  rw: read -> barrier -> write\n//  wr: write -> barrier -> read\n//  ww: write -> barrier -> write\ntype AccessPair = 'rw' | 'wr' | 'ww';\n\n// Test the non-atomic memory types.\nconst kMemTypes = [MemoryType.NonAtomicStorageClass, MemoryType.NonAtomicWorkgroupClass] as const;\n\nconst storageMemoryBarrierStoreLoadTestCode = `\n  test_locations.value[x_0] = 1;\n  workgroupBarrier();\n  let r0 = u32(test_locations.value[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n`;\n\nconst workgroupMemoryBarrierStoreLoadTestCode = `\n  wg_test_locations[x_0] = 1;\n  workgroupBarrier();\n  let r0 = u32(wg_test_locations[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n`;\n\nconst storageMemoryBarrierLoadStoreTestCode = `\n  let r0 = u32(test_locations.value[x_0]);\n  workgroupBarrier();\n  test_locations.value[x_1] = 1;\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst workgroupMemoryBarrierLoadStoreTestCode = `\n  let r0 = u32(wg_test_locations[x_0]);\n  workgroupBarrier();\n  wg_test_locations[x_1] = 1;\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n`;\n\nconst storageMemoryBarrierStoreStoreTestCode = `\n  test_locations.value[x_0] = 1;\n  storageBarrier();\n  test_locations.value[x_1] = 2;\n`;\n\nconst workgroupMemoryBarrierStoreStoreTestCode = `\n  wg_test_locations[x_0] = 1;\n  workgroupBarrier();\n  wg_test_locations[x_1] = 2;\n  workgroupBarrier();\n  test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1] = wg_test_locations[x_1];\n`;\n\nfunction getTestCode(p: { memType: MemoryType; accessPair: AccessPair }): string {\n  switch (p.accessPair) {\n    case 'rw':\n      return p.memType === MemoryType.NonAtomicStorageClass\n        ? storageMemoryBarrierLoadStoreTestCode\n        : workgroupMemoryBarrierLoadStoreTestCode;\n    case 'wr':\n      return p.memType === MemoryType.NonAtomicStorageClass\n        ? storageMemoryBarrierStoreLoadTestCode\n        : workgroupMemoryBarrierStoreLoadTestCode;\n    case 'ww':\n      return p.memType === MemoryType.NonAtomicStorageClass\n        ? storageMemoryBarrierStoreStoreTestCode\n        : workgroupMemoryBarrierStoreStoreTestCode;\n  }\n}\n\ng.test('workgroup_barrier_store_load')\n  .desc(\n    `Checks whether the workgroup barrier properly synchronizes a non-atomic write and read on\n    separate threads in the same workgroup. Within a workgroup, the barrier should force an invocation\n    after the barrier to read a write from an invocation before the barrier.\n    `\n  )\n  .params(u =>\n    u\n      .combine('accessValueType', kAccessValueTypes)\n      .combine('memType', kMemTypes)\n      .combine('accessPair', ['wr'] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.accessValueType === 'f16') {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(async t => {\n    const resultCode = `\n      if (r0 == 1u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (r0 == 0u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(\n      getTestCode(t.params),\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const resultShader = buildResultShader(\n      resultCode,\n      TestType.IntraWorkgroup,\n      ResultType.TwoBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader,\n      t.params.accessValueType\n    );\n    await memModelTester.run(15, 1);\n  });\n\ng.test('workgroup_barrier_load_store')\n  .desc(\n    `Checks whether the workgroup barrier properly synchronizes a non-atomic write and read on\n    separate threads in the same workgroup. Within a workgroup, the barrier should force an invocation\n    before the barrier to not read the write from an invocation after the barrier.\n    `\n  )\n  .params(u =>\n    u\n      .combine('accessValueType', kAccessValueTypes)\n      .combine('memType', kMemTypes)\n      .combine('accessPair', ['rw'] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.accessValueType === 'f16') {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(async t => {\n    const resultCode = `\n      if (r0 == 0u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (r0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(\n      getTestCode(t.params),\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const resultShader = buildResultShader(\n      resultCode,\n      TestType.IntraWorkgroup,\n      ResultType.TwoBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader,\n      t.params.accessValueType\n    );\n    await memModelTester.run(12, 1);\n  });\n\ng.test('workgroup_barrier_store_store')\n  .desc(\n    `Checks whether the workgroup barrier properly synchronizes non-atomic writes on\n    separate threads in the same workgroup. Within a workgroup, the barrier should force the value in memory\n    to be the result of the write after the barrier, not the write before.\n    `\n  )\n  .params(u =>\n    u\n      .combine('accessValueType', kAccessValueTypes)\n      .combine('memType', kMemTypes)\n      .combine('accessPair', ['ww'] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.accessValueType === 'f16') {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(async t => {\n    const resultCode = `\n      if (mem_x_0 == 2u) {\n        atomicAdd(&test_results.seq, 1u);\n      } else if (mem_x_0 == 1u) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n    const testShader = buildTestShader(\n      getTestCode(t.params),\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const resultShader = buildResultShader(\n      resultCode,\n      TestType.IntraWorkgroup,\n      ResultType.TwoBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader,\n      t.params.accessValueType\n    );\n    await memModelTester.run(10, 1);\n  });\n"],"mappings":"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"}
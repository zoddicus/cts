{"version":3,"file":"weak.spec.js","names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildTestShader","MemoryType","TestType","buildResultShader","ResultType","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numBehaviors","workgroupMemoryMessagePassingTestCode","storageMemoryMessagePassingTestCode","test","desc","paramsSimple","memType","AtomicWorkgroupClass","_testCode","AtomicStorageClass","fn","t","testShader","params","IntraWorkgroup","messagePassingResultShader","FourBehavior","memModelTester","run","workgroupMemoryStoreTestCode","storageMemoryStoreTestCode","workgroupMemoryLoadBufferTestCode","storageMemoryLoadBufferTestCode","workgroupMemoryReadTestCode","storageMemoryReadTestCode","workgroupMemoryStoreBufferTestCode","storageMemoryStoreBufferTestCode","workgroupMemory2P2WTestCode","storageMemory2P2WTestCode"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/weak.spec.ts"],"sourcesContent":["export const description = `\nTests for properties of the WebGPU memory model involving two memory locations.\nSpecifically, the acquire/release ordering provided by WebGPU's barriers can be used to disallow\nweak behaviors in several classic memory model litmus tests.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildTestShader,\n  MemoryType,\n  TestType,\n  buildResultShader,\n  ResultType,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 739,\n  maxWorkgroups: 885,\n  shufflePct: 0,\n  barrierPct: 0,\n  memStressPct: 0,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 100,\n  preStressIterations: 33,\n  preStressStoreFirstPct: 0,\n  preStressStoreSecondPct: 100,\n  scratchMemorySize: 1408,\n  stressLineSize: 4,\n  stressTargetLines: 11,\n  stressStrategyBalancePct: 0,\n  permuteFirst: 109,\n  permuteSecond: 419,\n  memStride: 2,\n  aliasedMemory: false,\n  numBehaviors: 4,\n};\n\nconst workgroupMemoryMessagePassingTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[y_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[y_1]);\n  workgroupBarrier();\n  let r1 = atomicLoad(&wg_test_locations[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst storageMemoryMessagePassingTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  storageBarrier();\n  atomicStore(&test_locations.value[y_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_1]);\n  storageBarrier();\n  let r1 = atomicLoad(&test_locations.value[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * u32(workgroupXSize) + id_1].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * u32(workgroupXSize) + id_1].r1, r1);\n`;\n\ng.test('message_passing')\n  .desc(\n    `Checks whether two reads on one thread can observe two writes in another thread in a way\n    that is inconsistent with sequential consistency. In the message passing litmus test, one\n    thread writes the value 1 to some location x and then 1 to some location y. The second thread\n    reads y and then x. If the second thread reads y == 1 and x == 0, then sequential consistency\n    has not been respected. The acquire/release semantics of WebGPU's barrier functions should disallow\n    this behavior within a workgroup.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemoryMessagePassingTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemoryMessagePassingTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n\nconst workgroupMemoryStoreTestCode = `\n  atomicStore(&wg_test_locations[x_0], 2u);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[y_0], 1u);\n  let r0 = atomicLoad(&wg_test_locations[y_1]);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[x_1], 1u);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n`;\n\nconst storageMemoryStoreTestCode = `\n  atomicStore(&test_locations.value[x_0], 2u);\n  storageBarrier();\n  atomicStore(&test_locations.value[y_0], 1u);\n  let r0 = atomicLoad(&test_locations.value[y_1]);\n  storageBarrier();\n  atomicStore(&test_locations.value[x_1], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n`;\n\ng.test('store')\n  .desc(\n    `In the store litmus test, one thread writes 2 to some memory location x and then 1 to some memory location\n     y. A second thread reads the value of y and then writes 1 to x. If the read on the second thread returns 1,\n     but the value of x in memory after the test ends is 2, then there has been a re-ordering which is not allowed\n     when using WebGPU's barriers.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemoryStoreTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemoryStoreTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((r0 == 1u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 0u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && mem_x_0 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && mem_x_0 == 2u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n\nconst workgroupMemoryLoadBufferTestCode = `\n  let r0 = atomicLoad(&wg_test_locations[y_0]);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[x_0], 1u);\n  let r1 = atomicLoad(&wg_test_locations[x_1]);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[y_1], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst storageMemoryLoadBufferTestCode = `\n  let r0 = atomicLoad(&test_locations.value[y_0]);\n  storageBarrier();\n  atomicStore(&test_locations.value[x_0], 1u);\n  let r1 = atomicLoad(&test_locations.value[x_1]);\n  storageBarrier();\n  atomicStore(&test_locations.value[y_1], 1u);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\ng.test('load_buffer')\n  .desc(\n    `In the load buffer litmus test, one thread reads from memory location y and then writes 1 to memory location x.\n     A second thread reads from x and then writes 1 to y. If both threads read the value 0, then the loads have been\n     buffered or re-ordered, which is not allowed when used in conjunction with WebGPU's barriers.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemoryLoadBufferTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemoryLoadBufferTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n\nconst workgroupMemoryReadTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  workgroupBarrier();\n  atomicExchange(&wg_test_locations[y_0], 1u);\n  atomicExchange(&wg_test_locations[y_1], 2u);\n  workgroupBarrier();\n  let r0 = atomicLoad(&wg_test_locations[x_1]);\n  workgroupBarrier();\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + y_1], atomicLoad(&wg_test_locations[y_1]));\n`;\n\nconst storageMemoryReadTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  storageBarrier();\n  atomicExchange(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[y_1], 2u);\n  storageBarrier();\n  let r0 = atomicLoad(&test_locations.value[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n`;\n\ng.test('read')\n  .desc(\n    `In the read litmus test, one thread writes 1 to memory location x and then 1 to memory location y. A second thread\n     first writes 2 to y and then reads from x. If the value read by the second thread is 0 but the value in memory of y\n     after the test completes is 2, then there has been some re-ordering of instructions disallowed when using WebGPU's\n     barrier. Additionally, both writes to y are RMWs, so that the barrier forces the correct acquire/release memory ordering\n     synchronization.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemoryReadTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemoryReadTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((r0 == 1u && mem_y_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 0u && mem_y_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 1u && mem_y_0 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 0u && mem_y_0 == 2u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n\nconst workgroupMemoryStoreBufferTestCode = `\n  atomicStore(&wg_test_locations[x_0], 1u);\n  workgroupBarrier();\n  let r0 = atomicAdd(&wg_test_locations[y_0], 0u);\n  atomicExchange(&wg_test_locations[y_1], 1u);\n  workgroupBarrier();\n  let r1 = atomicLoad(&wg_test_locations[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\nconst storageMemoryStoreBufferTestCode = `\n  atomicStore(&test_locations.value[x_0], 1u);\n  storageBarrier();\n  let r0 = atomicAdd(&test_locations.value[y_0], 0u);\n  atomicExchange(&test_locations.value[y_1], 1u);\n  storageBarrier();\n  let r1 = atomicLoad(&test_locations.value[x_1]);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_0].r0, r0);\n  atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n`;\n\ng.test('store_buffer')\n  .desc(\n    `In the store buffer litmus test, one thread writes 1 to memory location x and then reads from memory location\n     y. A second thread writes 1 to y and then reads from x. If both reads return 0, then stores have been buffered\n     or some other re-ordering has occurred that is disallowed by WebGPU's barriers. Additionally, both the read\n     and store to y are RMWs to achieve the necessary synchronization across threads.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemoryStoreBufferTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemoryStoreBufferTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n\nconst workgroupMemory2P2WTestCode = `\n  atomicStore(&wg_test_locations[x_0], 2u);\n  workgroupBarrier();\n  atomicExchange(&wg_test_locations[y_0], 1u);\n  atomicExchange(&wg_test_locations[y_1], 2u);\n  workgroupBarrier();\n  atomicStore(&wg_test_locations[x_1], 1u);\n  workgroupBarrier();\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + x_1], atomicLoad(&wg_test_locations[x_1]));\n  atomicStore(&test_locations.value[shuffled_workgroup * workgroupXSize * stress_params.mem_stride * 2u + y_1], atomicLoad(&wg_test_locations[y_1]));\n`;\n\nconst storageMemory2P2WTestCode = `\n  atomicStore(&test_locations.value[x_0], 2u);\n  storageBarrier();\n  atomicExchange(&test_locations.value[y_0], 1u);\n  atomicExchange(&test_locations.value[y_1], 2u);\n  storageBarrier();\n  atomicStore(&test_locations.value[x_1], 1u);\n`;\n\ng.test('2_plus_2_write')\n  .desc(\n    `In the 2+2 write litmus test, one thread stores 2 to memory location x and then 1 to memory location y.\n     A second thread stores 2 to y and then 1 to x. If at the end of the test both memory locations are set to 2,\n     then some disallowed re-ordering has occurred. Both writes to y are RMWs to achieve the required synchronization.\n    `\n  )\n  .paramsSimple([\n    { memType: MemoryType.AtomicWorkgroupClass, _testCode: workgroupMemory2P2WTestCode },\n    { memType: MemoryType.AtomicStorageClass, _testCode: storageMemory2P2WTestCode },\n  ])\n  .fn(async t => {\n    const testShader = buildTestShader(\n      t.params._testCode,\n      t.params.memType,\n      TestType.IntraWorkgroup\n    );\n    const messagePassingResultShader = buildResultShader(\n      `\n      if ((mem_x_0 == 1u && mem_y_0 == 2u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((mem_x_0 == 2u && mem_y_0 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((mem_x_0 == 1u && mem_y_0 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((mem_x_0 == 2u && mem_y_0 == 2u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n      `,\n      TestType.IntraWorkgroup,\n      ResultType.FourBehavior\n    );\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      messagePassingResultShader\n    );\n    await memModelTester.run(40, 3);\n  });\n"],"mappings":"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"}
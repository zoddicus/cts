{"version":3,"file":"user_io.spec.js","names":["description","makeTestGroup","range","GPUTest","g","generateInterstagePassthroughCode","type","drawPassthrough","t","code","formats","components","pipeline","device","createRenderPipeline","layout","vertex","module","createShaderModule","entryPoint","buffers","arrayStride","attributes","format","offset","shaderLocation","fragment","targets","map","x","primitive","topology","vertexBuffer","makeBufferWithContents","Uint32Array","GPUBufferUsage","COPY_SRC","VERTEX","bytesPerComponent","width","height","copyWidth","outputTextures","i","texture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","trackForCleanup","bufferSize","comp","length","outputBuffer","createBuffer","COPY_DST","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setVertexBuffer","draw","end","expectArray","copyTextureToBuffer","buffer","bytesPerRow","rowsPerImage","j","value","concat","queue","submit","finish","expect","expectGPUBufferValuesEqual","test","desc","params","u","combine","beforeAllSubcases","selectDeviceOrSkipTestCase","fn"],"sources":["../../../../../src/webgpu/shader/execution/shader_io/user_io.spec.ts"],"sourcesContent":["export const description = `\nTest for user-defined shader I/O.\n\npassthrough:\n  * Data passed into vertex shader as uints and converted to test type\n  * Passed from vertex to fragment as test type\n  * Output from fragment shader as uint\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { range } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction generateInterstagePassthroughCode(type: string): string {\n  return `\n${type === 'f16' ? 'enable f16;' : ''}\nstruct IOData {\n  @builtin(position) pos : vec4f,\n  @location(0) @interpolate(flat) user0 : ${type},\n  @location(1) @interpolate(flat) user1 : vec2<${type}>,\n  @location(2) @interpolate(flat) user2 : vec4<${type}>,\n}\n\nstruct VertexInput {\n  @builtin(vertex_index) idx : u32,\n  @location(0) in0 : u32,\n  @location(1) in1 : vec2u,\n  @location(2) in2 : vec4u,\n}\n\n@vertex\nfn vsMain(input : VertexInput) -> IOData {\n  const vertices = array(\n    vec4f(-1, -1, 0, 1),\n    vec4f(-1,  1, 0, 1),\n    vec4f( 1, -1, 0, 1),\n  );\n  var data : IOData;\n  data.pos = vertices[input.idx];\n  data.user0 = ${type}(input.in0);\n  data.user1 = vec2<${type}>(input.in1);\n  data.user2 = vec4<${type}>(input.in2);\n  return data;\n}\n\nstruct FragOutput {\n  @location(0) out0 : u32,\n  @location(1) out1 : vec2u,\n  @location(2) out2 : vec4u,\n}\n\n@fragment\nfn fsMain(input : IOData) -> FragOutput {\n  var out : FragOutput;\n  out.out0 = u32(input.user0);\n  out.out1 = vec2u(input.user1);\n  out.out2 = vec4u(input.user2);\n  return out;\n}\n`;\n}\n\nfunction drawPassthrough(t: GPUTest, code: string) {\n  // Default limit is 32 bytes of color attachments.\n  // These attachments use 28 bytes (which is why vec3 is skipped).\n  const formats: GPUTextureFormat[] = ['r32uint', 'rg32uint', 'rgba32uint'];\n  const components = [1, 2, 4];\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: t.device.createShaderModule({ code }),\n      entryPoint: 'vsMain',\n      buffers: [\n        {\n          arrayStride: 4,\n          attributes: [\n            {\n              format: 'uint32',\n              offset: 0,\n              shaderLocation: 0,\n            },\n          ],\n        },\n        {\n          arrayStride: 8,\n          attributes: [\n            {\n              format: 'uint32x2',\n              offset: 0,\n              shaderLocation: 1,\n            },\n          ],\n        },\n        {\n          arrayStride: 16,\n          attributes: [\n            {\n              format: 'uint32x4',\n              offset: 0,\n              shaderLocation: 2,\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: t.device.createShaderModule({ code }),\n      entryPoint: 'fsMain',\n      targets: formats.map(x => {\n        return { format: x };\n      }),\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  });\n\n  const vertexBuffer = t.makeBufferWithContents(\n    new Uint32Array([\n      // scalar: offset 0\n      1, 1, 1, 0,\n      // vec2: offset 16\n      2, 2, 2, 2, 2, 2, 0, 0,\n      // vec4: offset 48\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    ]),\n    GPUBufferUsage.COPY_SRC | GPUBufferUsage.VERTEX\n  );\n\n  const bytesPerComponent = 4;\n  // 256 is the minimum bytes per row for texture to buffer copies.\n  const width = 256 / bytesPerComponent;\n  const height = 2;\n  const copyWidth = 4;\n  const outputTextures = range(3, i => {\n    const texture = t.device.createTexture({\n      size: [width, height],\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.TEXTURE_BINDING,\n      format: formats[i],\n    });\n    t.trackForCleanup(texture);\n    return texture;\n  });\n\n  let bufferSize = 1;\n  for (const comp of components) {\n    bufferSize *= comp;\n  }\n  bufferSize *= outputTextures.length * bytesPerComponent * copyWidth;\n  const outputBuffer = t.device.createBuffer({\n    size: bufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  });\n  t.trackForCleanup(outputBuffer);\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginRenderPass({\n    colorAttachments: outputTextures.map(t => ({\n      view: t.createView(),\n      loadOp: 'clear',\n      storeOp: 'store',\n    })),\n  });\n  pass.setPipeline(pipeline);\n  pass.setVertexBuffer(0, vertexBuffer, 0, 12);\n  pass.setVertexBuffer(1, vertexBuffer, 16, 24);\n  pass.setVertexBuffer(2, vertexBuffer, 48, 48);\n  pass.draw(3);\n  pass.end();\n\n  // Copy 'copyWidth' samples from each attachment into a buffer to check the results.\n  let offset = 0;\n  let expectArray: number[] = [];\n  for (let i = 0; i < outputTextures.length; i++) {\n    encoder.copyTextureToBuffer(\n      { texture: outputTextures[i] },\n      {\n        buffer: outputBuffer,\n        offset,\n        bytesPerRow: bytesPerComponent * components[i] * width,\n        rowsPerImage: height,\n      },\n      { width: copyWidth, height: 1 }\n    );\n    offset += components[i] * bytesPerComponent * copyWidth;\n    for (let j = 0; j < components[i]; j++) {\n      const value = i + 1;\n      expectArray = expectArray.concat([value, value, value, value]);\n    }\n  }\n  t.queue.submit([encoder.finish()]);\n\n  const expect = new Uint32Array(expectArray);\n  t.expectGPUBufferValuesEqual(outputBuffer, expect);\n}\n\ng.test('passthrough')\n  .desc('Tests passing user-defined data from vertex input through fragment output')\n  .params(u => u.combine('type', ['f32', 'f16', 'i32', 'u32'] as const))\n  .beforeAllSubcases(t => {\n    if (t.params.type === 'f16') {\n      t.selectDeviceOrSkipTestCase('shader-f16');\n    }\n  })\n  .fn(t => {\n    const code = generateInterstagePassthroughCode(t.params.type);\n    drawPassthrough(t, code);\n  });\n"],"mappings":"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"}
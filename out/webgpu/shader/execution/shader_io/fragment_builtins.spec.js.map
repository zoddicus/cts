{"version":3,"file":"fragment_builtins.spec.js","names":["description","makeTestGroup","ErrorWithExtra","assert","range","unreachable","GPUTest","getMultisampleFragmentOffsets","dotProduct","subtractVectors","TexelView","findFailedPixels","g","s_deviceToPipelineMap","WeakMap","getPipelinesForDevice","device","pipelines","get","set","getCopyMultisamplePipelineForDevice","textures","length","sampleCount","pipelineType","pipeline","isMultisampled","numSamples","sampleIndex","module","createShaderModule","code","createComputePipeline","label","layout","compute","entryPoint","isTextureSameDimensions","a","b","width","height","depthOrArrayLayers","copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures","t","copyBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","trackForCleanup","buffer","MAP_READ","COPY_DST","encoder","createCommandEncoder","textureEntries","map","texture","i","binding","resource","createView","bindGroup","createBindGroup","getBindGroupLayout","entries","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","copyBufferToBuffer","queue","submit","finish","kZ","kW","getColumn","values","colNum","v","linearInterpolation","baryCoords","interCoords","perspectiveInterpolation","barycentricCoords","clipSpaceTriangleCoords","c","fa","fb","fc","wa","wb","wc","clipSpaceToNDC","point","ndcToWindow","ndcPoint","viewport","xd","yd","zd","px","py","ox","oy","zNear","zFar","calcBarycentricCoordinates","trianglePoints","p","v0","v1","v2","dot00","dot01","dot11","dot20","dot21","denom","w","u","generateFragmentInputs","nearFar","clipSpacePoints","interpolateFn","expected","Float32Array","ndcPoints","windowPoints","windowPoints2D","slice","fragmentOffsets","y","x","s","fragmentPoint","multisampleOffset","sampleFragmentPoint","fragmentBarycentricCoords","sampleBarycentricCoords","output","offset","computeFragmentPosition","createInterStageInterpolationFn","interStagePoints","type","sampling","_","renderFragmentShaderInputsTo4TexturesAndReadbackValues","interpolationType","interpolationSampling","outputCode","interpolate","join","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","format","createRenderPipeline","vertex","fragment","targets","multisample","count","uniformBuffer","UNIFORM","writeBuffer","beginRenderPass","colorAttachments","view","loadOp","storeOp","setViewport","draw","mapAsync","GPUMapMode","READ","getMappedRange","checkSampleRectsApproximatelyEqual","actual","maxFractionalDiff","subrectOrigin","subrectSize","areaDesc","bytesPerRow","rowsPerImage","actTexelView","fromTextureDataByReference","Uint8Array","expTexelView","failedPixelsMessage","z","undefined","msg","test","desc","params","combine","beforeAllSubcases","interpolation","skipIfInterpolationTypeOrSamplingNotSupported","fn","expectOK"],"sources":["../../../../../src/webgpu/shader/execution/shader_io/fragment_builtins.spec.ts"],"sourcesContent":["export const description = `Test fragment shader builtin variables and inter-stage variables\n\n* test builtin(position)\n* test interpolation\n\nThe current tests draw a single triangle with clip space coordinates [1, 1], [-3, 1], [1, -3].\nThis means they render to all pixels in the textures. To fully test centroid interpolation\nprobably requires drawing various triangles that only cover certain samples. That is TBD.\n\nTODO:\n* test sample interpolation\n* test centroid interpolation\n* test front_facing\n* test sample_index\n* test frag_depth\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ErrorWithExtra, assert, range, unreachable } from '../../../../common/util/util.js';\nimport { InterpolationSampling, InterpolationType } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { getMultisampleFragmentOffsets } from '../../../multisample_info.js';\nimport { dotProduct, subtractVectors } from '../../../util/math.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\nimport { findFailedPixels } from '../../../util/texture/texture_ok.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst s_deviceToPipelineMap = new WeakMap<\n  GPUDevice,\n  {\n    texture_2d?: GPUComputePipeline;\n    texture_multisampled_2d?: GPUComputePipeline;\n  }\n>();\n\n/**\n * Returns an object of pipelines associated\n * by weakmap to a device so we can cache pipelines.\n */\nfunction getPipelinesForDevice(device: GPUDevice) {\n  let pipelines = s_deviceToPipelineMap.get(device);\n  if (!pipelines) {\n    pipelines = {};\n    s_deviceToPipelineMap.set(device, pipelines);\n  }\n  return pipelines;\n}\n\n/**\n * Gets a compute pipeline that will copy the given texture if passed\n * a dispatch size of texture.width, texture.height\n * @param device a device\n * @param texture texture the pipeline is needed for.\n * @returns A GPUComputePipeline\n */\nfunction getCopyMultisamplePipelineForDevice(device: GPUDevice, textures: GPUTexture[]) {\n  assert(textures.length === 4);\n  assert(textures[0].sampleCount === textures[1].sampleCount);\n  assert(textures[0].sampleCount === textures[2].sampleCount);\n  assert(textures[0].sampleCount === textures[3].sampleCount);\n\n  const pipelineType = textures[0].sampleCount > 1 ? 'texture_multisampled_2d' : 'texture_2d';\n  const pipelines = getPipelinesForDevice(device);\n  let pipeline = pipelines[pipelineType];\n  if (!pipeline) {\n    const isMultisampled = pipelineType === 'texture_multisampled_2d';\n    const numSamples = isMultisampled ? 'textureNumSamples(texture0)' : '1u';\n    const sampleIndex = isMultisampled ? 'sampleIndex' : '0';\n    const module = device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var texture0: ${pipelineType}<f32>;\n        @group(0) @binding(1) var texture1: ${pipelineType}<f32>;\n        @group(0) @binding(2) var texture2: ${pipelineType}<f32>;\n        @group(0) @binding(3) var texture3: ${pipelineType}<f32>;\n        @group(0) @binding(4) var<storage, read_write> buffer: array<f32>;\n\n        @compute @workgroup_size(1) fn cs(@builtin(global_invocation_id) id: vec3u) {\n          let numSamples = ${numSamples};\n          let dimensions = textureDimensions(texture0);\n          let sampleIndex = id.x % numSamples;\n          let tx = id.x / numSamples;\n          let offset = ((id.y * dimensions.x + tx) * numSamples + sampleIndex) * 4;\n          let r = vec4u(textureLoad(texture0, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let g = vec4u(textureLoad(texture1, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let b = vec4u(textureLoad(texture2, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let a = vec4u(textureLoad(texture3, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n\n          // expand rgba8unorm values back to their byte form, add them together\n          // and cast them to an f32 so we can recover the f32 values we encoded\n          // in the rgba8unorm texture.\n          buffer[offset + 0] = bitcast<f32>(dot(r, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 1] = bitcast<f32>(dot(g, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 2] = bitcast<f32>(dot(b, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 3] = bitcast<f32>(dot(a, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n        }\n      `,\n    });\n\n    pipeline = device.createComputePipeline({\n      label: 'copy multisampled texture pipeline',\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'cs',\n      },\n    });\n\n    pipelines[pipelineType] = pipeline;\n  }\n  return pipeline;\n}\n\nfunction isTextureSameDimensions(a: GPUTexture, b: GPUTexture) {\n  return (\n    a.sampleCount === b.sampleCount &&\n    a.width === b.width &&\n    a.height === b.height &&\n    a.depthOrArrayLayers === b.depthOrArrayLayers\n  );\n}\n\n/**\n * Copies a texture (even if multisampled) to a buffer\n * @param t a gpu test\n * @param texture texture to copy\n * @returns buffer with copy of texture, mip level 0, array layer 0.\n */\nfunction copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures(\n  t: GPUTest,\n  textures: GPUTexture[]\n) {\n  assert(textures.length === 4);\n  assert(isTextureSameDimensions(textures[0], textures[1]));\n  assert(isTextureSameDimensions(textures[0], textures[2]));\n  assert(isTextureSameDimensions(textures[0], textures[3]));\n  const { width, height, sampleCount } = textures[0];\n\n  const copyBuffer = t.device.createBuffer({\n    size: width * height * sampleCount * 4 * 4,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n  t.trackForCleanup(copyBuffer);\n\n  const buffer = t.device.createBuffer({\n    size: copyBuffer.size,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n  });\n  t.trackForCleanup(buffer);\n\n  const pipeline = getCopyMultisamplePipelineForDevice(t.device, textures);\n  const encoder = t.device.createCommandEncoder();\n\n  const textureEntries = textures.map(\n    (texture, i) => ({ binding: i, resource: texture.createView() }) as GPUBindGroupEntry\n  );\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [...textureEntries, { binding: 4, resource: { buffer: copyBuffer } }],\n  });\n\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(width * sampleCount, height);\n  pass.end();\n\n  encoder.copyBufferToBuffer(copyBuffer, 0, buffer, 0, buffer.size);\n\n  t.device.queue.submit([encoder.finish()]);\n\n  return buffer;\n}\n\n/* column constants */\nconst kZ = 2;\nconst kW = 3;\n\n/**\n * Gets a column of values from an array of arrays.\n */\nfunction getColumn(values: readonly number[][], colNum: number) {\n  return values.map(v => v[colNum]);\n}\n\n/**\n * Computes the linear interpolation of 3 values from 3 vertices of a triangle\n * based on barycentric coordinates\n */\nfunction linearInterpolation(baryCoords: readonly number[], interCoords: readonly number[]) {\n  return dotProduct(baryCoords, interCoords);\n}\n\n/**\n * Computes the perspective interpolation of 3 values from 3 vertices of a\n * triangle based on barycentric coordinates and their corresponding clip space\n * W coordinates.\n */\nfunction perspectiveInterpolation(\n  barycentricCoords: readonly number[],\n  clipSpaceTriangleCoords: readonly number[][],\n  interCoords: readonly number[]\n) {\n  const [a, b, c] = barycentricCoords;\n  const [fa, fb, fc] = interCoords;\n  const wa = clipSpaceTriangleCoords[0][kW];\n  const wb = clipSpaceTriangleCoords[1][kW];\n  const wc = clipSpaceTriangleCoords[2][kW];\n\n  return ((a * fa) / wa + (b * fb) / wb + (c * fc) / wc) / (a / wa + b / wb + c / wc);\n}\n\n/**\n * Converts clip space coords to NDC coords\n */\nfunction clipSpaceToNDC(point: readonly number[]) {\n  return point.map(v => v / point[kW]);\n}\n\n/**\n * Converts NDC coords to window coords.\n */\nfunction ndcToWindow(ndcPoint: readonly number[], viewport: readonly number[]) {\n  const [xd, yd, zd] = ndcPoint;\n  const px = viewport[2];\n  const py = viewport[3];\n  const ox = viewport[0] + px / 2;\n  const oy = viewport[1] + py / 2;\n  const zNear = viewport[4];\n  const zFar = viewport[5];\n  // prettier-ignore\n  return [\n    px / 2 * xd + ox,\n    -py / 2 * yd + oy,\n    zd * (zFar - zNear) + zNear,\n  ];\n}\n\n/**\n * Computes barycentric coordinates of triangle for point p.\n * @param trianglePoints points for triangle\n * @param p point in triangle (or relative to it)\n * @returns barycentric coords of p\n */\nfunction calcBarycentricCoordinates(trianglePoints: number[][], p: number[]) {\n  const [a, b, c] = trianglePoints;\n\n  const v0 = subtractVectors(b, a);\n  const v1 = subtractVectors(c, a);\n  const v2 = subtractVectors(p, a);\n\n  const dot00 = dotProduct(v0, v0);\n  const dot01 = dotProduct(v0, v1);\n  const dot11 = dotProduct(v1, v1);\n  const dot20 = dotProduct(v2, v0);\n  const dot21 = dotProduct(v2, v1);\n\n  const denom = 1 / (dot00 * dot11 - dot01 * dot01);\n  const v = (dot11 * dot20 - dot01 * dot21) * denom;\n  const w = (dot00 * dot21 - dot01 * dot20) * denom;\n  const u = 1 - v - w;\n\n  return [u, v, w];\n}\n\ntype FragData = {\n  fragmentPoint: readonly number[];\n  fragmentBarycentricCoords: readonly number[];\n  sampleBarycentricCoords: readonly number[];\n  clipSpacePoints: readonly number[][];\n  ndcPoints: readonly number[][];\n  windowPoints: readonly number[][];\n};\n\n/**\n * For each sample in texture, computes the values that would be provided\n * to the shader as `@builtin(position)` if the texture was a render target\n * and every point in the texture was inside the triangle.\n * @param texture The texture\n * @param clipSpacePoints triangle points in clip space\n * @returns the expected values for each sample\n */\nfunction generateFragmentInputs({\n  width,\n  height,\n  nearFar,\n  sampleCount,\n  clipSpacePoints,\n  interpolateFn,\n}: {\n  width: number;\n  height: number;\n  nearFar: readonly number[];\n  sampleCount: number;\n  clipSpacePoints: readonly number[][];\n  interpolateFn: (fragData: FragData) => number[];\n}) {\n  const expected = new Float32Array(width * height * sampleCount * 4);\n\n  const viewport = [0, 0, width, height, ...nearFar];\n\n  const ndcPoints = clipSpacePoints.map(clipSpaceToNDC);\n  const windowPoints = ndcPoints.map(p => ndcToWindow(p, viewport));\n  const windowPoints2D = windowPoints.map(p => p.slice(0, 2));\n\n  const fragmentOffsets = getMultisampleFragmentOffsets(sampleCount)!;\n  for (let y = 0; y < height; ++y) {\n    for (let x = 0; x < width; ++x) {\n      for (let s = 0; s < sampleCount; ++s) {\n        const fragmentPoint = [x + 0.5, y + 0.5];\n        const multisampleOffset = fragmentOffsets[s];\n        const sampleFragmentPoint = [x + multisampleOffset[0], y + multisampleOffset[1]];\n        const fragmentBarycentricCoords = calcBarycentricCoordinates(windowPoints2D, fragmentPoint);\n        const sampleBarycentricCoords = calcBarycentricCoordinates(\n          windowPoints2D,\n          sampleFragmentPoint\n        );\n\n        const output = interpolateFn({\n          fragmentPoint,\n          fragmentBarycentricCoords,\n          sampleBarycentricCoords,\n          clipSpacePoints,\n          ndcPoints,\n          windowPoints,\n        });\n\n        const offset = ((y * width + x) * sampleCount + s) * 4;\n        expected.set(output, offset);\n      }\n    }\n  }\n  return expected;\n}\n\n/**\n * Computes 'builtin(position)`\n */\nfunction computeFragmentPosition({\n  fragmentPoint,\n  fragmentBarycentricCoords,\n  clipSpacePoints,\n  windowPoints,\n}: FragData) {\n  return [\n    fragmentPoint[0],\n    fragmentPoint[1],\n    linearInterpolation(fragmentBarycentricCoords, getColumn(windowPoints, kZ)),\n    1 /\n      perspectiveInterpolation(\n        fragmentBarycentricCoords,\n        clipSpacePoints,\n        getColumn(clipSpacePoints, kW)\n      ),\n  ];\n}\n\n/**\n * Creates a function that will compute the interpolation of an inter-stage variable.\n */\nfunction createInterStageInterpolationFn(\n  interStagePoints: number[][],\n  type: InterpolationType,\n  sampling: InterpolationSampling | undefined\n) {\n  return function ({\n    fragmentBarycentricCoords,\n    sampleBarycentricCoords,\n    clipSpacePoints,\n  }: FragData) {\n    const barycentricCoords =\n      sampling === 'center' ? fragmentBarycentricCoords : sampleBarycentricCoords;\n    switch (type) {\n      case 'perspective':\n        return interStagePoints[0].map((_, colNum: number) =>\n          perspectiveInterpolation(\n            barycentricCoords,\n            clipSpacePoints,\n            getColumn(interStagePoints, colNum)\n          )\n        );\n        break;\n      case 'linear':\n        return interStagePoints[0].map((_, colNum: number) =>\n          linearInterpolation(barycentricCoords, getColumn(interStagePoints, colNum))\n        );\n        break;\n      case 'flat':\n        return interStagePoints[0];\n        break;\n      default:\n        unreachable();\n    }\n  };\n}\n\n/**\n * Renders float32 fragment shader inputs values to 4 rgba8unorm textures that\n * can be multisampled textures. It stores each of the channels, r, g, b, a of\n * the shader input to a separate texture, doing the math required to store the\n * float32 value into an rgba8unorm texel.\n *\n * Note: We could try to store the output to an vec4f storage buffer.\n * Unfortunately, using a storage buffer has the issue that we need to compute\n * an index with the very thing we're trying to test. Similarly, if we used a\n * storage texture we would need to compute texture locations with the things\n * we're trying to test. Also, using a storage buffer seems to affect certain\n * backends like M1 Mac so it seems better to stick to rgba8unorm here and test\n * using a storage buffer in a fragment shader separately.\n *\n * We can't use rgba32float because it's optional. We can't use rgba16float\n * because it's optional in compat. We can't we use rgba32uint as that can't be\n * multisampled.\n */\nasync function renderFragmentShaderInputsTo4TexturesAndReadbackValues(\n  t: GPUTest,\n  {\n    interpolationType,\n    interpolationSampling,\n    sampleCount,\n    width,\n    height,\n    nearFar,\n    clipSpacePoints,\n    interStagePoints,\n    outputCode,\n  }: {\n    interpolationType: InterpolationType;\n    interpolationSampling?: InterpolationSampling;\n    width: number;\n    height: number;\n    sampleCount: number;\n    nearFar: readonly number[];\n    clipSpacePoints: readonly number[][];\n    interStagePoints: readonly number[][];\n    outputCode: string;\n  }\n) {\n  const interpolate = `${interpolationType}${\n    interpolationSampling ? `, ${interpolationSampling}` : ''\n  }`;\n  const module = t.device.createShaderModule({\n    code: `\n      struct Uniforms {\n        resolution: vec2f,\n      };\n\n      @group(0) @binding(0) var<uniform> uni: Uniforms;\n\n      struct Vertex {\n        @builtin(position) position: vec4f,\n        @location(0) @interpolate(${interpolate}) interpolatedValue: vec4f,\n      };\n\n      @vertex fn vs(@builtin(vertex_index) vNdx: u32) -> Vertex {\n        let pos = array(\n          ${clipSpacePoints.map(p => `vec4f(${p.join(', ')})`).join(', ')}\n        );\n        let interStage = array(\n          ${interStagePoints.map(p => `vec4f(${p.join(', ')})`).join(', ')}\n        );\n        var v: Vertex;\n        v.position = pos[vNdx];\n        v.interpolatedValue = interStage[vNdx];\n        _ = uni;\n        return v;\n      }\n\n      struct FragOut {\n        @location(0) out0: vec4f,\n        @location(1) out1: vec4f,\n        @location(2) out2: vec4f,\n        @location(3) out3: vec4f,\n      };\n\n      fn u32ToRGBAUnorm(u: u32) -> vec4f {\n        return vec4f(\n          f32((u >> 24) & 0xFF) / 255.0,\n          f32((u >> 16) & 0xFF) / 255.0,\n          f32((u >>  8) & 0xFF) / 255.0,\n          f32((u >>  0) & 0xFF) / 255.0,\n        );\n      }\n\n      @fragment fn fs(vin: Vertex) -> FragOut {\n        var f: FragOut;\n        let v = ${outputCode};\n        let u = bitcast<vec4u>(v);\n        f.out0 = u32ToRGBAUnorm(u[0]);\n        f.out1 = u32ToRGBAUnorm(u[1]);\n        f.out2 = u32ToRGBAUnorm(u[2]);\n        f.out3 = u32ToRGBAUnorm(u[3]);\n        _ = vin.interpolatedValue;\n        return f;\n      }\n    `,\n  });\n\n  const textures = range(4, () => {\n    const texture = t.device.createTexture({\n      size: [width, height],\n      usage:\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n      sampleCount,\n    });\n    t.trackForCleanup(texture);\n    return texture;\n  });\n\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets: textures.map(() => ({ format: 'rgba8unorm' })),\n    },\n    multisample: {\n      count: sampleCount,\n    },\n  });\n\n  const uniformBuffer = t.device.createBuffer({\n    size: 8,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  t.trackForCleanup(uniformBuffer);\n  t.device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([width, height]));\n\n  const viewport = [0, 0, width, height, ...nearFar] as const;\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginRenderPass({\n    colorAttachments: textures.map(texture => ({\n      view: texture.createView(),\n      loadOp: 'clear',\n      storeOp: 'store',\n    })),\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.setViewport(viewport[0], viewport[1], viewport[2], viewport[3], viewport[4], viewport[5]);\n  pass.draw(clipSpacePoints.length);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  const buffer = copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures(t, textures);\n  await buffer.mapAsync(GPUMapMode.READ);\n  return new Float32Array(buffer.getMappedRange());\n}\n\nfunction checkSampleRectsApproximatelyEqual({\n  width,\n  height,\n  sampleCount,\n  actual,\n  expected,\n  maxFractionalDiff,\n}: {\n  width: number;\n  height: number;\n  sampleCount: number;\n  actual: Float32Array;\n  expected: Float32Array;\n  maxFractionalDiff: number;\n}) {\n  const subrectOrigin = [0, 0, 0];\n  const subrectSize = [width, height, 1];\n  const areaDesc = {\n    bytesPerRow: width * sampleCount * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin,\n    subrectSize,\n  };\n\n  const format = 'rgba32float';\n  const actTexelView = TexelView.fromTextureDataByReference(\n    format,\n    new Uint8Array(actual.buffer),\n    areaDesc\n  );\n  const expTexelView = TexelView.fromTextureDataByReference(\n    format,\n    new Uint8Array(expected.buffer),\n    areaDesc\n  );\n\n  const failedPixelsMessage = findFailedPixels(\n    format,\n    { x: 0, y: 0, z: 0 },\n    { width, height, depthOrArrayLayers: 1 },\n    { actTexelView, expTexelView },\n    { maxFractionalDiff }\n  );\n\n  if (failedPixelsMessage !== undefined) {\n    const msg = 'Texture level had unexpected contents:\\n' + failedPixelsMessage;\n    return new ErrorWithExtra(msg, () => ({\n      expTexelView,\n      actTexelView,\n    }));\n  }\n\n  return undefined;\n}\n\ng.test('inputs,position')\n  .desc(\n    `\n    Test fragment shader builtin(position) values.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        // MAINTENANCE_TODO: enable these tests.\n        // { type: 'perspective', sampling: 'centroid' },\n        // { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        // MAINTENANCE_TODO: enable these tests.\n        // { type: 'linear', sampling: 'centroid' },\n        // { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [0.333, 0.333, 0.333, 0.333],  //  1,  1, 1\n      [ 1.0,  -3.0,   0.25, 1.0  ],  //  1, -3, 0.25\n      [-1.5,   0.5,   0.25, 0.5  ],  // -3,  1, 0.5\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      outputCode: 'vin.position',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: computeFragmentPosition,\n    });\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxFractionalDiff: 0.000001,\n      })\n    );\n  });\n\ng.test('inputs,interStage')\n  .desc(\n    `\n    Test fragment shader inter-stage variable values.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        // MAINTENANCE_TODO: enable these tests.\n        // { type: 'perspective', sampling: 'centroid' },\n        // { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        // MAINTENANCE_TODO: enable these tests.\n        // { type: 'linear', sampling: 'centroid' },\n        // { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [0.333, 0.333, 0.333, 0.333],  //  1,  1, 1\n      [ 1.0,  -3.0,   0.25, 1.0  ],  //  1, -3, 0.25\n      [-1.5,   0.5,   0.25, 0.5  ],  // -3,  1, 0.5\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      outputCode: 'vin.interpolatedValue',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: createInterStageInterpolationFn(interStagePoints, type, sampling),\n    });\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxFractionalDiff: 0.00001,\n      })\n    );\n  });\n"],"mappings":"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"}
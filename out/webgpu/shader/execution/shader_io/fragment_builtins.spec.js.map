{"version":3,"file":"fragment_builtins.spec.js","names":["description","makeTestGroup","ErrorWithExtra","assert","range","unreachable","GPUTest","getMultisampleFragmentOffsets","dotProduct","subtractVectors","TexelView","findFailedPixels","g","s_deviceToPipelineMap","WeakMap","getPipelinesForDevice","device","pipelines","get","set","getCopyMultisamplePipelineForDevice","textures","length","sampleCount","pipelineType","pipeline","isMultisampled","numSamples","sampleIndex","module","createShaderModule","code","createComputePipeline","label","layout","compute","entryPoint","isTextureSameDimensions","a","b","width","height","depthOrArrayLayers","copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures","t","copyBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","trackForCleanup","buffer","MAP_READ","COPY_DST","encoder","createCommandEncoder","textureEntries","map","texture","i","binding","resource","createView","bindGroup","createBindGroup","getBindGroupLayout","entries","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","copyBufferToBuffer","queue","submit","finish","kX","kY","kZ","kW","getColumn","values","colNum","v","linearInterpolation","baryCoords","interCoords","perspectiveInterpolation","barycentricCoords","clipSpaceTriangleCoords","c","fa","fb","fc","wa","wb","wc","clipSpaceToNDC","point","ndcToWindow","ndcPoint","viewport","xd","yd","zd","px","py","ox","oy","zNear","zFar","calcBarycentricCoordinates","trianglePoints","p","v0","v1","v2","dot00","dot01","dot11","dot20","dot21","denom","w","u","isInsideTriangle","isTriangleClockwise","windowPoints","sum","p0","p1","generateFragmentInputs","nearFar","frontFace","clipSpacePoints","interpolateFn","expected","Float32Array","vertexIndex","ndcPoints","slice","windowPoints2D","cw","frontFacing","fragmentOffsets","y","x","fragmentPoint","multisampleOffset","sampleFragmentPoint","fragmentBarycentricCoords","sampleBarycentricCoords","inside","output","baseVertexIndex","offset","computeFragmentPosition","createInterStageInterpolationFn","interStagePoints","type","sampling","triangleInterStagePoints","_","createInterStageInterpolationBetween0And1TestFn","fragData","interpolatedValues","allTrue","reduce","all","computeFragmentSampleIndex","computeFragmentFrontFacing","renderFragmentShaderInputsTo4TexturesAndReadbackValues","interpolationType","interpolationSampling","fragInCode","outputCode","interpolate","join","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","format","createRenderPipeline","vertex","fragment","targets","primitive","multisample","count","uniformBuffer","UNIFORM","writeBuffer","beginRenderPass","colorAttachments","view","loadOp","storeOp","setViewport","draw","mapAsync","GPUMapMode","READ","getMappedRange","checkSampleRectsApproximatelyEqual","actual","maxDiffULPsForFloatFormat","subrectOrigin","subrectSize","areaDesc","bytesPerRow","rowsPerImage","actTexelView","fromTextureDataByReference","Uint8Array","expTexelView","failedPixelsMessage","z","undefined","msg","test","desc","params","combine","beforeAllSubcases","interpolation","skipIfInterpolationTypeOrSamplingNotSupported","fn","expectOK","skipIf","isCompatibility"],"sources":["../../../../../src/webgpu/shader/execution/shader_io/fragment_builtins.spec.ts"],"sourcesContent":["export const description = `Test fragment shader builtin variables and inter-stage variables\n\n* test builtin(position)\n* test @interpolate\n* test builtin(sample_index)\n* test builtin(front_facing)\n\nNote: @interpolate settings and sample_index affect whether or not the fragment shader\nis evaluated per-fragment or per-sample. With @interpolate(, sample) or usage of\n@builtin(sample_index) the fragment shader should be executed per-sample.\n\nTODO:\n* test frag_depth\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ErrorWithExtra, assert, range, unreachable } from '../../../../common/util/util.js';\nimport { InterpolationSampling, InterpolationType } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { getMultisampleFragmentOffsets } from '../../../multisample_info.js';\nimport { dotProduct, subtractVectors } from '../../../util/math.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\nimport { findFailedPixels } from '../../../util/texture/texture_ok.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst s_deviceToPipelineMap = new WeakMap<\n  GPUDevice,\n  {\n    texture_2d?: GPUComputePipeline;\n    texture_multisampled_2d?: GPUComputePipeline;\n  }\n>();\n\n/**\n * Returns an object of pipelines associated\n * by weakmap to a device so we can cache pipelines.\n */\nfunction getPipelinesForDevice(device: GPUDevice) {\n  let pipelines = s_deviceToPipelineMap.get(device);\n  if (!pipelines) {\n    pipelines = {};\n    s_deviceToPipelineMap.set(device, pipelines);\n  }\n  return pipelines;\n}\n\n/**\n * Gets a compute pipeline that will copy the given texture if passed\n * a dispatch size of texture.width, texture.height\n * @param device a device\n * @param texture texture the pipeline is needed for.\n * @returns A GPUComputePipeline\n */\nfunction getCopyMultisamplePipelineForDevice(device: GPUDevice, textures: GPUTexture[]) {\n  assert(textures.length === 4);\n  assert(textures[0].sampleCount === textures[1].sampleCount);\n  assert(textures[0].sampleCount === textures[2].sampleCount);\n  assert(textures[0].sampleCount === textures[3].sampleCount);\n\n  const pipelineType = textures[0].sampleCount > 1 ? 'texture_multisampled_2d' : 'texture_2d';\n  const pipelines = getPipelinesForDevice(device);\n  let pipeline = pipelines[pipelineType];\n  if (!pipeline) {\n    const isMultisampled = pipelineType === 'texture_multisampled_2d';\n    const numSamples = isMultisampled ? 'textureNumSamples(texture0)' : '1u';\n    const sampleIndex = isMultisampled ? 'sampleIndex' : '0';\n    const module = device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var texture0: ${pipelineType}<f32>;\n        @group(0) @binding(1) var texture1: ${pipelineType}<f32>;\n        @group(0) @binding(2) var texture2: ${pipelineType}<f32>;\n        @group(0) @binding(3) var texture3: ${pipelineType}<f32>;\n        @group(0) @binding(4) var<storage, read_write> buffer: array<f32>;\n\n        @compute @workgroup_size(1) fn cs(@builtin(global_invocation_id) id: vec3u) {\n          let numSamples = ${numSamples};\n          let dimensions = textureDimensions(texture0);\n          let sampleIndex = id.x % numSamples;\n          let tx = id.x / numSamples;\n          let offset = ((id.y * dimensions.x + tx) * numSamples + sampleIndex) * 4;\n          let r = vec4u(textureLoad(texture0, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let g = vec4u(textureLoad(texture1, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let b = vec4u(textureLoad(texture2, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n          let a = vec4u(textureLoad(texture3, vec2u(tx, id.y), ${sampleIndex}) * 255.0);\n\n          // expand rgba8unorm values back to their byte form, add them together\n          // and cast them to an f32 so we can recover the f32 values we encoded\n          // in the rgba8unorm texture.\n          buffer[offset + 0] = bitcast<f32>(dot(r, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 1] = bitcast<f32>(dot(g, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 2] = bitcast<f32>(dot(b, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n          buffer[offset + 3] = bitcast<f32>(dot(a, vec4u(0x1000000, 0x10000, 0x100, 0x1)));\n        }\n      `,\n    });\n\n    pipeline = device.createComputePipeline({\n      label: 'copy multisampled texture pipeline',\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'cs',\n      },\n    });\n\n    pipelines[pipelineType] = pipeline;\n  }\n  return pipeline;\n}\n\nfunction isTextureSameDimensions(a: GPUTexture, b: GPUTexture) {\n  return (\n    a.sampleCount === b.sampleCount &&\n    a.width === b.width &&\n    a.height === b.height &&\n    a.depthOrArrayLayers === b.depthOrArrayLayers\n  );\n}\n\n/**\n * Copies a texture (even if multisampled) to a buffer\n * @param t a gpu test\n * @param texture texture to copy\n * @returns buffer with copy of texture, mip level 0, array layer 0.\n */\nfunction copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures(\n  t: GPUTest,\n  textures: GPUTexture[]\n) {\n  assert(textures.length === 4);\n  assert(isTextureSameDimensions(textures[0], textures[1]));\n  assert(isTextureSameDimensions(textures[0], textures[2]));\n  assert(isTextureSameDimensions(textures[0], textures[3]));\n  const { width, height, sampleCount } = textures[0];\n\n  const copyBuffer = t.device.createBuffer({\n    size: width * height * sampleCount * 4 * 4,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n  t.trackForCleanup(copyBuffer);\n\n  const buffer = t.device.createBuffer({\n    size: copyBuffer.size,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n  });\n  t.trackForCleanup(buffer);\n\n  const pipeline = getCopyMultisamplePipelineForDevice(t.device, textures);\n  const encoder = t.device.createCommandEncoder();\n\n  const textureEntries = textures.map(\n    (texture, i) => ({ binding: i, resource: texture.createView() }) as GPUBindGroupEntry\n  );\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [...textureEntries, { binding: 4, resource: { buffer: copyBuffer } }],\n  });\n\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(width * sampleCount, height);\n  pass.end();\n\n  encoder.copyBufferToBuffer(copyBuffer, 0, buffer, 0, buffer.size);\n\n  t.device.queue.submit([encoder.finish()]);\n\n  return buffer;\n}\n\n/* column constants */\nconst kX = 0;\nconst kY = 1;\nconst kZ = 2;\nconst kW = 3;\n\n/**\n * Gets a column of values from an array of arrays.\n */\nfunction getColumn(values: readonly number[][], colNum: number) {\n  return values.map(v => v[colNum]);\n}\n\n/**\n * Computes the linear interpolation of 3 values from 3 vertices of a triangle\n * based on barycentric coordinates\n */\nfunction linearInterpolation(baryCoords: readonly number[], interCoords: readonly number[]) {\n  return dotProduct(baryCoords, interCoords);\n}\n\n/**\n * Computes the perspective interpolation of 3 values from 3 vertices of a\n * triangle based on barycentric coordinates and their corresponding clip space\n * W coordinates.\n */\nfunction perspectiveInterpolation(\n  barycentricCoords: readonly number[],\n  clipSpaceTriangleCoords: readonly number[][],\n  interCoords: readonly number[]\n) {\n  const [a, b, c] = barycentricCoords;\n  const [fa, fb, fc] = interCoords;\n  const wa = clipSpaceTriangleCoords[0][kW];\n  const wb = clipSpaceTriangleCoords[1][kW];\n  const wc = clipSpaceTriangleCoords[2][kW];\n\n  return ((a * fa) / wa + (b * fb) / wb + (c * fc) / wc) / (a / wa + b / wb + c / wc);\n}\n\n/**\n * Converts clip space coords to NDC coords\n */\nfunction clipSpaceToNDC(point: readonly number[]) {\n  return point.map(v => v / point[kW]);\n}\n\n/**\n * Converts NDC coords to window coords.\n */\nfunction ndcToWindow(ndcPoint: readonly number[], viewport: readonly number[]) {\n  const [xd, yd, zd] = ndcPoint;\n  const px = viewport[2];\n  const py = viewport[3];\n  const ox = viewport[0] + px / 2;\n  const oy = viewport[1] + py / 2;\n  const zNear = viewport[4];\n  const zFar = viewport[5];\n  // prettier-ignore\n  return [\n    px / 2 * xd + ox,\n    -py / 2 * yd + oy,\n    zd * (zFar - zNear) + zNear,\n  ];\n}\n\n/**\n * Computes barycentric coordinates of triangle for point p.\n * @param trianglePoints points for triangle\n * @param p point in triangle (or relative to it)\n * @returns barycentric coords of p\n */\nfunction calcBarycentricCoordinates(trianglePoints: number[][], p: number[]) {\n  const [a, b, c] = trianglePoints;\n\n  const v0 = subtractVectors(b, a);\n  const v1 = subtractVectors(c, a);\n  const v2 = subtractVectors(p, a);\n\n  const dot00 = dotProduct(v0, v0);\n  const dot01 = dotProduct(v0, v1);\n  const dot11 = dotProduct(v1, v1);\n  const dot20 = dotProduct(v2, v0);\n  const dot21 = dotProduct(v2, v1);\n\n  const denom = 1 / (dot00 * dot11 - dot01 * dot01);\n  const v = (dot11 * dot20 - dot01 * dot21) * denom;\n  const w = (dot00 * dot21 - dot01 * dot20) * denom;\n  const u = 1 - v - w;\n\n  return [u, v, w];\n}\n\n/**\n * Returns true if point is inside triangle\n */\nfunction isInsideTriangle(barycentricCoords: number[]) {\n  for (const v of barycentricCoords) {\n    if (v < 0 || v > 1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns true if windowPoints define a clockwise triangle\n */\nfunction isTriangleClockwise(windowPoints: readonly number[][]) {\n  let sum = 0;\n  for (let i = 0; i < 3; ++i) {\n    const p0 = windowPoints[i];\n    const p1 = windowPoints[(i + 1) % 3];\n    sum += p0[kX] * p1[kY] - p1[kX] * p0[kY];\n  }\n  return sum >= 0;\n}\n\ntype FragData = {\n  baseVertexIndex: number;\n  fragmentPoint: readonly number[];\n  fragmentBarycentricCoords: readonly number[];\n  sampleBarycentricCoords: readonly number[];\n  clipSpacePoints: readonly number[][];\n  ndcPoints: readonly number[][];\n  windowPoints: readonly number[][];\n  sampleIndex: number;\n  frontFacing: boolean;\n};\n\n/**\n * For each sample in texture, computes the values that would be provided\n * to the shader as `@builtin(position)` if the texture was a render target\n * and every point in the texture was inside the triangle.\n * @param texture The texture\n * @param clipSpacePoints triangle points in clip space\n * @returns the expected values for each sample\n */\nfunction generateFragmentInputs({\n  width,\n  height,\n  nearFar,\n  sampleCount,\n  frontFace,\n  clipSpacePoints,\n  interpolateFn,\n}: {\n  width: number;\n  height: number;\n  nearFar: readonly number[];\n  sampleCount: number;\n  frontFace?: GPUFrontFace;\n  clipSpacePoints: readonly number[][];\n  interpolateFn: (fragData: FragData) => number[];\n}) {\n  const expected = new Float32Array(width * height * sampleCount * 4);\n\n  const viewport = [0, 0, width, height, ...nearFar];\n\n  // For each triangle\n  for (let vertexIndex = 0; vertexIndex < clipSpacePoints.length; vertexIndex += 3) {\n    const ndcPoints = clipSpacePoints.slice(vertexIndex, vertexIndex + 3).map(clipSpaceToNDC);\n    const windowPoints = ndcPoints.map(p => ndcToWindow(p, viewport));\n    const windowPoints2D = windowPoints.map(p => p.slice(0, 2));\n\n    const cw = isTriangleClockwise(windowPoints2D);\n    const frontFacing = frontFace === 'cw' ? cw : !cw;\n    const fragmentOffsets = getMultisampleFragmentOffsets(sampleCount)!;\n\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n          const fragmentPoint = [x + 0.5, y + 0.5];\n          const multisampleOffset = fragmentOffsets[sampleIndex];\n          const sampleFragmentPoint = [x + multisampleOffset[0], y + multisampleOffset[1]];\n          const fragmentBarycentricCoords = calcBarycentricCoordinates(\n            windowPoints2D,\n            fragmentPoint\n          );\n          const sampleBarycentricCoords = calcBarycentricCoordinates(\n            windowPoints2D,\n            sampleFragmentPoint\n          );\n\n          const inside = isInsideTriangle(sampleBarycentricCoords);\n          if (inside) {\n            const output = interpolateFn({\n              baseVertexIndex: vertexIndex,\n              fragmentPoint,\n              fragmentBarycentricCoords,\n              sampleBarycentricCoords,\n              clipSpacePoints,\n              ndcPoints,\n              windowPoints,\n              sampleIndex,\n              frontFacing,\n            });\n\n            const offset = ((y * width + x) * sampleCount + sampleIndex) * 4;\n            expected.set(output, offset);\n          }\n        }\n      }\n    }\n  }\n  return expected;\n}\n\n/**\n * Computes 'builtin(position)`\n */\nfunction computeFragmentPosition({\n  fragmentPoint,\n  fragmentBarycentricCoords,\n  clipSpacePoints,\n  windowPoints,\n}: FragData) {\n  return [\n    fragmentPoint[0],\n    fragmentPoint[1],\n    linearInterpolation(fragmentBarycentricCoords, getColumn(windowPoints, kZ)),\n    1 /\n      perspectiveInterpolation(\n        fragmentBarycentricCoords,\n        clipSpacePoints,\n        getColumn(clipSpacePoints, kW)\n      ),\n  ];\n}\n\n/**\n * Creates a function that will compute the interpolation of an inter-stage variable.\n */\nfunction createInterStageInterpolationFn(\n  interStagePoints: number[][],\n  type: InterpolationType,\n  sampling: InterpolationSampling | undefined\n) {\n  return function ({\n    baseVertexIndex,\n    fragmentBarycentricCoords,\n    sampleBarycentricCoords,\n    clipSpacePoints,\n  }: FragData) {\n    const triangleInterStagePoints = interStagePoints.slice(baseVertexIndex, baseVertexIndex + 3);\n    const barycentricCoords =\n      sampling === 'center' ? fragmentBarycentricCoords : sampleBarycentricCoords;\n    switch (type) {\n      case 'perspective':\n        return triangleInterStagePoints[0].map((_, colNum: number) =>\n          perspectiveInterpolation(\n            barycentricCoords,\n            clipSpacePoints,\n            getColumn(triangleInterStagePoints, colNum)\n          )\n        );\n        break;\n      case 'linear':\n        return triangleInterStagePoints[0].map((_, colNum: number) =>\n          linearInterpolation(barycentricCoords, getColumn(triangleInterStagePoints, colNum))\n        );\n        break;\n      case 'flat':\n        return triangleInterStagePoints[0];\n        break;\n      default:\n        unreachable();\n    }\n  };\n}\n\n/**\n * Creates a function that will compute the interpolation of an inter-stage variable\n * and then return [1, 0, 0, 0] if all interpolated values are between 0.0 and 1.0 inclusive\n * or [-1, 0, 0, 0] otherwise.\n */\nfunction createInterStageInterpolationBetween0And1TestFn(\n  interStagePoints: number[][],\n  type: InterpolationType,\n  sampling: InterpolationSampling | undefined\n) {\n  const interpolateFn = createInterStageInterpolationFn(interStagePoints, type, sampling);\n  return function (fragData: FragData) {\n    const interpolatedValues = interpolateFn(fragData);\n    const allTrue = interpolatedValues.reduce((all, v) => all && v >= 0 && v <= 1, true);\n    return [allTrue ? 1 : -1, 0, 0, 0];\n  };\n}\n\n/**\n * Computes 'builtin(sample_index)'\n */\nfunction computeFragmentSampleIndex({ sampleIndex }: FragData) {\n  return [sampleIndex, 0, 0, 0];\n}\n\n/**\n * Computes 'builtin(front_facing)'\n */\nfunction computeFragmentFrontFacing({ frontFacing }: FragData) {\n  return [frontFacing ? 1 : 0, 0, 0, 0];\n}\n\n/**\n * Renders float32 fragment shader inputs values to 4 rgba8unorm textures that\n * can be multisampled textures. It stores each of the channels, r, g, b, a of\n * the shader input to a separate texture, doing the math required to store the\n * float32 value into an rgba8unorm texel.\n *\n * Note: We could try to store the output to an vec4f storage buffer.\n * Unfortunately, using a storage buffer has the issue that we need to compute\n * an index with the very thing we're trying to test. Similarly, if we used a\n * storage texture we would need to compute texture locations with the things\n * we're trying to test. Also, using a storage buffer seems to affect certain\n * backends like M1 Mac so it seems better to stick to rgba8unorm here and test\n * using a storage buffer in a fragment shader separately.\n *\n * We can't use rgba32float because it's optional. We can't use rgba16float\n * because it's optional in compat. We can't we use rgba32uint as that can't be\n * multisampled.\n */\nasync function renderFragmentShaderInputsTo4TexturesAndReadbackValues(\n  t: GPUTest,\n  {\n    interpolationType,\n    interpolationSampling,\n    sampleCount,\n    width,\n    height,\n    nearFar,\n    frontFace,\n    clipSpacePoints,\n    interStagePoints,\n    fragInCode,\n    outputCode,\n  }: {\n    interpolationType: InterpolationType;\n    interpolationSampling?: InterpolationSampling;\n    width: number;\n    height: number;\n    sampleCount: number;\n    frontFace?: GPUFrontFace;\n    nearFar: readonly number[];\n    clipSpacePoints: readonly number[][];\n    interStagePoints: readonly number[][];\n    fragInCode: string;\n    outputCode: string;\n  }\n) {\n  const interpolate = `${interpolationType}${\n    interpolationSampling ? `, ${interpolationSampling}` : ''\n  }`;\n  const module = t.device.createShaderModule({\n    code: `\n      struct Uniforms {\n        resolution: vec2f,\n      };\n\n      @group(0) @binding(0) var<uniform> uni: Uniforms;\n\n      struct VertexOut {\n        @builtin(position) position: vec4f,\n        @location(0) @interpolate(${interpolate}) interpolatedValue: vec4f,\n      };\n\n      @vertex fn vs(@builtin(vertex_index) vNdx: u32) -> VertexOut {\n        let pos = array(\n          ${clipSpacePoints.map(p => `vec4f(${p.join(', ')})`).join(', ')}\n        );\n        let interStage = array(\n          ${interStagePoints.map(p => `vec4f(${p.join(', ')})`).join(', ')}\n        );\n        var v: VertexOut;\n        v.position = pos[vNdx];\n        v.interpolatedValue = interStage[vNdx];\n        _ = uni;\n        return v;\n      }\n\n      struct FragmentIn {\n        @builtin(position) position: vec4f,\n        @location(0) @interpolate(${interpolate}) interpolatedValue: vec4f,\n        ${fragInCode}\n      };\n\n      struct FragOut {\n        @location(0) out0: vec4f,\n        @location(1) out1: vec4f,\n        @location(2) out2: vec4f,\n        @location(3) out3: vec4f,\n      };\n\n      fn u32ToRGBAUnorm(u: u32) -> vec4f {\n        return vec4f(\n          f32((u >> 24) & 0xFF) / 255.0,\n          f32((u >> 16) & 0xFF) / 255.0,\n          f32((u >>  8) & 0xFF) / 255.0,\n          f32((u >>  0) & 0xFF) / 255.0,\n        );\n      }\n\n      @fragment fn fs(fin: FragmentIn) -> FragOut {\n        var f: FragOut;\n        let v = ${outputCode};\n        let u = bitcast<vec4u>(v);\n        f.out0 = u32ToRGBAUnorm(u[0]);\n        f.out1 = u32ToRGBAUnorm(u[1]);\n        f.out2 = u32ToRGBAUnorm(u[2]);\n        f.out3 = u32ToRGBAUnorm(u[3]);\n        _ = fin.interpolatedValue;\n        return f;\n      }\n    `,\n  });\n\n  const textures = range(4, () => {\n    const texture = t.device.createTexture({\n      size: [width, height],\n      usage:\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n      sampleCount,\n    });\n    t.trackForCleanup(texture);\n    return texture;\n  });\n\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets: textures.map(() => ({ format: 'rgba8unorm' })),\n    },\n    ...(frontFace && {\n      primitive: {\n        frontFace,\n      },\n    }),\n    multisample: {\n      count: sampleCount,\n    },\n  });\n\n  const uniformBuffer = t.device.createBuffer({\n    size: 8,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  t.trackForCleanup(uniformBuffer);\n  t.device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([width, height]));\n\n  const viewport = [0, 0, width, height, ...nearFar] as const;\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginRenderPass({\n    colorAttachments: textures.map(texture => ({\n      view: texture.createView(),\n      loadOp: 'clear',\n      storeOp: 'store',\n    })),\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.setViewport(viewport[0], viewport[1], viewport[2], viewport[3], viewport[4], viewport[5]);\n  pass.draw(clipSpacePoints.length);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  const buffer = copyRGBA8EncodedFloatTexturesToBufferIncludingMultisampledTextures(t, textures);\n  await buffer.mapAsync(GPUMapMode.READ);\n  return new Float32Array(buffer.getMappedRange());\n}\n\nfunction checkSampleRectsApproximatelyEqual({\n  width,\n  height,\n  sampleCount,\n  actual,\n  expected,\n  maxDiffULPsForFloatFormat,\n}: {\n  width: number;\n  height: number;\n  sampleCount: number;\n  actual: Float32Array;\n  expected: Float32Array;\n  maxDiffULPsForFloatFormat: number;\n}) {\n  const subrectOrigin = [0, 0, 0];\n  const subrectSize = [width * sampleCount, height, 1];\n  const areaDesc = {\n    bytesPerRow: width * sampleCount * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin,\n    subrectSize,\n  };\n\n  const format = 'rgba32float';\n  const actTexelView = TexelView.fromTextureDataByReference(\n    format,\n    new Uint8Array(actual.buffer),\n    areaDesc\n  );\n  const expTexelView = TexelView.fromTextureDataByReference(\n    format,\n    new Uint8Array(expected.buffer),\n    areaDesc\n  );\n\n  const failedPixelsMessage = findFailedPixels(\n    format,\n    { x: 0, y: 0, z: 0 },\n    { width: width * sampleCount, height, depthOrArrayLayers: 1 },\n    { actTexelView, expTexelView },\n    { maxDiffULPsForFloatFormat }\n  );\n\n  if (failedPixelsMessage !== undefined) {\n    const msg = 'Texture level had unexpected contents:\\n' + failedPixelsMessage;\n    return new ErrorWithExtra(msg, () => ({\n      expTexelView,\n      actTexelView,\n    }));\n  }\n\n  return undefined;\n}\n\ng.test('inputs,position')\n  .desc(\n    `\n    Test fragment shader builtin(position) values.\n\n    Note: @builtin(position) is always a fragment position, never a sample position.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        { type: 'perspective', sampling: 'centroid' },\n        { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        { type: 'linear', sampling: 'centroid' },\n        { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [0.333, 0.333, 0.333, 0.333],  //  1,  1, 1\n      [ 1.0,  -3.0,   0.25, 1.0  ],  //  1, -3, 0.25\n      [-1.5,   0.5,   0.25, 0.5  ],  // -3,  1, 0.5\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      fragInCode: '',\n      outputCode: 'fin.position',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: computeFragmentPosition,\n    });\n\n    // Since @builtin(position) is always a fragment position, never a sample position, check\n    // the first coordinate. It should be 0.5, 0.5 always. This is just to double check\n    // that computeFragmentPosition is generating the correct values.\n    assert(expected[0] === 0.5);\n    assert(expected[1] === 0.5);\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxDiffULPsForFloatFormat: 2,\n      })\n    );\n  });\n\ng.test('inputs,interStage')\n  .desc(\n    `\n    Test fragment shader inter-stage variable values except for centroid interpolation.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [0.333, 0.333, 0.333, 0.333],  //  1,  1, 1\n      [ 1.0,  -3.0,   0.25, 1.0  ],  //  1, -3, 0.25\n      [-1.5,   0.5,   0.25, 0.5  ],  // -3,  1, 0.5\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      fragInCode: '',\n      outputCode: 'fin.interpolatedValue',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: createInterStageInterpolationFn(interStagePoints, type, sampling),\n    });\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxDiffULPsForFloatFormat: 3,\n      })\n    );\n  });\n\ng.test('inputs,interStage,centroid')\n  .desc(\n    `\n    Test fragment shader inter-stage variable values in centroid sampling mode.\n\n    Centroid sampling mode is trying to solve the following issue\n\n    +-------------+\n    |....s1|/     |\n    |......|      |\n    |...../|   s2 |\n    +------C------+\n    |s3./  |      |\n    |../   |      |\n    |./    |s4    |\n    +-------------+\n\n    Above is a diagram of a texel where s1, s2, s3, s4 are sample points,\n    C is the center of the texel and the diagonal line is some edge of\n    a triangle. s1 and s3 are inside the triangle. In sampling = 'center'\n    modes, the interpolated value will be relative to C. The problem is,\n    C is outside of the triangle. In sample = 'centroid' mode, the\n    interpolated value will be computed relative to some point inside the\n    portion of the triangle inside the texel. While ideally it would be\n    the actual centroid, the specs from the various APIs suggest the only\n    guarantee is it's inside the triangle.\n\n    So, we set the interStage values to barycentric coords. We expect\n    that when sampling mode is 'center', some interpolated values\n    will be outside of the triangle (ie, one or more of their values will\n    be outside the 0 to 1 range). In sampling mode = 'centroid' mode, none\n    of the values will be outside of the 0 to 1 range.\n\n    Note: generateFragmentInputs below generates \"expected\". Values not\n    rendered to will be 0. Values rendered to outside the triangle will\n    be -1. Values rendered to inside the triangle will be 1. Manually\n    checking, \"expected\" for sampling = 'center' should have a couple of\n    -1 values where as \"expected\" for sampling = 'centroid' should not.\n    This was verified with manual testing.\n\n    Since we only care about inside vs outside of the triangle, having\n    createInterStageInterpolationFn use the interpolated value relative\n    to the sample point when sampling = 'centroid' will give us a value\n    inside the triangle, which is good enough for our test.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        { type: 'perspective', sampling: 'centroid' },\n        { type: 'linear', sampling: 'center' },\n        { type: 'linear', sampling: 'centroid' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    //\n    // We're drawing 1 triangle that cut the viewport\n    //\n    //  -1   0   1\n    //   +===+===+  2\n    //   |\\..|...|\n    //   +---+---+  1  <---\n    //   |  \\|...|       |\n    //   +---+---+  0    | viewport\n    //   |   |\\..|       |\n    //   +---+---+ -1  <---\n    //   |   |  \\|\n    //   +===+===+ -2\n\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [ 1, -2, 0, 1],\n      [-1,  2, 0, 1],\n      [ 1,  2, 0, 1],\n    ];\n\n    // prettier-ignore\n    const interStagePoints = [\n      [ 1, 0, 0, 0],\n      [ 0, 1, 0, 0],\n      [ 0, 0, 1, 0],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      fragInCode: '',\n      outputCode:\n        'vec4f(select(-1.0, 1.0, all(fin.interpolatedValue >= vec4f(0)) && all(fin.interpolatedValue <= vec4f(1))), 0, 0, 0)',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: createInterStageInterpolationBetween0And1TestFn(\n        interStagePoints,\n        type,\n        sampling\n      ),\n    });\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxDiffULPsForFloatFormat: 3,\n      })\n    );\n  });\n\ng.test('inputs,sample_index')\n  .desc(\n    `\n    Test fragment shader builtin(sample_index) values.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        { type: 'perspective', sampling: 'centroid' },\n        { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        { type: 'linear', sampling: 'centroid' },\n        { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIf(t.isCompatibility, 'sample_index is not supported in compatibility mode');\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      interpolation: { type, sampling },\n    } = t.params;\n    // prettier-ignore\n    const clipSpacePoints = [       // ndc values\n      [0.333, 0.333, 0.333, 0.333],  //  1,  1, 1\n      [ 1.0,  -3.0,   0.25, 1.0  ],  //  1, -3, 0.25\n      [-1.5,   0.5,   0.25, 0.5  ],  // -3,  1, 0.5\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      fragInCode: `@builtin(sample_index) sampleIndex: u32,`,\n      outputCode: 'vec4f(f32(fin.sampleIndex), 0, 0, 0)',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      interpolateFn: computeFragmentSampleIndex,\n    });\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxDiffULPsForFloatFormat: 1,\n      })\n    );\n  });\n\ng.test('inputs,front_facing')\n  .desc(\n    `\n    Test fragment shader builtin(front_facing) values.\n\n    Draws a quad from 2 triangles that entirely cover clip space. (see diagram below in code)\n    One triangle is clockwise, the other is counter clockwise. The triangles\n    bisect pixels so that different samples are covered by each triangle so that some\n    samples should get different values for front_facing for the same fragment.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('nearFar', [[0, 1] as const, [0.25, 0.75] as const] as const)\n      .combine('sampleCount', [1, 4] as const)\n      .combine('frontFace', ['cw', 'ccw'] as const)\n      .combine('interpolation', [\n        { type: 'perspective', sampling: 'center' },\n        { type: 'perspective', sampling: 'centroid' },\n        { type: 'perspective', sampling: 'sample' },\n        { type: 'linear', sampling: 'center' },\n        { type: 'linear', sampling: 'centroid' },\n        { type: 'linear', sampling: 'sample' },\n        { type: 'flat' },\n      ] as const)\n  )\n  .beforeAllSubcases(t => {\n    const {\n      interpolation: { type, sampling },\n    } = t.params;\n    t.skipIfInterpolationTypeOrSamplingNotSupported({ type, sampling });\n  })\n  .fn(async t => {\n    const {\n      nearFar,\n      sampleCount,\n      frontFace,\n      interpolation: { type, sampling },\n    } = t.params;\n    //\n    // We're drawing 2 triangles starting at y = -2 to y = +2\n    //\n    //  -1   0   1\n    //   +===+===+  2\n    //   |\\  |   |\n    //   +---+---+  1  <---\n    //   |  \\|   |       |\n    //   +---+---+  0    | viewport\n    //   |   |\\  |       |\n    //   +---+---+ -1  <---\n    //   |   |  \\|\n    //   +===+===+ -2\n\n    // prettier-ignore\n    const clipSpacePoints = [\n      // ccw\n      [-1, -2, 0, 1],\n      [ 1, -2, 0, 1],\n      [-1,  2, 0, 1],\n\n      // cw\n      [ 1, -2, 0, 1],\n      [-1,  2, 0, 1],\n      [ 1,  2, 0, 1],\n    ];\n\n    const interStagePoints = [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8],\n      [9, 10, 11, 12],\n\n      [13, 14, 15, 16],\n      [17, 18, 19, 20],\n      [21, 22, 23, 24],\n    ];\n\n    const width = 4;\n    const height = 4;\n    const actual = await renderFragmentShaderInputsTo4TexturesAndReadbackValues(t, {\n      interpolationType: type,\n      interpolationSampling: sampling,\n      frontFace,\n      sampleCount,\n      width,\n      height,\n      nearFar,\n      clipSpacePoints,\n      interStagePoints,\n      fragInCode: '@builtin(front_facing) frontFacing: bool,',\n      outputCode: 'vec4f(select(0.0, 1.0, fin.frontFacing), 0, 0, 0)',\n    });\n\n    const expected = generateFragmentInputs({\n      width,\n      height,\n      nearFar,\n      sampleCount,\n      clipSpacePoints,\n      frontFace,\n      interpolateFn: computeFragmentFrontFacing,\n    });\n\n    // Double check, first corner should be different than last based on the triangles we are drawing.\n    assert(expected[0] !== expected[expected.length - 4]);\n\n    t.expectOK(\n      checkSampleRectsApproximatelyEqual({\n        width,\n        height,\n        sampleCount,\n        actual,\n        expected,\n        maxDiffULPsForFloatFormat: 0,\n      })\n    );\n  });\n"],"mappings":"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"}
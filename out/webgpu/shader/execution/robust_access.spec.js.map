{"version":3,"file":"robust_access.spec.js","names":["description","makeTestGroup","assert","GPUTest","align","generateTypes","supportedScalarTypes","supportsAtomics","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","stage","testSource","layout","testBindings","dynamicOffsets","GPUShaderStage","COMPUTE","constantsBuffer","device","createBuffer","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","createShaderModule","code","pipeline","createComputePipelineAsync","compute","entryPoint","group","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f32","Float32Array","BYTES_PER_ELEMENT","fill","test","desc","params","u","combineWithParams","addressSpace","storageMode","access","dynamicOffset","containerType","shadowingMode","expand","p","beginSubcases","expandWithParams","fn","isAtomic","baseType","_kTypeInfo","undefined","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","testGroupBGLEntires","alignment","qualifiers","push","visibility","hasDynamicOffset","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","arrayLength","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprZeroElement","elementBaseType","exprElement","exprLoadElement","condition","moduleScopeShadowDecls","functionScopeShadowDecls","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray"],"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"sourcesContent":["export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport { generateTypes, supportedScalarTypes, supportsAtomics } from '../types.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nasync function runShaderTest(\n  t: GPUTest,\n  stage: GPUShaderStageFlags,\n  testSource: string,\n  layout: GPUPipelineLayout,\n  testBindings: GPUBindGroupEntry[],\n  dynamicOffsets?: number[]\n): Promise<void> {\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.device.createBuffer({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const source = `\nstruct Constants {\n  zero: u32\n};\n@group(1) @binding(0) var<uniform> constants: Constants;\n\nstruct Result {\n  value: u32\n};\n@group(1) @binding(1) var<storage, read_write> result: Result;\n\n${testSource}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = constants.zero; // Ensure constants buffer is statically-accessed\n  result.value = runTest();\n}`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = await t.device.createComputePipelineAsync({\n    layout,\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n      { binding: 0, resource: { buffer: constantsBuffer } },\n      { binding: 1, resource: { buffer: resultBuffer } },\n    ],\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup, dynamicOffsets);\n  pass.setBindGroup(1, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\n  array: ArrayBuffer,\n  type: 'u32' | 'i32' | 'f32',\n  { zeroByteStart, zeroByteCount }: { zeroByteStart: number; zeroByteCount: number }\n) {\n  const constructor = { u32: Uint32Array, i32: Int32Array, f32: Float32Array }[type];\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\n\ng.test('linear_memory')\n  .desc(\n    `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: false },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'read',\n          dynamicOffset: false,\n        },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: false,\n        },\n        { addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: true },\n        { addressSpace: 'storage', storageMode: 'read_write', access: 'read', dynamicOffset: true },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: true,\n        },\n        { addressSpace: 'uniform', access: 'read', dynamicOffset: false },\n        { addressSpace: 'uniform', access: 'read', dynamicOffset: true },\n        { addressSpace: 'private', access: 'read' },\n        { addressSpace: 'private', access: 'write' },\n        { addressSpace: 'function', access: 'read' },\n        { addressSpace: 'function', access: 'write' },\n        { addressSpace: 'workgroup', access: 'read' },\n        { addressSpace: 'workgroup', access: 'write' },\n      ] as const)\n      .combineWithParams([\n        { containerType: 'array' },\n        { containerType: 'matrix' },\n        { containerType: 'vector' },\n      ] as const)\n      .combineWithParams([\n        { shadowingMode: 'none' },\n        { shadowingMode: 'module-scope' },\n        { shadowingMode: 'function-scope' },\n      ])\n      .expand('isAtomic', p => (supportsAtomics(p) ? [false, true] : [false]))\n      .beginSubcases()\n      .expand('baseType', supportedScalarTypes)\n      .expandWithParams(generateTypes)\n  )\n  .fn(async t => {\n    const {\n      addressSpace,\n      storageMode,\n      access,\n      dynamicOffset,\n      isAtomic,\n      containerType,\n      baseType,\n      type,\n      shadowingMode,\n      _kTypeInfo,\n    } = t.params;\n\n    assert(_kTypeInfo !== undefined, 'not an indexable type');\n    assert('arrayLength' in _kTypeInfo);\n\n    let usesCanary = false;\n    let globalSource = '';\n    let testFunctionSource = '';\n    const testBufferSize = 512;\n    const bufferBindingOffset = 256;\n    /** Undefined if no buffer binding is needed */\n    let bufferBindingSize: number | undefined = undefined;\n\n    // Declare the data that will be accessed to check robust access, as a buffer or a struct\n    // in the global scope or inside the test function itself.\n    const structDecl = `\nstruct S {\n  startCanary: array<u32, 10>,\n  data: ${type},\n  endCanary: array<u32, 10>,\n};`;\n\n    const testGroupBGLEntires: GPUBindGroupLayoutEntry[] = [];\n    switch (addressSpace) {\n      case 'uniform':\n      case 'storage':\n        {\n          assert(_kTypeInfo.layout !== undefined);\n          const layout = _kTypeInfo.layout;\n          bufferBindingSize = align(layout.size, layout.alignment);\n          const qualifiers = addressSpace === 'storage' ? `storage, ${storageMode}` : addressSpace;\n          globalSource += `\nstruct TestData {\n  data: ${type},\n};\n@group(0) @binding(0) var<${qualifiers}> s: TestData;`;\n\n          testGroupBGLEntires.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type:\n                addressSpace === 'uniform'\n                  ? 'uniform'\n                  : storageMode === 'read'\n                  ? 'read-only-storage'\n                  : 'storage',\n              hasDynamicOffset: dynamicOffset,\n            },\n          });\n        }\n        break;\n\n      case 'private':\n      case 'workgroup':\n        usesCanary = true;\n        globalSource += structDecl;\n        globalSource += `var<${addressSpace}> s: S;`;\n        break;\n\n      case 'function':\n        usesCanary = true;\n        globalSource += structDecl;\n        testFunctionSource += 'var s: S;';\n        break;\n    }\n\n    // Build the test function that will do the tests.\n\n    // If we use a local canary declared in the shader, initialize it.\n    if (usesCanary) {\n      testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    s.startCanary[i] = 0xFFFFFFFFu;\n    s.endCanary[i] = 0xFFFFFFFFu;\n  }`;\n    }\n\n    /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n    const nextErrorReturnValue = (() => {\n      let errorReturnValue = 0x1000;\n      return () => {\n        ++errorReturnValue;\n        return `0x${errorReturnValue.toString(16)}u`;\n      };\n    })();\n\n    // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n    for (const indexSigned of [false, true]) {\n      const indicesToTest = indexSigned\n        ? [\n            // Exactly in bounds (should be OK)\n            '0',\n            `${_kTypeInfo.arrayLength} - 1`,\n            // Exactly out of bounds\n            '-1',\n            `${_kTypeInfo.arrayLength}`,\n            // Far out of bounds\n            '-1000000',\n            '1000000',\n            `${kMinI32}`,\n            `${kMaxI32}`,\n          ]\n        : [\n            // Exactly in bounds (should be OK)\n            '0u',\n            `${_kTypeInfo.arrayLength}u - 1u`,\n            // Exactly out of bounds\n            `${_kTypeInfo.arrayLength}u`,\n            // Far out of bounds\n            '1000000u',\n            `${kMaxU32}u`,\n            `${kMaxI32}u`,\n          ];\n\n      const indexTypeLiteral = indexSigned ? '0' : '0u';\n      const indexTypeCast = indexSigned ? 'i32' : 'u32';\n      for (const exprIndexAddon of [\n        '', // No addon\n        ` + ${indexTypeLiteral}`, // Add a literal 0\n        ` + ${indexTypeCast}(constants.zero)`, // Add a uniform 0\n      ]) {\n        // Produce the accesses to the variable.\n        for (const indexToTest of indicesToTest) {\n          testFunctionSource += `\n  {\n    let index = (${indexToTest})${exprIndexAddon};`;\n          const exprZeroElement = `${_kTypeInfo.elementBaseType}()`;\n          const exprElement = `s.data[index]`;\n\n          switch (access) {\n            case 'read':\n              {\n                let exprLoadElement = isAtomic ? `atomicLoad(&${exprElement})` : exprElement;\n                if (addressSpace === 'uniform' && containerType === 'array') {\n                  // Scalar types will be wrapped in a vec4 to satisfy array element size\n                  // requirements for the uniform address space, so we need an additional index\n                  // accessor expression.\n                  exprLoadElement += '[0]';\n                }\n                let condition = `${exprLoadElement} != ${exprZeroElement}`;\n                if (containerType === 'matrix') condition = `any(${condition})`;\n                testFunctionSource += `\n    if (${condition}) { return ${nextErrorReturnValue()}; }`;\n              }\n              break;\n\n            case 'write':\n              if (isAtomic) {\n                testFunctionSource += `\n    atomicStore(&s.data[index], ${exprZeroElement});`;\n              } else {\n                testFunctionSource += `\n    s.data[index] = ${exprZeroElement};`;\n              }\n              break;\n          }\n          testFunctionSource += `\n  }`;\n        }\n      }\n    }\n\n    // Check that the canaries haven't been modified\n    if (usesCanary) {\n      testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    if (s.startCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n    if (s.endCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n  }`;\n    }\n\n    // Shadowing case declarations\n    let moduleScopeShadowDecls = '';\n    let functionScopeShadowDecls = '';\n\n    switch (shadowingMode) {\n      case 'module-scope':\n        // Shadow the builtins likely used by robustness as module-scope variables\n        moduleScopeShadowDecls = `\nvar<private> min = 0;\nvar<private> max = 0;\nvar<private> arrayLength = 0;\n`;\n        // Make sure that these are referenced by the function.\n        // This ensures that compilers don't strip away unused variables.\n        functionScopeShadowDecls = `\n  _ = min;\n  _ = max;\n  _ = arrayLength;\n`;\n        break;\n      case 'function-scope':\n        // Shadow the builtins likely used by robustness as function-scope variables\n        functionScopeShadowDecls = `\n  let min = 0;\n  let max = 0;\n  let arrayLength = 0;\n`;\n        break;\n    }\n\n    // Run the test\n\n    // First aggregate the test source\n    const testSource = `\n${globalSource}\n${moduleScopeShadowDecls}\n\nfn runTest() -> u32 {\n  ${functionScopeShadowDecls}\n  ${testFunctionSource}\n  return 0u;\n}`;\n\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts: [\n        t.device.createBindGroupLayout({\n          entries: testGroupBGLEntires,\n        }),\n        t.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'uniform',\n              },\n            },\n            {\n              binding: 1,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'storage',\n              },\n            },\n          ],\n        }),\n      ],\n    });\n\n    // Run it.\n    if (bufferBindingSize !== undefined && baseType !== 'bool') {\n      const expectedData = new ArrayBuffer(testBufferSize);\n      const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n      testFillArrayBuffer(expectedData, baseType, {\n        zeroByteStart: bufferBindingOffset,\n        zeroByteCount: bufferBindingSize,\n      });\n\n      // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n      const testBuffer = t.makeBufferWithContents(\n        new Uint8Array(expectedData),\n        GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.UNIFORM |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.COPY_DST\n      );\n\n      // Run the shader, accessing the buffer.\n      await runShaderTest(\n        t,\n        GPUShaderStage.COMPUTE,\n        testSource,\n        layout,\n        [\n          {\n            binding: 0,\n            resource: {\n              buffer: testBuffer,\n              offset: dynamicOffset ? 0 : bufferBindingOffset,\n              size: bufferBindingSize,\n            },\n          },\n        ],\n        dynamicOffset ? [bufferBindingOffset] : undefined\n      );\n\n      // Check that content of the buffer outside of the allowed area didn't change.\n      const expectedBytes = new Uint8Array(expectedData);\n      t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n      t.expectGPUBufferValuesEqual(\n        testBuffer,\n        expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n        bufferBindingEnd\n      );\n    } else {\n      await runShaderTest(t, GPUShaderStage.COMPUTE, testSource, layout, []);\n    }\n  });\n"],"mappings":"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"}
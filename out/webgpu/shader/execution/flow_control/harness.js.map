{"version":3,"file":"harness.js","names":["Colors","runFlowControlTest","t","build_wgsl","inputData","Array","expectations","build_wgsl_result","value","v","params","preventValueOptimizations","push","length","expect_order","expected","kind","stack","Error","values","counter","expect_not_reached","built_wgsl","entrypoint","extra","main_wgsl","undefined","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","GPUBufferUsage","STORAGE","maxOutputValues","outputBuffer","createBuffer","size","usage","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","eventualExpectOK","readGPUBufferRangeTyped","type","typedLength","then","outputs","outputCount","data","fail","err","dim","blue","expect_order_err","expectation","err_idx","out","i","green","red","event","expectationIndex","cleanup"],"sources":["../../../../../src/webgpu/shader/execution/flow_control/harness.ts"],"sourcesContent":["import { Colors } from '../../../../common/util/colors.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\n/**\n * Options for runFlowControlTest()\n */\ninterface FlowControlTest extends GPUTest {\n  params: {\n    /**\n     * If true, then constant values will be placed into a storage buffer,\n     * preventing the shader compiler from knowing the value at compile time.\n     * This can prevent constant folding, loop unrolling, dead-code\n     * optimizations etc, which would could all affect the tests.\n     */\n    preventValueOptimizations?: boolean;\n  };\n}\n\n/**\n * The builder interface for the runFlowControlTest() callback.\n * This interface is indented to be used to inject WGSL logic into the test\n * shader.\n * @see runFlowControlTest\n */\ninterface FlowControlTestBuilder {\n  /**\n   * Emits a value into the shader.\n   * If the FlowControlTest.params.preventValueOptimizations flag is enabled,\n   * then value() emits an expression to load the given value from a storage\n   * buffer, preventing the shader compiler from knowing the value at compile\n   * time. This can prevent constant folding, loop unrolling, dead-code\n   * optimizations etc, which would could all affect the tests.\n   */\n  value(v: number | boolean): string;\n\n  /**\n   * Emits an expectation that the statement will be executed at the given\n   * chronological events.\n   * @param event one or more chronological events, the first being 0.\n   */\n  expect_order(...event: number[]): string;\n\n  /**\n   * Emits an expectation that the statement will not be reached.\n   */\n  expect_not_reached(): string;\n}\n\n/**\n * Builds, runs then checks the output of a flow control shader test.\n *\n * @p build_wgsl is a function that's called to build the WGSL shader.\n * This function takes a FlowControlTestBuilder as the single argument, and\n * returns either a string which is embedded into the WGSL entrypoint function,\n * or an object of the signature `{ entrypoint: string; extra: string }` which\n * contains the entrypoint code, along with additional module-scope code.\n *\n * The FlowControlTestBuilder should be used to insert expectations into WGSL to\n * validate control flow. FlowControlTestBuilder also can be used to add values\n * to the shader which cannot be optimized away.\n *\n * Example, testing that an if-statement behaves as expected:\n *\n * ```\n *   runFlowControlTest(t, f =>\n *   `\n *    ${f.expect_order(0)}\n *    if (${f.value(true)}) {\n *      ${f.expect_order(1)}\n *    } else {\n *      ${f.expect_not_reached()}\n *    }\n *    ${f.expect_order(2)}\n *  `);\n * ```\n *\n * @param t The test object\n * @param builder The shader builder function that takes a\n * FlowControlTestBuilder as the single argument, and returns either a WGSL\n * string which is embedded into the WGSL entrypoint function, or a structure\n * with entrypoint-scoped WGSL code and extra module-scope WGSL code.\n */\nexport function runFlowControlTest(\n  t: FlowControlTest,\n  build_wgsl: (builder: FlowControlTestBuilder) => string | { entrypoint: string; extra: string }\n) {\n  const inputData = new Array<number>();\n\n  type ExpectedEvents = {\n    kind: 'events';\n    stack: string | undefined;\n    values: number[];\n    counter: number;\n  };\n  type ExpectedNotReached = {\n    kind: 'not-reached';\n    stack: string | undefined;\n  };\n\n  const expectations = new Array<ExpectedEvents | ExpectedNotReached>();\n\n  const build_wgsl_result = build_wgsl({\n    value: v => {\n      if (t.params.preventValueOptimizations) {\n        if (typeof v === 'boolean') {\n          inputData.push(v ? 1 : 0);\n          return `inputs[${inputData.length - 1}] != 0`;\n        }\n        inputData.push(v);\n        return `inputs[${inputData.length - 1}]`;\n      } else {\n        return `${v}`;\n      }\n    },\n    expect_order: (...expected) => {\n      expectations.push({\n        kind: 'events',\n        stack: Error().stack,\n        values: expected,\n        counter: 0,\n      });\n      return `push_output(${expectations.length - 1});`;\n    },\n    expect_not_reached: () => {\n      expectations.push({\n        kind: 'not-reached',\n        stack: Error().stack,\n      });\n      return `push_output(${expectations.length - 1});`;\n    },\n  });\n\n  const built_wgsl =\n    typeof build_wgsl_result === 'string'\n      ? { entrypoint: build_wgsl_result, extra: '' }\n      : build_wgsl_result;\n\n  const main_wgsl = built_wgsl.entrypoint !== undefined ? built_wgsl : built_wgsl.entrypoint;\n\n  const wgsl = `\nstruct Outputs {\n  count : u32,\n  data  : array<u32>,\n};\n@group(0) @binding(0) var<storage, read>       inputs  : array<i32>;\n@group(0) @binding(1) var<storage, read_write> outputs : Outputs;\n\nfn push_output(value : u32) {\n  outputs.data[outputs.count] = value;\n  outputs.count++;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = &inputs;\n  _ = &outputs;\n  ${main_wgsl.entrypoint}\n}\n${main_wgsl.extra}\n`;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  // If there are no inputs, just put a single value in the buffer to keep\n  // makeBufferWithContents() happy.\n  if (inputData.length === 0) {\n    inputData.push(0);\n  }\n\n  const inputBuffer = t.makeBufferWithContents(new Uint32Array(inputData), GPUBufferUsage.STORAGE);\n\n  const maxOutputValues = 1000;\n  const outputBuffer = t.device.createBuffer({\n    size: 4 * (1 + maxOutputValues),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  t.eventualExpectOK(\n    t\n      .readGPUBufferRangeTyped(outputBuffer, {\n        type: Uint32Array,\n        typedLength: outputBuffer.size / 4,\n      })\n      .then(outputs => {\n        // outputs[0]    is the number of outputted values\n        // outputs[1..N] holds the outputted values\n        const outputCount = outputs.data[0];\n        if (outputCount > maxOutputValues) {\n          return new Error(\n            `output data count (${outputCount}) exceeds limit of ${maxOutputValues}`\n          );\n        }\n\n        // returns an Error with the given message and WGSL source\n        const fail = (err: string) => Error(`${err}\\nWGSL:\\n${Colors.dim(Colors.blue(wgsl))}`);\n\n        // returns a colorized string of the expect_order() call, highlighting\n        // the event number that caused an error.\n        const expect_order_err = (expectation: ExpectedEvents, err_idx: number) => {\n          let out = 'expect_order(';\n          for (let i = 0; i < expectation.values.length; i++) {\n            if (i > 0) {\n              out += ', ';\n            }\n            if (i < err_idx) {\n              out += Colors.green(`${expectation.values[i]}`);\n            } else if (i > err_idx) {\n              out += Colors.dim(`${expectation.values[i]}`);\n            } else {\n              out += Colors.red(`${expectation.values[i]}`);\n            }\n          }\n          out += ')';\n          return out;\n        };\n\n        // Each of the outputted values represents an event\n        // Check that each event is as expected\n        for (let event = 0; event < outputCount; event++) {\n          const expectationIndex = outputs.data[1 + event]; // 0 is count\n          if (expectationIndex >= expectations.length) {\n            return fail(\n              `outputs.data[${event}] value (${expectationIndex}) exceeds number of expectations (${expectations.length})`\n            );\n          }\n          const expectation = expectations[expectationIndex];\n          switch (expectation.kind) {\n            case 'not-reached':\n              return fail(`expect_not_reached() reached at event ${event}\\n${expectation.stack}`);\n            case 'events':\n              if (expectation.counter >= expectation.values.length) {\n                return fail(\n                  `${expect_order_err(\n                    expectation,\n                    expectation.counter\n                  )}) unexpectedly reached at event ${Colors.red(`${event}`)}\\n${expectation.stack}`\n                );\n              }\n              if (event !== expectation.values[expectation.counter]) {\n                return fail(\n                  `${expect_order_err(expectation, expectation.counter)} expected event ${\n                    expectation.values[expectation.counter]\n                  }, got ${event}\\n${expectation.stack}`\n                );\n              }\n\n              expectation.counter++;\n              break;\n          }\n        }\n\n        // Finally check that all expect_order() calls were reached\n        for (const expectation of expectations) {\n          if (expectation.kind === 'events' && expectation.counter !== expectation.values.length) {\n            return fail(\n              `${expect_order_err(expectation, expectation.counter)} event ${\n                expectation.values[expectation.counter]\n              } was not reached\\n${expectation.stack}`\n            );\n          }\n        }\n        outputs.cleanup();\n        return undefined;\n      })\n  );\n}\n"],"mappings":"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"}
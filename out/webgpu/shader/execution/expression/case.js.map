{"version":3,"file":"case.js","names":["crc32","assert","abstractInt","i32","u32","VectorValue","cartesianProduct","quantizeToI32","quantizeToI64","quantizeToU32","notUndefined","value","undefined","selectNCases","dis","n","cases","Math","round","count","length","dis_crc32","filter","c","trunc","input","toString","makeScalarVectorBinaryToVectorCase","scalar","vector","op","quantize","scalarize","map","result","v","includes","expected","generateScalarVectorBinaryToVectorCases","scalars","vectors","flatMap","s","makeVectorScalarBinaryToVectorCase","generateVectorScalarBinaryToVectorCases","generateU32VectorBinaryToVectorCases","generateVectorU32BinaryToVectorCases","generateI32VectorBinaryToVectorCases","generateVectorI32BinaryToVectorCases","generateI64VectorBinaryToVectorCases","generateVectorI64BinaryToVectorCases","generateScalarBinaryToScalarCases","param0s","param1s","reduce","e","push","Array","generateBinaryToI32Cases","generateBinaryToU32Cases","generateBinaryToI64Cases","makeVectorVectorToScalarCase","param0","param1","param0_quantized","param1_quantized","generateVectorVectorToScalarCases","generateVectorVectorToI32Cases","generateVectorVectorToU32Cases","generateVectorVectorToI64Cases"],"sources":["../../../../../src/webgpu/shader/execution/expression/case.ts"],"sourcesContent":["import { crc32 } from '../../../../common/util/crc32.js';\nimport { ROArrayArray } from '../../../../common/util/types.js';\nimport { assert } from '../../../../common/util/util.js';\nimport {\n  abstractInt,\n  i32,\n  ScalarBuilder,\n  u32,\n  Value,\n  VectorValue,\n} from '../../../util/conversion.js';\nimport {\n  cartesianProduct,\n  QuantizeFunc,\n  quantizeToI32,\n  quantizeToI64,\n  quantizeToU32,\n} from '../../../util/math.js';\n\nimport { Expectation } from './expectation.js';\n\nfunction notUndefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | ReadonlyArray<Value>;\n  // The expected result, or function to check the result\n  expected: Expectation;\n};\n\n/**\n * Filters a given set of Cases down to a target number of cases by\n * randomly selecting which Cases to return.\n *\n * The selection algorithm is deterministic and stable for a case's\n * inputs.\n *\n * This means that if a specific case is selected is not affected by the\n * presence of other cases in the list, so in theory it is possible to create a\n * pathological set of cases such that all or not of the cases are selected\n * in spite of the target number.\n *\n * This is a trade-off from guaranteeing stability of the selected cases over\n * small changes, so the target number of cases is more of a suggestion. It is\n * still guaranteed that if you set n0 < n1, then the invocation with n0 will\n * return at most the number of cases that n1 does, it just isn't guaranteed to\n * be less.\n *\n * @param dis is a string provided for additional hashing information to avoid\n *            systemic bias in the selection process across different test\n *            suites. Specifically every Case with the same input values being\n *            included or skipped regardless of the operation that they are\n *            testing. This string should be something like the name of the case\n *            cache the values are for or the operation under test.\n * @param n number of cases targeted be returned. Expected to be a positive\n *          integer. If equal or greater than the number of cases, then all the\n *          cases are returned. 0 is not allowed, since it is likely a\n *          programming error, because if the caller intentionally wants 0\n *          items, they can just use [].\n * @param cases list of Cases to be selected from.\n */\nexport function selectNCases(dis: string, n: number, cases: Case[]): Case[] {\n  assert(n > 0 && Math.round(n) === n, `n ${n} is expected to be a positive integer`);\n  const count = cases.length;\n  if (n >= count) {\n    return cases;\n  }\n  const dis_crc32 = crc32(dis);\n  return cases.filter(\n    c => Math.trunc((n / count) * 0xffff_ffff) > (crc32(c.input.toString()) ^ dis_crc32) >>> 0\n  );\n}\n\n/**\n * A function that performs a binary operation on x and y, and returns the\n * expected result.\n */\nexport interface BinaryOp<T> {\n  (x: T, y: T): T | undefined;\n}\n\n/**\n * A function that performs a vector-vector operation on x and y, and returns the\n * expected result.\n */\nexport interface VectorVectorToScalarOp<T> {\n  (x: T[], y: T[]): T | undefined;\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param scalar scalar param\n * @param vector vector param (2, 3, or 4 elements)\n * @param op the op to apply to scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeScalarVectorBinaryToVectorCase<T>(\n  scalar: T,\n  vector: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case | undefined {\n  scalar = quantize(scalar);\n  vector = vector.map(quantize);\n  const result = vector.map(v => op(scalar, v));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [scalarize(scalar), new VectorValue(vector.map(scalarize))],\n    expected: new VectorValue(result.filter(notUndefined).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op the op to apply to each pair of scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarVectorBinaryToVectorCases<T>(\n  scalars: readonly T[],\n  vectors: ROArrayArray<T>,\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  return scalars.flatMap(s => {\n    return vectors\n      .map(v => {\n        return makeScalarVectorBinaryToVectorCase(s, v, op, quantize, scalarize);\n      })\n      .filter(notUndefined);\n  });\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param vector vector param (2, 3, or 4 elements)\n * @param scalar scalar param\n * @param op the op to apply to vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorScalarBinaryToVectorCase<T>(\n  vector: readonly T[],\n  scalar: T,\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case | undefined {\n  vector = vector.map(quantize);\n  scalar = quantize(scalar);\n  const result = vector.map(v => op(v, scalar));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [new VectorValue(vector.map(scalarize)), scalarize(scalar)],\n    expected: new VectorValue(result.filter(notUndefined).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op the op to apply to each pair of vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorScalarBinaryToVectorCases<T>(\n  vectors: ROArrayArray<T>,\n  scalars: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  return scalars.flatMap(s => {\n    return vectors\n      .map(v => {\n        return makeVectorScalarBinaryToVectorCase(v, s, op, quantize, scalarize);\n      })\n      .filter(notUndefined);\n  });\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateU32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp<number>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorU32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp<number>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp<number>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp<number>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI64VectorBinaryToVectorCases(\n  scalars: readonly bigint[],\n  vectors: ROArrayArray<bigint>,\n  op: BinaryOp<bigint>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI64BinaryToVectorCases(\n  vectors: ROArrayArray<bigint>,\n  scalars: readonly bigint[],\n  op: BinaryOp<bigint>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n * @param quantize function to quantize all values\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarBinaryToScalarCases<T>(\n  param0s: readonly T[],\n  param1s: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  param0s = param0s.map(quantize);\n  param1s = param1s.map(quantize);\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [scalarize(e[0]), scalarize(e[1])], expected: scalarize(expected) });\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp<number>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToU32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp<number>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI64Cases(\n  param0s: readonly bigint[],\n  param1s: readonly bigint[],\n  op: BinaryOp<bigint>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param param0 vector param (2, 3, or 4 elements) for the first param\n * @param param1 vector param (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorVectorToScalarCase<T>(\n  param0: readonly T[],\n  param1: readonly T[],\n  op: VectorVectorToScalarOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case | undefined {\n  const param0_quantized = param0.map(quantize);\n  const param1_quantized = param1.map(quantize);\n  const result = op(param0_quantized, param1_quantized);\n  if (result === undefined) return undefined;\n\n  return {\n    input: [\n      new VectorValue(param0_quantized.map(scalarize)),\n      new VectorValue(param1_quantized.map(scalarize)),\n    ],\n    expected: scalarize(result),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorVectorToScalarCases<T>(\n  param0s: ROArrayArray<T>,\n  param1s: ROArrayArray<T>,\n  op: VectorVectorToScalarOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  return param0s.flatMap(param0 => {\n    return param1s\n      .map(param1 => {\n        return makeVectorVectorToScalarCase(param0, param1, op, quantize, scalarize);\n      })\n      .filter(notUndefined);\n  });\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToI32Cases(\n  param0s: ROArrayArray<number>,\n  param1s: ROArrayArray<number>,\n  op: VectorVectorToScalarOp<number>\n): Case[] {\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToU32Cases(\n  param0s: ROArrayArray<number>,\n  param1s: ROArrayArray<number>,\n  op: VectorVectorToScalarOp<number>\n): Case[] {\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToI64Cases(\n  param0s: ROArrayArray<bigint>,\n  param1s: ROArrayArray<bigint>,\n  op: VectorVectorToScalarOp<bigint>\n): Case[] {\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToI64, abstractInt);\n}\n"],"mappings":"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"}
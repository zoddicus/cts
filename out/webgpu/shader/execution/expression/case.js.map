{"version":3,"file":"case.js","names":["Vector","i32","u32","abstractInt","cartesianProduct","quantizeToI32","quantizeToU32","quantizeToI64","notUndefined","value","undefined","makeScalarVectorBinaryToVectorCase","scalar","vector","op","quantize","scalarize","map","result","v","includes","input","expected","filter","generateScalarVectorBinaryToVectorCases","scalars","vectors","flatMap","s","makeVectorScalarBinaryToVectorCase","generateVectorScalarBinaryToVectorCases","generateU32VectorBinaryToVectorCases","generateVectorU32BinaryToVectorCases","generateI32VectorBinaryToVectorCases","generateVectorI32BinaryToVectorCases","generateI64VectorBinaryToVectorCases","generateVectorI64BinaryToVectorCases","generateScalarBinaryToScalarCases","param0s","param1s","reduce","cases","e","push","Array","generateBinaryToI32Cases","generateBinaryToU32Cases","generateBinaryToI64Cases"],"sources":["../../../../../src/webgpu/shader/execution/expression/case.ts"],"sourcesContent":["import { ROArrayArray } from '../../../../common/util/types.js';\nimport { ScalarBuilder, Value, Vector, i32, u32, abstractInt } from '../../../util/conversion.js';\nimport {\n  QuantizeFunc,\n  cartesianProduct,\n  quantizeToI32,\n  quantizeToU32,\n  quantizeToI64,\n} from '../../../util/math.js';\n\nimport { Expectation } from './expectation.js';\n\nfunction notUndefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | ReadonlyArray<Value>;\n  // The expected result, or function to check the result\n  expected: Expectation;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/**\n * A function that performs a binary operation on x and y, and returns the\n * expected result.\n */\nexport interface BinaryOp<T> {\n  (x: T, y: T): T | undefined;\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param scalar scalar param\n * @param vector vector param (2, 3, or 4 elements)\n * @param op the op to apply to scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeScalarVectorBinaryToVectorCase<T>(\n  scalar: T,\n  vector: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case | undefined {\n  scalar = quantize(scalar);\n  vector = vector.map(quantize);\n  const result = vector.map(v => op(scalar, v));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [scalarize(scalar), new Vector(vector.map(scalarize))],\n    expected: new Vector(result.filter(notUndefined).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op the op to apply to each pair of scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarVectorBinaryToVectorCases<T>(\n  scalars: readonly T[],\n  vectors: ROArrayArray<T>,\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  return scalars.flatMap(s => {\n    return vectors\n      .map(v => {\n        return makeScalarVectorBinaryToVectorCase(s, v, op, quantize, scalarize);\n      })\n      .filter(notUndefined);\n  });\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param vector vector param (2, 3, or 4 elements)\n * @param scalar scalar param\n * @param op the op to apply to vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorScalarBinaryToVectorCase<T>(\n  vector: readonly T[],\n  scalar: T,\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case | undefined {\n  vector = vector.map(quantize);\n  scalar = quantize(scalar);\n  const result = vector.map(v => op(v, scalar));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(vector.map(scalarize)), scalarize(scalar)],\n    expected: new Vector(result.filter(notUndefined).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op the op to apply to each pair of vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorScalarBinaryToVectorCases<T>(\n  vectors: ROArrayArray<T>,\n  scalars: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  return scalars.flatMap(s => {\n    return vectors\n      .map(v => {\n        return makeVectorScalarBinaryToVectorCase(v, s, op, quantize, scalarize);\n      })\n      .filter(notUndefined);\n  });\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateU32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp<number>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorU32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp<number>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp<number>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp<number>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI64VectorBinaryToVectorCases(\n  scalars: readonly bigint[],\n  vectors: ROArrayArray<bigint>,\n  op: BinaryOp<bigint>\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI64BinaryToVectorCases(\n  vectors: ROArrayArray<bigint>,\n  scalars: readonly bigint[],\n  op: BinaryOp<bigint>\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n * @param quantize function to quantize all values\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarBinaryToScalarCases<T>(\n  param0s: readonly T[],\n  param1s: readonly T[],\n  op: BinaryOp<T>,\n  quantize: QuantizeFunc<T>,\n  scalarize: ScalarBuilder<T>\n): Case[] {\n  param0s = param0s.map(quantize);\n  param1s = param1s.map(quantize);\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [scalarize(e[0]), scalarize(e[1])], expected: scalarize(expected) });\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp<number>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToU32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp<number>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI64Cases(\n  param0s: readonly bigint[],\n  param1s: readonly bigint[],\n  op: BinaryOp<bigint>\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI64, abstractInt);\n}\n"],"mappings":"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"}
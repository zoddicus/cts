{"version":3,"file":"expression.js","names":["globalTestConfig","assert","objectEquals","unreachable","compare","kValue","ScalarType","Scalar","TypeVec","TypeU32","Vector","VectorType","u32","i32","Matrix","MatrixType","scalarTypeOf","FPInterval","cartesianProduct","quantizeToI32","quantizeToU32","isComparator","e","Array","toComparator","input","got","kind","allInputSources","onlyConstInputSource","valueStride","ty","width","cols","rows","toString","valueStrides","tys","map","reduce","sum","c","storageType","elementType","fromStorage","expr","toStorage","getOrCreate","key","create","existing","get","undefined","value","set","run","t","shaderBuilder","parameterTypes","resultType","cfg","inputSource","cases","batch_size","vectorize","packed","packScalarsToVector","casesPerBatch","Math","floor","min","device","limits","maxUniformBufferBindingSize","maxStorageBufferBindingSize","pipelineCache","Map","maxBatchesInFlight","batchesInFlight","resolvePromiseBlockingBatch","batchFinishedCallback","processBatch","batchCases","checkBatch","submitBatch","queue","onSubmittedWorkDone","finally","pendingBatches","i","length","slice","Promise","resolve","push","all","outputBufferSize","outputBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","pipeline","group","buildPipeline","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","testHeartbeatCallback","submit","finish","checkExpectation","outputData","outputs","read","errs","caseIdx","cmp","expected","matched","join","Error","expectGPUBufferValuesPassCheck","type","Uint8Array","typedLength","v","fn","wgslOutputs","count","output_struct","dim","wgslValuesArray","expressionBuilder","wgsl","wgslInputVar","wgslHeader","usedF16","some","header","basicExpressionShaderBody","body","unrollConstEvalLoops","_","paramExpr","basicExpressionBuilder","basicExpressionWithPredeclarationBuilder","predeclaration","compoundAssignmentBuilder","op","lhsType","rhsType","values","abstractFloatSnippet","case_idx","accessor","f64","positive","subnormal","max","negative","abstractFloatCaseBody","keys","idx","results","r","abstractFloatShaderBuilder","forEach","inputTypes","input_str","param_str","source","module","createShaderModule","code","createComputePipelineAsync","layout","compute","entryPoint","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","inputSize","inputData","caseStride","caseBase","offset","paramIdx","params","copyTo","createComputePipeline","inputBuffer","makeBufferWithContents","UNIFORM","vectorWidth","packedCases","packedParameterTypes","p","packedResultType","clampCaseIdx","packedInputs","inputElements","cmp_impls","comparators","gElements","eElements","d","elements","generateScalarBinaryToScalarCases","param0s","param1s","quantize","scalarize","generateBinaryToI32Cases","generateBinaryToU32Cases","makeScalarVectorBinaryToVectorCase","scalar","vector","result","includes","generateScalarVectorBinaryToVectorCases","scalars","vectors","s","makeVectorScalarBinaryToVectorCase","generateVectorScalarBinaryToVectorCases","generateU32VectorBinaryToVectorCases","generateVectorU32BinaryToVectorCases","generateI32VectorBinaryToVectorCases","generateVectorI32BinaryToVectorCases"],"sources":["../../../../../src/webgpu/shader/execution/expression/expression.ts"],"sourcesContent":["import { globalTestConfig } from '../../../../common/framework/test_config.js';\nimport { ROArrayArray } from '../../../../common/util/types.js';\nimport { assert, objectEquals, unreachable } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { compare, Comparator, ComparatorImpl } from '../../../util/compare.js';\nimport { kValue } from '../../../util/constants.js';\nimport {\n  ScalarType,\n  Scalar,\n  Type,\n  TypeVec,\n  TypeU32,\n  Value,\n  Vector,\n  VectorType,\n  u32,\n  i32,\n  Matrix,\n  MatrixType,\n  ScalarBuilder,\n  scalarTypeOf,\n} from '../../../util/conversion.js';\nimport { FPInterval } from '../../../util/floating_point.js';\nimport {\n  cartesianProduct,\n  QuantizeFunc,\n  quantizeToI32,\n  quantizeToU32,\n} from '../../../util/math.js';\n\nexport type Expectation =\n  | Value\n  | FPInterval\n  | readonly FPInterval[]\n  | ROArrayArray<FPInterval>\n  | Comparator;\n\n/** @returns if this Expectation actually a Comparator */\nexport function isComparator(e: Expectation): e is Comparator {\n  return !(\n    e instanceof FPInterval ||\n    e instanceof Scalar ||\n    e instanceof Vector ||\n    e instanceof Matrix ||\n    e instanceof Array\n  );\n}\n\n/** @returns the input if it is already a Comparator, otherwise wraps it in a 'value' comparator */\nexport function toComparator(input: Expectation): Comparator {\n  if (isComparator(input)) {\n    return input;\n  }\n\n  return { compare: got => compare(got, input as Value), kind: 'value' };\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | ReadonlyArray<Value>;\n  // The expected result, or function to check the result\n  expected: Expectation;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/** The input value source */\nexport type InputSource =\n  | 'const' // Shader creation time constant values (@const)\n  | 'uniform' // Uniform buffer\n  | 'storage_r' // Read-only storage buffer\n  | 'storage_rw'; // Read-write storage buffer\n\n/** All possible input sources */\nexport const allInputSources: InputSource[] = ['const', 'uniform', 'storage_r', 'storage_rw'];\n\n/** Just constant input source */\nexport const onlyConstInputSource: InputSource[] = ['const'];\n\n/** Configuration for running a expression test */\nexport type Config = {\n  // Where the input values are read from\n  inputSource: InputSource;\n  // If defined, scalar test cases will be packed into vectors of the given\n  // width, which must be 2, 3 or 4.\n  // Requires that all parameters of the expression overload are of a scalar\n  // type, and the return type of the expression overload is also a scalar type.\n  // If the number of test cases is not a multiple of the vector width, then the\n  // last scalar value is repeated to fill the last vector value.\n  vectorize?: number;\n};\n\n// Helper for returning the stride for a given Type\nfunction valueStride(ty: Type): number {\n  // AbstractFloats are passed out of the shader via a struct of 2x u32s and\n  // unpacking containers as arrays\n  if (scalarTypeOf(ty).kind === 'abstract-float') {\n    if (ty instanceof ScalarType) {\n      return 16;\n    }\n    if (ty instanceof VectorType) {\n      if (ty.width === 2) {\n        return 16;\n      }\n      // vec3s have padding to make them the same size as vec4s\n      return 32;\n    }\n    if (ty instanceof MatrixType) {\n      switch (ty.cols) {\n        case 2:\n          switch (ty.rows) {\n            case 2:\n              return 32;\n            case 3:\n              return 64;\n            case 4:\n              return 64;\n          }\n          break;\n        case 3:\n          switch (ty.rows) {\n            case 2:\n              return 48;\n            case 3:\n              return 96;\n            case 4:\n              return 96;\n          }\n          break;\n        case 4:\n          switch (ty.rows) {\n            case 2:\n              return 64;\n            case 3:\n              return 128;\n            case 4:\n              return 128;\n          }\n          break;\n      }\n    }\n    unreachable(`AbstractFloats have not yet been implemented for ${ty.toString()}`);\n  }\n\n  if (ty instanceof MatrixType) {\n    switch (ty.cols) {\n      case 2:\n        switch (ty.rows) {\n          case 2:\n            return 16;\n          case 3:\n            return 32;\n          case 4:\n            return 32;\n        }\n        break;\n      case 3:\n        switch (ty.rows) {\n          case 2:\n            return 32;\n          case 3:\n            return 64;\n          case 4:\n            return 64;\n        }\n        break;\n      case 4:\n        switch (ty.rows) {\n          case 2:\n            return 32;\n          case 3:\n            return 64;\n          case 4:\n            return 64;\n        }\n        break;\n    }\n    unreachable(\n      `Attempted to get stride length for a matrix with dimensions (${ty.cols}x${ty.rows}), which isn't currently handled`\n    );\n  }\n\n  // Handles scalars and vectors\n  return 16;\n}\n\n// Helper for summing up all of the stride values for an array of Types\nfunction valueStrides(tys: Type[]): number {\n  return tys.map(valueStride).reduce((sum, c) => sum + c);\n}\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty: Type): Type {\n  if (ty instanceof ScalarType) {\n    assert(ty.kind !== 'f64', `No storage type defined for 'f64' values`);\n    assert(\n      ty.kind !== 'abstract-float',\n      `Custom handling is implemented for 'abstract-float' values`\n    );\n    if (ty.kind === 'bool') {\n      return TypeU32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return TypeVec(ty.width, storageType(ty.elementType) as ScalarType);\n  }\n  return ty;\n}\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    assert(ty.kind !== 'abstract-float', `AbstractFloat values should not be in input storage`);\n    assert(ty.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    assert(\n      ty.elementType.kind !== 'abstract-float',\n      `AbstractFloat values cannot appear in input storage`\n    );\n    assert(ty.elementType.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.elementType.kind === 'bool') {\n      return `${expr} != vec${ty.width}<u32>(0u)`;\n    }\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    assert(\n      ty.kind !== 'abstract-float',\n      `AbstractFloat values have custom code for writing to storage`\n    );\n    assert(ty.kind !== 'f64', `No storage type defined for 'f64' values`);\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    assert(\n      ty.elementType.kind !== 'abstract-float',\n      `AbstractFloat values have custom code for writing to storage`\n    );\n    assert(ty.elementType.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  return expr;\n}\n\n// A Pipeline is a map of WGSL shader source to a built pipeline\ntype PipelineCache = Map<String, GPUComputePipeline>;\n\n/**\n * Searches for an entry with the given key, adding and returning the result of calling\n * `create` if the entry was not found.\n * @param map the cache map\n * @param key the entry's key\n * @param create the function used to construct a value, if not found in the cache\n * @returns the value, either fetched from the cache, or newly built.\n */\nfunction getOrCreate<K, V>(map: Map<K, V>, key: K, create: () => V) {\n  const existing = map.get(key);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const value = create();\n  map.set(key, value);\n  return value;\n}\n\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder function\n * @param parameterTypes the list of expression parameter types\n * @param resultType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n * @param batch_size override the calculated casesPerBatch.\n */\nexport async function run(\n  t: GPUTest,\n  shaderBuilder: ShaderBuilder,\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cfg: Config = { inputSource: 'storage_r' },\n  cases: CaseList,\n  batch_size?: number\n) {\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, resultType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    resultType = packed.resultType;\n  }\n\n  // The size of the input buffer may exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits. We also split\n  // the cases into smaller batches to help with shader compilation performance.\n  const casesPerBatch = (function () {\n    if (batch_size) {\n      return batch_size;\n    }\n    switch (cfg.inputSource) {\n      case 'const':\n        // Some drivers are slow to optimize shaders with many constant values,\n        // or statements. 32 is an empirically picked number of cases that works\n        // well for most drivers.\n        return 32;\n      case 'uniform':\n        // Some drivers are slow to build pipelines with large uniform buffers.\n        // 2k appears to be a sweet-spot when benchmarking.\n        return Math.floor(\n          Math.min(1024 * 2, t.device.limits.maxUniformBufferBindingSize) /\n            valueStrides(parameterTypes)\n        );\n      case 'storage_r':\n      case 'storage_rw':\n        return Math.floor(\n          t.device.limits.maxStorageBufferBindingSize / valueStrides(parameterTypes)\n        );\n    }\n  })();\n\n  // A cache to hold built shader pipelines.\n  const pipelineCache = new Map<String, GPUComputePipeline>();\n\n  // Submit all the cases in batches, rate-limiting to ensure not too many\n  // batches are in flight simultaneously.\n  const maxBatchesInFlight = 5;\n  let batchesInFlight = 0;\n  let resolvePromiseBlockingBatch: (() => void) | undefined = undefined;\n  const batchFinishedCallback = () => {\n    batchesInFlight -= 1;\n    // If there is any batch waiting on a previous batch to finish,\n    // unblock it now, and clear the resolve callback.\n    if (resolvePromiseBlockingBatch) {\n      resolvePromiseBlockingBatch();\n      resolvePromiseBlockingBatch = undefined;\n    }\n  };\n\n  const processBatch = async (batchCases: CaseList) => {\n    const checkBatch = await submitBatch(\n      t,\n      shaderBuilder,\n      parameterTypes,\n      resultType,\n      batchCases,\n      cfg.inputSource,\n      pipelineCache\n    );\n    checkBatch();\n    void t.queue.onSubmittedWorkDone().finally(batchFinishedCallback);\n  };\n\n  const pendingBatches = [];\n\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n\n    if (batchesInFlight > maxBatchesInFlight) {\n      await new Promise<void>(resolve => {\n        // There should only be one batch waiting at a time.\n        assert(resolvePromiseBlockingBatch === undefined);\n        resolvePromiseBlockingBatch = resolve;\n      });\n    }\n    batchesInFlight += 1;\n\n    pendingBatches.push(processBatch(batchCases));\n  }\n\n  await Promise.all(pendingBatches);\n}\n\n/**\n * Submits the list of expression tests. The input data must fit within the\n * buffer binding limits of the given inputSource.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder function\n * @param parameterTypes the list of expression parameter types\n * @param resultType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param pipelineCache the cache of compute pipelines, shared between batches\n * @returns a function that checks the results are as expected\n */\nasync function submitBatch(\n  t: GPUTest,\n  shaderBuilder: ShaderBuilder,\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  pipelineCache: PipelineCache\n): Promise<() => void> {\n  // Construct a buffer to hold the results of the expression tests\n  const outputBufferSize = cases.length * valueStride(resultType);\n  const outputBuffer = t.device.createBuffer({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n\n  const [pipeline, group] = await buildPipeline(\n    t,\n    shaderBuilder,\n    parameterTypes,\n    resultType,\n    cases,\n    inputSource,\n    outputBuffer,\n    pipelineCache\n  );\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  // Heartbeat to ensure CTS runners know we're alive.\n  globalTestConfig.testHeartbeatCallback();\n\n  t.queue.submit([encoder.finish()]);\n\n  // Return a function that can check the results of the shader\n  return () => {\n    const checkExpectation = (outputData: Uint8Array) => {\n      // Read the outputs from the output buffer\n      const outputs = new Array<Value>(cases.length);\n      for (let i = 0; i < cases.length; i++) {\n        outputs[i] = resultType.read(outputData, i * valueStride(resultType));\n      }\n\n      // The list of expectation failures\n      const errs: string[] = [];\n\n      // For each case...\n      for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n        const c = cases[caseIdx];\n        const got = outputs[caseIdx];\n        const cmp = toComparator(c.expected).compare(got);\n        if (!cmp.matched) {\n          errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n        }\n      }\n\n      return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n    };\n\n    // Heartbeat to ensure CTS runners know we're alive.\n    globalTestConfig.testHeartbeatCallback();\n\n    t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n      type: Uint8Array,\n      typedLength: outputBufferSize,\n    });\n  };\n}\n\n/**\n * map is a helper for returning a new array with each element of `v`\n * transformed with `fn`.\n * If `v` is not an array, then `fn` is called with (v, 0).\n */\nfunction map<T, U>(v: T | readonly T[], fn: (value: T, index?: number) => U): U[] {\n  if (v instanceof Array) {\n    return v.map(fn);\n  }\n  return [fn(v, 0)];\n}\n\n/**\n * ShaderBuilder is a function used to construct the WGSL shader used by an\n * expression test.\n * @param parameterTypes the list of expression parameter types\n * @param resultType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n */\nexport type ShaderBuilder = (\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  inputSource: InputSource\n) => string;\n\n/**\n * Helper that returns the WGSL to declare the output storage buffer for a shader\n */\nfunction wgslOutputs(resultType: Type, count: number): string {\n  let output_struct = undefined;\n  if (scalarTypeOf(resultType).kind !== 'abstract-float') {\n    output_struct = `\nstruct Output {\n  @size(${valueStride(resultType)}) value : ${storageType(resultType)}\n};`;\n  } else {\n    if (resultType instanceof ScalarType) {\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n  @size(${valueStride(resultType)}) value: AF,\n};`;\n    }\n    if (resultType instanceof VectorType) {\n      const dim = resultType.width;\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n  @size(${valueStride(resultType)}) value: array<AF, ${dim}>,\n};`;\n    }\n\n    if (resultType instanceof MatrixType) {\n      const cols = resultType.cols;\n      const rows = resultType.rows === 2 ? 2 : 4; // 3 element rows have a padding element\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n   @size(${valueStride(resultType)}) value: array<array<AF, ${rows}>, ${cols}>,\n};`;\n    }\n\n    assert(output_struct !== undefined, `No implementation for result type '${resultType}'`);\n  }\n\n  return `${output_struct}\n@group(0) @binding(0) var<storage, read_write> outputs : array<Output, ${count}>;\n`;\n}\n\n/**\n * Helper that returns the WGSL to declare the values array for a shader\n */\nfunction wgslValuesArray(\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  expressionBuilder: ExpressionBuilder\n): string {\n  return `\nconst values = array(\n  ${cases.map(c => expressionBuilder(map(c.input, v => v.wgsl()))).join(',\\n  ')}\n);`;\n}\n\n/**\n * Helper that returns the WGSL 'var' declaration for the given input source\n */\nfunction wgslInputVar(inputSource: InputSource, count: number) {\n  switch (inputSource) {\n    case 'storage_r':\n      return `@group(0) @binding(1) var<storage, read> inputs : array<Input, ${count}>;`;\n    case 'storage_rw':\n      return `@group(0) @binding(1) var<storage, read_write> inputs : array<Input, ${count}>;`;\n    case 'uniform':\n      return `@group(0) @binding(1) var<uniform> inputs : array<Input, ${count}>;`;\n  }\n  throw new Error(`InputSource ${inputSource} does not use an input var`);\n}\n\n/**\n * Helper that returns the WGSL header before any other declaration, currently include f16\n * enable directive if necessary.\n */\nfunction wgslHeader(parameterTypes: Array<Type>, resultType: Type) {\n  const usedF16 =\n    scalarTypeOf(resultType).kind === 'f16' ||\n    parameterTypes.some((ty: Type) => scalarTypeOf(ty).kind === 'f16');\n  const header = usedF16 ? 'enable f16;\\n' : '';\n  return header;\n}\n\n/**\n * ExpressionBuilder returns the WGSL used to evaluate an expression with the\n * given input values.\n */\nexport type ExpressionBuilder = (values: ReadonlyArray<string>) => string;\n\n/**\n * Returns a ShaderBuilder that builds a basic expression test shader.\n * @param expressionBuilder the expression builder\n */\nfunction basicExpressionShaderBody(\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  inputSource: InputSource\n): string {\n  assert(\n    scalarTypeOf(resultType).kind !== 'abstract-float',\n    `abstractFloatShaderBuilder should be used when result type is 'abstract-float`\n  );\n  if (inputSource === 'const') {\n    //////////////////////////////////////////////////////////////////////////\n    // Constant eval\n    //////////////////////////////////////////////////////////////////////////\n    let body = '';\n    if (parameterTypes.some(ty => scalarTypeOf(ty).kind === 'abstract-float')) {\n      // Directly assign the expression to the output, to avoid an\n      // intermediate store, which will concretize the value early\n      body = cases\n        .map(\n          (c, i) =>\n            `  outputs[${i}].value = ${toStorage(\n              resultType,\n              expressionBuilder(map(c.input, v => v.wgsl()))\n            )};`\n        )\n        .join('\\n  ');\n    } else if (globalTestConfig.unrollConstEvalLoops) {\n      body = cases\n        .map((_, i) => {\n          const value = `values[${i}]`;\n          return `  outputs[${i}].value = ${toStorage(resultType, value)};`;\n        })\n        .join('\\n  ');\n    } else {\n      body = `\n  for (var i = 0u; i < ${cases.length}; i++) {\n    outputs[i].value = ${toStorage(resultType, `values[i]`)};\n  }`;\n    }\n\n    return `\n${wgslOutputs(resultType, cases.length)}\n\n${wgslValuesArray(parameterTypes, resultType, cases, expressionBuilder)}\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n  } else {\n    //////////////////////////////////////////////////////////////////////////\n    // Runtime eval\n    //////////////////////////////////////////////////////////////////////////\n\n    // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n    const paramExpr = (ty: Type, i: number) => fromStorage(ty, `inputs[i].param${i}`);\n\n    // resolves to the expression that calls the builtin\n    const expr = toStorage(resultType, expressionBuilder(parameterTypes.map(paramExpr)));\n\n    return `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${valueStride(ty)}) param${i} : ${storageType(ty)},`)\n  .join('\\n')}\n};\n\n${wgslOutputs(resultType, cases.length)}\n\n${wgslInputVar(inputSource, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n  for (var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n  }\n}\n\n/**\n * Returns a ShaderBuilder that builds a basic expression test shader.\n * @param expressionBuilder the expression builder\n */\nexport function basicExpressionBuilder(expressionBuilder: ExpressionBuilder): ShaderBuilder {\n  return (\n    parameterTypes: Array<Type>,\n    resultType: Type,\n    cases: CaseList,\n    inputSource: InputSource\n  ) => {\n    return `\\\n${wgslHeader(parameterTypes, resultType)}\n\n${basicExpressionShaderBody(expressionBuilder, parameterTypes, resultType, cases, inputSource)}`;\n  };\n}\n\n/**\n * Returns a ShaderBuilder that builds a basic expression test shader with given predeclaration\n * string goes after WGSL header (i.e. enable directives) if any but before anything else.\n * @param expressionBuilder the expression builder\n * @param predeclaration the predeclaration string\n */\nexport function basicExpressionWithPredeclarationBuilder(\n  expressionBuilder: ExpressionBuilder,\n  predeclaration: string\n): ShaderBuilder {\n  return (\n    parameterTypes: Array<Type>,\n    resultType: Type,\n    cases: CaseList,\n    inputSource: InputSource\n  ) => {\n    return `\\\n${wgslHeader(parameterTypes, resultType)}\n\n${predeclaration}\n\n${basicExpressionShaderBody(expressionBuilder, parameterTypes, resultType, cases, inputSource)}`;\n  };\n}\n\n/**\n * Returns a ShaderBuilder that builds a compound assignment operator test shader.\n * @param op the compound operator\n */\nexport function compoundAssignmentBuilder(op: string): ShaderBuilder {\n  return (\n    parameterTypes: Array<Type>,\n    resultType: Type,\n    cases: CaseList,\n    inputSource: InputSource\n  ) => {\n    //////////////////////////////////////////////////////////////////////////\n    // Input validation\n    //////////////////////////////////////////////////////////////////////////\n    if (parameterTypes.length !== 2) {\n      throw new Error(`compoundBinaryOp() requires exactly two parameters values per case`);\n    }\n    const lhsType = parameterTypes[0];\n    const rhsType = parameterTypes[1];\n    if (!objectEquals(lhsType, resultType)) {\n      throw new Error(\n        `compoundBinaryOp() requires result type (${resultType}) to be equal to the LHS type (${lhsType})`\n      );\n    }\n    if (inputSource === 'const') {\n      //////////////////////////////////////////////////////////////////////////\n      // Constant eval\n      //////////////////////////////////////////////////////////////////////////\n      let body = '';\n      if (globalTestConfig.unrollConstEvalLoops) {\n        body = cases\n          .map((_, i) => {\n            return `\n  var ret_${i} = lhs[${i}];\n  ret_${i} ${op} rhs[${i}];\n  outputs[${i}].value = ${storageType(resultType)}(ret_${i});`;\n          })\n          .join('\\n  ');\n      } else {\n        body = `\n  for (var i = 0u; i < ${cases.length}; i++) {\n    var ret = lhs[i];\n    ret ${op} rhs[i];\n    outputs[i].value = ${storageType(resultType)}(ret);\n  }`;\n      }\n\n      const values = cases.map(c => (c.input as Value[]).map(v => v.wgsl()));\n\n      return `\n${wgslHeader(parameterTypes, resultType)}\n${wgslOutputs(resultType, cases.length)}\n\nconst lhs = array(\n${values.map(c => `${c[0]}`).join(',\\n  ')}\n      );\nconst rhs = array(\n${values.map(c => `${c[1]}`).join(',\\n  ')}\n);\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n    } else {\n      //////////////////////////////////////////////////////////////////////////\n      // Runtime eval\n      //////////////////////////////////////////////////////////////////////////\n      return `\n${wgslHeader(parameterTypes, resultType)}\n${wgslOutputs(resultType, cases.length)}\n\nstruct Input {\n  @size(${valueStride(lhsType)}) lhs : ${storageType(lhsType)},\n  @size(${valueStride(rhsType)}) rhs : ${storageType(rhsType)},\n}\n\n${wgslInputVar(inputSource, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n  for (var i = 0; i < ${cases.length}; i++) {\n    var ret = ${lhsType}(inputs[i].lhs);\n    ret ${op} ${rhsType}(inputs[i].rhs);\n    outputs[i].value = ${storageType(resultType)}(ret);\n  }\n}\n`;\n    }\n  };\n}\n\n/**\n * @returns a string that extracts the value of an AbstractFloat into an output\n *          destination\n * @param expr expression for an AbstractFloat value, if working with vectors or\n *             matrices, this string needs to include indexing into the\n *             container.\n * @param case_idx index in the case output array to assign the result\n * @param accessor string representing how access to the AF that needs to be\n *                 operated on.\n *                 For scalars this should be left as ''.\n *                 For vectors this will be an indexing operation,\n *                 i.e. '[i]'\n *                 For matrices this will double indexing operation,\n *                 i.e. '[c][r]'\n */\nfunction abstractFloatSnippet(expr: string, case_idx: number, accessor: string = ''): string {\n  // AbstractFloats are f64s under the hood. WebGPU does not support\n  // putting f64s in buffers, so the result needs to be split up into u32s\n  // and rebuilt in the test framework.\n  //\n  // Since there is no 64-bit data type that can be used as an element for a\n  // vector or a matrix in WGSL, the testing framework needs to pass the u32s\n  // via a struct with two u32s, and deconstruct vectors and matrices into\n  // arrays.\n  //\n  // This is complicated by the fact that user defined functions cannot\n  // take/return AbstractFloats, and AbstractFloats cannot be stored in\n  // variables, so the code cannot just inject a simple utility function\n  // at the top of the shader, instead this snippet needs to be inlined\n  // everywhere the test needs to return an AbstractFloat.\n  //\n  // select is used below, since ifs are not available during constant\n  // eval. This has the side effect of short-circuiting doesn't occur, so\n  // both sides of the select have to evaluate and be valid.\n  //\n  // This snippet implements FTZ for subnormals to bypass the need for\n  // complex subnormal specific logic.\n  //\n  // Expressions resulting in subnormals can still be reasonably tested,\n  // since this snippet will return 0 with the correct sign, which is\n  // always in the acceptance interval for a subnormal result, since an\n  // implementation may FTZ.\n  //\n  // Documentation for the snippet working with scalar results is included here\n  // in this code block, since shader length affects compilation time\n  // significantly on some backends. The code for vectors and matrices basically\n  // the same thing, with extra indexing operations.\n  //\n  // Snippet with documentation:\n  //   const kExponentBias = 1022;\n  //\n  //   // Detect if the value is zero or subnormal, so that FTZ behaviour\n  //   // can occur\n  //   const subnormal_or_zero : bool = (${expr} <= ${kValue.f64.positive.subnormal.max}) && (${expr} >= ${kValue.f64.negative.subnormal.min});\n  //\n  //   // MSB of the upper u32 is 1 if the value is negative, otherwise 0\n  //   // Extract the sign bit early, so that abs() can be used with\n  //   // frexp() so negative cases do not need to be handled\n  //   const sign_bit : u32 = select(0, 0x80000000, ${expr} < 0);\n  //\n  //   // Use frexp() to obtain the exponent and fractional parts, and\n  //   // then perform FTZ if needed\n  //   const f = frexp(abs(${expr}));\n  //   const f_fract = select(f.fract, 0, subnormal_or_zero);\n  //   const f_exp = select(f.exp, -kExponentBias, subnormal_or_zero);\n  //\n  //   // Adjust for the exponent bias and shift for storing in bits\n  //   // [20..31] of the upper u32\n  //   const exponent_bits : u32 = (f_exp + kExponentBias) << 20;\n  //\n  //   // Extract the portion of the mantissa that appears in upper u32 as\n  //   // a float for later use\n  //   const high_mantissa = ldexp(f_fract, 21);\n  //\n  //   // Extract the portion of the mantissa that appears in upper u32 as\n  //   // as bits. This value is masked, because normals will explicitly\n  //   // have the implicit leading 1 that should not be in the final\n  //   // result.\n  //   const high_mantissa_bits : u32 = u32(ldexp(f_fract, 21)) & 0x000fffff;\n  //\n  //   // Calculate the mantissa stored in the lower u32 as a float\n  //   const low_mantissa = f_fract - ldexp(floor(high_mantissa), -21);\n  //\n  //   // Convert the lower u32 mantissa to bits\n  //   const low_mantissa_bits = u32(ldexp(low_mantissa, 53));\n  //\n  //   outputs[${i}].value.high = sign_bit | exponent_bits | high_mantissa_bits;\n  //   outputs[${i}].value.low = low_mantissa_bits;\n  // prettier-ignore\n  return `  {\n    const kExponentBias = 1022;\n    const subnormal_or_zero : bool = (${expr}${accessor} <= ${kValue.f64.positive.subnormal.max}) && (${expr}${accessor} >= ${kValue.f64.negative.subnormal.min});\n    const sign_bit : u32 = select(0, 0x80000000, ${expr}${accessor} < 0);\n    const f = frexp(abs(${expr}${accessor}));\n    const f_fract = select(f.fract, 0, subnormal_or_zero);\n    const f_exp = select(f.exp, -kExponentBias, subnormal_or_zero);\n    const exponent_bits : u32 = (f_exp + kExponentBias) << 20;\n    const high_mantissa = ldexp(f_fract, 21);\n    const high_mantissa_bits : u32 = u32(ldexp(f_fract, 21)) & 0x000fffff;\n    const low_mantissa = f_fract - ldexp(floor(high_mantissa), -21);\n    const low_mantissa_bits = u32(ldexp(low_mantissa, 53));\n    outputs[${case_idx}].value${accessor}.high = sign_bit | exponent_bits | high_mantissa_bits;\n    outputs[${case_idx}].value${accessor}.low = low_mantissa_bits;\n  }`;\n}\n\n/** @returns a string for a specific case that has a AbstractFloat result */\nfunction abstractFloatCaseBody(expr: string, resultType: Type, i: number): string {\n  if (resultType instanceof ScalarType) {\n    return abstractFloatSnippet(expr, i);\n  }\n\n  if (resultType instanceof VectorType) {\n    return [...Array(resultType.width).keys()]\n      .map(idx => abstractFloatSnippet(expr, i, `[${idx}]`))\n      .join('  \\n');\n  }\n\n  if (resultType instanceof MatrixType) {\n    const cols = resultType.cols;\n    const rows = resultType.rows;\n    const results: String[] = [...Array(cols * rows)];\n\n    for (let c = 0; c < cols; c++) {\n      for (let r = 0; r < rows; r++) {\n        results[c * rows + r] = abstractFloatSnippet(expr, i, `[${c}][${r}]`);\n      }\n    }\n\n    return results.join('  \\n');\n  }\n\n  unreachable(`Results of type '${resultType}' not yet implemented`);\n}\n\n/**\n * @returns a ShaderBuilder that builds a test shader hands AbstractFloat results.\n * @param expressionBuilder an expression builder that will return AbstractFloats\n */\nexport function abstractFloatShaderBuilder(expressionBuilder: ExpressionBuilder): ShaderBuilder {\n  return (\n    parameterTypes: Array<Type>,\n    resultType: Type,\n    cases: CaseList,\n    inputSource: InputSource\n  ) => {\n    assert(inputSource === 'const', 'AbstractFloat results are only defined for const-eval');\n    assert(\n      scalarTypeOf(resultType).kind === 'abstract-float',\n      `Expected resultType of 'abstract-float', received '${scalarTypeOf(resultType).kind}' instead`\n    );\n\n    const body = cases\n      .map((c, i) => {\n        const expr = `${expressionBuilder(map(c.input, v => v.wgsl()))}`;\n        return abstractFloatCaseBody(expr, resultType, i);\n      })\n      .join('\\n  ');\n\n    return `\n${wgslHeader(parameterTypes, resultType)}\n\n${wgslOutputs(resultType, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n  };\n}\n\n/**\n * Constructs and returns a GPUComputePipeline and GPUBindGroup for running a\n * batch of test cases. If a pre-created pipeline can be found in\n * `pipelineCache`, then this may be returned instead of creating a new\n * pipeline.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder\n * @param parameterTypes the list of expression parameter types\n * @param resultType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param outputBuffer the buffer that will hold the output values of the tests\n * @param pipelineCache the cache of compute pipelines, shared between batches\n */\nasync function buildPipeline(\n  t: GPUTest,\n  shaderBuilder: ShaderBuilder,\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  outputBuffer: GPUBuffer,\n  pipelineCache: PipelineCache\n): Promise<[GPUComputePipeline, GPUBindGroup]> {\n  cases.forEach(c => {\n    const inputTypes = c.input instanceof Array ? c.input.map(i => i.type) : [c.input.type];\n    if (!objectEquals(inputTypes, parameterTypes)) {\n      const input_str = `[${inputTypes.join(',')}]`;\n      const param_str = `[${parameterTypes.join(',')}]`;\n      throw new Error(\n        `case input types ${input_str} do not match provided runner parameter types ${param_str}`\n      );\n    }\n  });\n\n  const source = shaderBuilder(parameterTypes, resultType, cases, inputSource);\n\n  switch (inputSource) {\n    case 'const': {\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = await t.device.createComputePipelineAsync({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n      });\n\n      return [pipeline, group];\n    }\n\n    case 'uniform':\n    case 'storage_r':\n    case 'storage_rw': {\n      // Input values come from a uniform or storage buffer\n\n      // size in bytes of the input buffer\n      const inputSize = cases.length * valueStrides(parameterTypes);\n\n      // Holds all the parameter values for all cases\n      const inputData = new Uint8Array(inputSize);\n\n      // Pack all the input parameter values into the inputData buffer\n      {\n        const caseStride = valueStrides(parameterTypes);\n        for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n          const caseBase = caseIdx * caseStride;\n          let offset = caseBase;\n          for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n            const params = cases[caseIdx].input;\n            if (params instanceof Array) {\n              params[paramIdx].copyTo(inputData, offset);\n            } else {\n              params.copyTo(inputData, offset);\n            }\n            offset += valueStride(parameterTypes[paramIdx]);\n          }\n        }\n      }\n\n      // build the compute pipeline, if the shader hasn't been compiled already.\n      const pipeline = getOrCreate(pipelineCache, source, () => {\n        // build the shader module\n        const module = t.device.createShaderModule({ code: source });\n\n        // build the pipeline\n        return t.device.createComputePipeline({\n          layout: 'auto',\n          compute: { module, entryPoint: 'main' },\n        });\n      });\n\n      // build the input buffer\n      const inputBuffer = t.makeBufferWithContents(\n        inputData,\n        GPUBufferUsage.COPY_SRC |\n          (inputSource === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n      );\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: outputBuffer } },\n          { binding: 1, resource: { buffer: inputBuffer } },\n        ],\n      });\n\n      return [pipeline, group];\n    }\n  }\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nfunction packScalarsToVector(\n  parameterTypes: Array<Type>,\n  resultType: Type,\n  cases: CaseList,\n  vectorWidth: number\n): { cases: CaseList; parameterTypes: Array<Type>; resultType: Type } {\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(resultType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${resultType}'`\n    );\n  }\n\n  const packedCases: Array<Case> = [];\n  const packedParameterTypes = parameterTypes.map(p => TypeVec(vectorWidth, p as ScalarType));\n  const packedResultType = new VectorType(vectorWidth, resultType);\n\n  const clampCaseIdx = (idx: number) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array<Vector>(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array<Scalar>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = (input instanceof Array ? input[paramIdx] : input) as Scalar;\n      }\n      packedInputs[paramIdx] = new Vector(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const cmp_impls = new Array<ComparatorImpl>(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      cmp_impls[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected).compare;\n    }\n    const comparators: Comparator = {\n      compare: (got: Value) => {\n        let matched = true;\n        const gElements = new Array<string>(vectorWidth);\n        const eElements = new Array<string>(vectorWidth);\n        for (let i = 0; i < vectorWidth; i++) {\n          const d = cmp_impls[i]((got as Vector).elements[i]);\n          matched = matched && d.matched;\n          gElements[i] = d.got;\n          eElements[i] = d.expected;\n        }\n        return {\n          matched,\n          got: `${packedResultType}(${gElements.join(', ')})`,\n          expected: `${packedResultType}(${eElements.join(', ')})`,\n        };\n      },\n      kind: 'packed',\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: comparators });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    resultType: packedResultType,\n  };\n}\n\n/**\n * Indicates bounds that acceptance intervals need to be within to avoid inputs\n * being filtered out. This is used for const-eval tests, since going OOB will\n * cause a validation error not an execution error.\n */\nexport type IntervalFilter =\n  | 'finite' // Expected to be finite in the interval numeric space\n  | 'unfiltered'; // No expectations\n\n/**\n * A function that performs a binary operation on x and y, and returns the expected\n * result.\n */\nexport interface BinaryOp {\n  (x: number, y: number): number | undefined;\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n * @param quantize function to quantize all values\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarBinaryToScalarCases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case[] {\n  param0s = param0s.map(quantize);\n  param1s = param1s.map(quantize);\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [scalarize(e[0]), scalarize(e[1])], expected: scalarize(expected) });\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToU32Cases(\n  param0s: readonly number[],\n  param1s: readonly number[],\n  op: BinaryOp\n) {\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param scalar scalar param\n * @param vector vector param (2, 3, or 4 elements)\n * @param op the op to apply to scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeScalarVectorBinaryToVectorCase(\n  scalar: number,\n  vector: readonly number[],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case | undefined {\n  scalar = quantize(scalar);\n  vector = vector.map(quantize);\n  const result = vector.map(v => op(scalar, v));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [scalarize(scalar), new Vector(vector.map(scalarize))],\n    expected: new Vector((result as readonly number[]).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op the op to apply to each pair of scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarVectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case[] {\n  const cases = new Array<Case>();\n  scalars.forEach(s => {\n    vectors.forEach(v => {\n      const c = makeScalarVectorBinaryToVectorCase(s, v, op, quantize, scalarize);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param vector vector param (2, 3, or 4 elements)\n * @param scalar scalar param\n * @param op the op to apply to vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorScalarBinaryToVectorCase(\n  vector: readonly number[],\n  scalar: number,\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case | undefined {\n  vector = vector.map(quantize);\n  scalar = quantize(scalar);\n  const result = vector.map(v => op(v, scalar));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(vector.map(scalarize)), scalarize(scalar)],\n    expected: new Vector((result as readonly number[]).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op the op to apply to each pair of vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorScalarBinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case[] {\n  const cases = new Array<Case>();\n  scalars.forEach(s => {\n    vectors.forEach(v => {\n      const c = makeVectorScalarBinaryToVectorCase(v, s, op, quantize, scalarize);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateU32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorU32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI32VectorBinaryToVectorCases(\n  scalars: readonly number[],\n  vectors: ROArrayArray<number>,\n  op: BinaryOp\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI32BinaryToVectorCases(\n  vectors: ROArrayArray<number>,\n  scalars: readonly number[],\n  op: BinaryOp\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI32, i32);\n}\n"],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsG,oBAAoBA,CAACpH,IAAY,EAAEqH,QAAgB,EAAEC,QAAgB,GAAG,EAAE,EAAU;EAC3F;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,OAAQ;AACV;AACA,wCAAwCtH,IAAK,GAAEsH,QAAS,OAAM9J,MAAM,CAAC+J,GAAG,CAACC,QAAQ,CAACC,SAAS,CAACC,GAAI,SAAQ1H,IAAK,GAAEsH,QAAS,OAAM9J,MAAM,CAAC+J,GAAG,CAACI,QAAQ,CAACF,SAAS,CAAChG,GAAI;AAChK,mDAAmDzB,IAAK,GAAEsH,QAAS;AACnE,0BAA0BtH,IAAK,GAAEsH,QAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAcD,QAAS,UAASC,QAAS;AACzC,cAAcD,QAAS,UAASC,QAAS;AACzC,IAAI;AACJ;;AAEA;AACA,SAASM,qBAAqBA,CAAC5H,IAAY,EAAEc,UAAgB,EAAE8B,CAAS,EAAU;EAChF,IAAI9B,UAAU,YAAYrD,UAAU,EAAE;IACpC,OAAO2J,oBAAoB,CAACpH,IAAI,EAAE4C,CAAC,CAAC;EACtC;;EAEA,IAAI9B,UAAU,YAAYhD,UAAU,EAAE;IACpC,OAAO,CAAC,GAAGY,KAAK,CAACoC,UAAU,CAAC3B,KAAK,CAAC,CAAC0I,IAAI,CAAC,CAAC,CAAC;IACvCpI,GAAG,CAAC,CAAAqI,GAAG,KAAIV,oBAAoB,CAACpH,IAAI,EAAE4C,CAAC,EAAG,IAAGkF,GAAI,GAA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"}
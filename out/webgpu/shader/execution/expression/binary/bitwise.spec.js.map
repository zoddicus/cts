{"version":3,"file":"bitwise.spec.js","names":["description","makeTestGroup","assert","GPUTest","abstractIntBits","i32","i32Bits","scalarType","u32","u32Bits","allInputSources","onlyConstInputSource","run","abstractIntBinary","binary","compoundBinary","g","kScalarImpls","builder","bits","size","scalarImplForInputType","inputType","kBitwiseOrStaticPatterns","input","expected","makeBitwiseOrCases","impl","indices","Array","keys","map","BigInt","c","flatMap","i","lhs","j","rhs","result","test","specURL","desc","params","u","combine","undefined","fn","t","skipIf","type","includes","inputSource","cases","makeBitwiseAndCases","V","push","kBitwiseExclusiveOrStaticPatterns","makeBitwiseExclusiveOrCases"],"sources":["../../../../../../src/webgpu/shader/execution/expression/binary/bitwise.spec.ts"],"sourcesContent":["export const description = `\nExecution Tests for the bitwise binary expression operations\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport {\n  abstractIntBits,\n  i32,\n  i32Bits,\n  Scalar,\n  scalarType,\n  u32,\n  u32Bits,\n} from '../../../../util/conversion.js';\nimport { allInputSources, onlyConstInputSource, run } from '../expression.js';\n\nimport { abstractIntBinary, binary, compoundBinary } from './binary.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n/**\n * Collection of functions and values required to implement bitwise tests for a\n * specific scalar type\n */\ninterface ScalarImpl {\n  // builder is a mostly a wrapper around type builders like 'i32Bits' that\n  // handles the (number|bigint) type check.\n  builder: (bits: bigint | number) => Scalar;\n  size: 32 | 64;\n}\n\nconst kScalarImpls = {\n  i32: {\n    builder: (bits: bigint | number): Scalar => {\n      assert(typeof bits === 'number');\n      return i32Bits(bits);\n    },\n    size: 32,\n  } as ScalarImpl,\n  u32: {\n    builder: (bits: bigint | number): Scalar => {\n      assert(typeof bits === 'number');\n      return u32Bits(bits);\n    },\n    size: 32,\n  } as ScalarImpl,\n  'abstract-int': {\n    builder: (bits: bigint | number): Scalar => {\n      assert(typeof bits === 'bigint');\n      return abstractIntBits(bits);\n    },\n    size: 64,\n  } as ScalarImpl,\n};\n\n/** Wrapper for converting from input type strings to the appropriate implementation */\nfunction scalarImplForInputType(inputType: string): ScalarImpl {\n  assert(inputType === 'i32' || inputType === 'u32' || inputType === 'abstract-int');\n  return kScalarImpls[inputType];\n}\n\n/** Manually calculated bitwise-or cases used a check that the CTS test is correct */\nconst kBitwiseOrStaticPatterns = {\n  32: [\n    {\n      input: [0b00000000000000000000000000000000, 0b00000000000000000000000000000000],\n      expected: 0b00000000000000000000000000000000,\n    },\n    {\n      input: [0b11111111111111111111111111111111, 0b00000000000000000000000000000000],\n      expected: 0b11111111111111111111111111111111,\n    },\n    {\n      input: [0b00000000000000000000000000000000, 0b11111111111111111111111111111111],\n      expected: 0b11111111111111111111111111111111,\n    },\n    {\n      input: [0b11111111111111111111111111111111, 0b11111111111111111111111111111111],\n      expected: 0b11111111111111111111111111111111,\n    },\n    {\n      input: [0b10100100010010100100010010100100, 0b00000000000000000000000000000000],\n      expected: 0b10100100010010100100010010100100,\n    },\n    {\n      input: [0b00000000000000000000000000000000, 0b10100100010010100100010010100100],\n      expected: 0b10100100010010100100010010100100,\n    },\n    {\n      input: [0b01010010001001010010001001010010, 0b10100100010010100100010010100100],\n      expected: 0b11110110011011110110011011110110,\n    },\n  ],\n  64: [\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b0000000000000000000000000000000000000000000000000000000000000000n,\n    },\n    {\n      input: [\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b1111111111111111111111111111111111111111111111111111111111111111n,\n    },\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n      ],\n      expected: 0b1111111111111111111111111111111111111111111111111111111111111111n,\n    },\n    {\n      input: [\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n      ],\n      expected: 0b1111111111111111111111111111111111111111111111111111111111111111n,\n    },\n    {\n      input: [\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b1010010001001010010001001010010010100100010010100100010010100100n,\n    },\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n      ],\n      expected: 0b1010010001001010010001001010010010100100010010100100010010100100n,\n    },\n    {\n      input: [\n        0b0101001000100101001000100101001010100100010010100100010010100100n,\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n      ],\n      expected: 0b1111011001101111011001101111011010100100010010100100010010100100n,\n    },\n  ],\n};\n\n/** @returns a set of bitwise-or cases for the specific input type */\nfunction makeBitwiseOrCases(inputType: string) {\n  const impl = scalarImplForInputType(inputType);\n  const indices =\n    impl.size === 64 ? [...Array(impl.size).keys()].map(BigInt) : [...Array(impl.size).keys()];\n\n  return [\n    ...kBitwiseOrStaticPatterns[impl.size].map(c => {\n      return {\n        input: c.input.map(impl.builder),\n        expected: impl.builder(c.expected),\n      };\n    }),\n    // Permute all combinations of a single bit being set for the LHS and RHS\n    ...indices.flatMap(i => {\n      const lhs = typeof i === 'bigint' ? 1n << i : 1 << i;\n      return indices.map(j => {\n        const rhs = typeof j === 'bigint' ? 1n << j : 1 << j;\n        assert(typeof lhs === typeof rhs);\n        const result = typeof lhs === 'bigint' ? lhs | (rhs as bigint) : lhs | (rhs as number);\n        return { input: [impl.builder(lhs), impl.builder(rhs)], expected: impl.builder(result) };\n      });\n    }),\n  ];\n}\n\ng.test('bitwise_or')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 | e2: T\nT is i32, u32, abstractInt, vecN<i32>, vecN<u32>, or vecN<abstractInt>\n\nBitwise-or. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32', 'abstract-int'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    t.skipIf(\n      t.params.type === 'abstract-int' && !onlyConstInputSource.includes(t.params.inputSource)\n    );\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseOrCases(t.params.type);\n    const builder = t.params.type === 'abstract-int' ? abstractIntBinary('|') : binary('|');\n    await run(t, builder, [type, type], type, t.params, cases);\n  });\n\ng.test('bitwise_or_compound')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 |= e2: T\nT is i32, u32, vecN<i32>, or vecN<u32>\n\nBitwise-or. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseOrCases(t.params.type);\n\n    await run(t, compoundBinary('|='), [type, type], type, t.params, cases);\n  });\n\nfunction makeBitwiseAndCases(inputType: string) {\n  const V = inputType === 'i32' ? i32 : u32;\n  const cases = [\n    // Static patterns\n    {\n      input: [V(0b00000000000000000000000000000000), V(0b00000000000000000000000000000000)],\n      expected: V(0b00000000000000000000000000000000),\n    },\n    {\n      input: [V(0b11111111111111111111111111111111), V(0b00000000000000000000000000000000)],\n      expected: V(0b00000000000000000000000000000000),\n    },\n    {\n      input: [V(0b00000000000000000000000000000000), V(0b11111111111111111111111111111111)],\n      expected: V(0b00000000000000000000000000000000),\n    },\n    {\n      input: [V(0b11111111111111111111111111111111), V(0b11111111111111111111111111111111)],\n      expected: V(0b11111111111111111111111111111111),\n    },\n    {\n      input: [V(0b10100100010010100100010010100100), V(0b00000000000000000000000000000000)],\n      expected: V(0b00000000000000000000000000000000),\n    },\n    {\n      input: [V(0b10100100010010100100010010100100), V(0b11111111111111111111111111111111)],\n      expected: V(0b10100100010010100100010010100100),\n    },\n    {\n      input: [V(0b00000000000000000000000000000000), V(0b10100100010010100100010010100100)],\n      expected: V(0b00000000000000000000000000000000),\n    },\n    {\n      input: [V(0b11111111111111111111111111111111), V(0b10100100010010100100010010100100)],\n      expected: V(0b10100100010010100100010010100100),\n    },\n    {\n      input: [V(0b01010010001001010010001001010010), V(0b01011011101101011011101101011011)],\n      expected: V(0b01010010001001010010001001010010),\n    },\n  ];\n  // Permute all combinations of a single bit being set for the LHS and all but one bit set for the RHS\n  for (let i = 0; i < 32; i++) {\n    const lhs = 1 << i;\n    for (let j = 0; j < 32; j++) {\n      const rhs = 0xffffffff ^ (1 << j);\n      cases.push({\n        input: [V(lhs), V(rhs)],\n        expected: V(lhs & rhs),\n      });\n    }\n  }\n  return cases;\n}\n\ng.test('bitwise_and')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 & e2: T\nT is i32, u32, vecN<i32>, or vecN<u32>\n\nBitwise-and. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseAndCases(t.params.type);\n    await run(t, binary('&'), [type, type], type, t.params, cases);\n  });\n\ng.test('bitwise_and_compound')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 &= e2: T\nT is i32, u32, vecN<i32>, or vecN<u32>\n\nBitwise-and. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseAndCases(t.params.type);\n    await run(t, compoundBinary('&='), [type, type], type, t.params, cases);\n  });\n\n/** Manually calculated bitwise-or cases used a check that the CTS test is correct */\nconst kBitwiseExclusiveOrStaticPatterns = {\n  32: [\n    {\n      input: [0b00000000000000000000000000000000, 0b00000000000000000000000000000000],\n      expected: 0b00000000000000000000000000000000,\n    },\n    {\n      input: [0b11111111111111111111111111111111, 0b00000000000000000000000000000000],\n      expected: 0b11111111111111111111111111111111,\n    },\n    {\n      input: [0b00000000000000000000000000000000, 0b11111111111111111111111111111111],\n      expected: 0b11111111111111111111111111111111,\n    },\n    {\n      input: [0b11111111111111111111111111111111, 0b11111111111111111111111111111111],\n      expected: 0b00000000000000000000000000000000,\n    },\n    {\n      input: [0b10100100010010100100010010100100, 0b00000000000000000000000000000000],\n      expected: 0b10100100010010100100010010100100,\n    },\n    {\n      input: [0b10100100010010100100010010100100, 0b11111111111111111111111111111111],\n      expected: 0b01011011101101011011101101011011,\n    },\n    {\n      input: [0b00000000000000000000000000000000, 0b10100100010010100100010010100100],\n      expected: 0b10100100010010100100010010100100,\n    },\n    {\n      input: [0b11111111111111111111111111111111, 0b10100100010010100100010010100100],\n      expected: 0b01011011101101011011101101011011,\n    },\n    {\n      input: [0b01010010001001010010001001010010, 0b01011011101101011011101101011011],\n      expected: 0b00001001100100001001100100001001,\n    },\n  ],\n  64: [\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b0000000000000000000000000000000000000000000000000000000000000000n,\n    },\n    {\n      input: [\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b1111111111111111111111111111111111111111111111111111111111111111n,\n    },\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n      ],\n      expected: 0b1111111111111111111111111111111111111111111111111111111111111111n,\n    },\n    {\n      input: [\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n      ],\n      expected: 0b0000000000000000000000000000000000000000000000000000000000000000n,\n    },\n    {\n      input: [\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n      expected: 0b1010010001001010010001001010010010100100010010100100010010100100n,\n    },\n    {\n      input: [\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n      ],\n      expected: 0b0101101110110101101110110101101101011011101101011011101101011011n,\n    },\n    {\n      input: [\n        0b0000000000000000000000000000000000000000000000000000000000000000n,\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n      ],\n      expected: 0b1010010001001010010001001010010010100100010010100100010010100100n,\n    },\n    {\n      input: [\n        0b1111111111111111111111111111111111111111111111111111111111111111n,\n        0b1010010001001010010001001010010010100100010010100100010010100100n,\n      ],\n      expected: 0b0101101110110101101110110101101101011011101101011011101101011011n,\n    },\n    {\n      input: [\n        0b0101001000100101001000100101001001010010001001010010001001010010n,\n        0b0101101110110101101110110101101101011011101101011011101101011011n,\n      ],\n      expected: 0b0000100110010000100110010000100100001001100100001001100100001001n,\n    },\n  ],\n};\n\n/** @returns a set of bitwise-xor cases for the specific input type */\nfunction makeBitwiseExclusiveOrCases(inputType: string) {\n  const impl = scalarImplForInputType(inputType);\n  const indices =\n    impl.size === 64 ? [...Array(impl.size).keys()].map(BigInt) : [...Array(impl.size).keys()];\n\n  return [\n    ...kBitwiseExclusiveOrStaticPatterns[impl.size].map(c => {\n      return {\n        input: c.input.map(impl.builder),\n        expected: impl.builder(c.expected),\n      };\n    }),\n    // Permute all combinations of a single bit being set for the LHS and all but one bit set for the RHS\n    ...indices.flatMap(i => {\n      const lhs = typeof i === 'bigint' ? 1n << i : 1 << i;\n      return indices.map(j => {\n        const rhs = typeof j === 'bigint' ? 0xffffffffffffffffn ^ (1n << j) : 0xffffffff ^ (1 << j);\n        assert(typeof lhs === typeof rhs);\n        const result = typeof lhs === 'bigint' ? lhs ^ (rhs as bigint) : lhs ^ (rhs as number);\n        return { input: [impl.builder(lhs), impl.builder(rhs)], expected: impl.builder(result) };\n      });\n    }),\n  ];\n}\n\ng.test('bitwise_exclusive_or')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 ^ e2: T\nT is i32, u32, abstractInt, vecN<i32>, vecN<u32>, or vecN<abstractInt>\n\nBitwise-exclusive-or. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32', 'abstract-int'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    t.skipIf(\n      t.params.type === 'abstract-int' && !onlyConstInputSource.includes(t.params.inputSource)\n    );\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseExclusiveOrCases(t.params.type);\n    const builder = t.params.type === 'abstract-int' ? abstractIntBinary('^') : binary('^');\n    await run(t, builder, [type, type], type, t.params, cases);\n  });\n\ng.test('bitwise_exclusive_or_compound')\n  .specURL('https://www.w3.org/TR/WGSL/#bit-expr')\n  .desc(\n    `\ne1 ^= e2: T\nT is i32, u32, vecN<i32>, or vecN<u32>\n\nBitwise-exclusive-or. Component-wise when T is a vector.\n`\n  )\n  .params(u =>\n    u\n      .combine('type', ['i32', 'u32'] as const)\n      .combine('inputSource', allInputSources)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n  )\n  .fn(async t => {\n    const type = scalarType(t.params.type);\n    const cases = makeBitwiseExclusiveOrCases(t.params.type);\n    await run(t, compoundBinary('^='), [type, type], type, t.params, cases);\n  });\n"],"mappings":"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"}
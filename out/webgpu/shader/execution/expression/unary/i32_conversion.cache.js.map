{"version":3,"file":"i32_conversion.cache.js","names":["kValue","abstractFloat","abstractInt","bool","f16","f32","i32","u32","fullI32Range","fullI64Range","fullU32Range","quantizeToF16","quantizeToF32","scalarF16Range","scalarF32Range","scalarF64Range","reinterpretU32AsI32","makeCaseCache","d","input","expected","filter","a","negative","min","positive","max","map","i","Number","u","f","Math","abs","trunc"],"sources":["../../../../../../src/webgpu/shader/execution/expression/unary/i32_conversion.cache.ts"],"sourcesContent":["import { kValue } from '../../../../util/constants.js';\nimport {\n  abstractFloat,\n  abstractInt,\n  bool,\n  f16,\n  f32,\n  i32,\n  u32,\n} from '../../../../util/conversion.js';\nimport {\n  fullI32Range,\n  fullI64Range,\n  fullU32Range,\n  quantizeToF16,\n  quantizeToF32,\n  scalarF16Range,\n  scalarF32Range,\n  scalarF64Range,\n} from '../../../../util/math.js';\nimport { reinterpretU32AsI32 } from '../../../../util/reinterpret.js';\nimport { makeCaseCache } from '../case_cache.js';\n\nexport const d = makeCaseCache('unary/i32_conversion', {\n  bool: () => {\n    return [\n      { input: bool(true), expected: i32(1) },\n      { input: bool(false), expected: i32(0) },\n    ];\n  },\n  abstractInt: () => {\n    return fullI64Range()\n      .filter(a => a >= kValue.i32.negative.min && a <= kValue.i32.positive.max)\n      .map(i => {\n        return { input: abstractInt(i), expected: i32(Number(i)) };\n      });\n  },\n  u32: () => {\n    return fullU32Range().map(u => {\n      return { input: u32(u), expected: i32(reinterpretU32AsI32(u)) };\n    });\n  },\n  i32: () => {\n    return fullI32Range().map(i => {\n      return { input: i32(i), expected: i32(i) };\n    });\n  },\n  abstractFloat: () => {\n    return scalarF64Range().map(f => {\n      // Handles zeros and subnormals\n      if (Math.abs(f) < 1.0) {\n        return { input: abstractFloat(f), expected: i32(0) };\n      }\n\n      if (f <= kValue.i32.negative.min) {\n        return { input: abstractFloat(f), expected: i32(kValue.i32.negative.min) };\n      }\n\n      if (f >= kValue.i32.positive.max) {\n        return { input: abstractFloat(f), expected: i32(kValue.i32.positive.max) };\n      }\n\n      // All i32s are representable as f64, and both AbstractFloat and number\n      // are f64 internally, so there is no need for special casing like f32 and\n      // f16 below.\n      return { input: abstractFloat(f), expected: i32(Math.trunc(f)) };\n    });\n  },\n  f32: () => {\n    return scalarF32Range().map(f => {\n      // Handles zeros and subnormals\n      if (Math.abs(f) < 1.0) {\n        return { input: f32(f), expected: i32(0) };\n      }\n\n      if (f <= kValue.i32.negative.min) {\n        return { input: f32(f), expected: i32(kValue.i32.negative.min) };\n      }\n\n      if (f >= kValue.i32.positive.max) {\n        return { input: f32(f), expected: i32(kValue.i32.positive.max) };\n      }\n\n      // All f32 no larger than 2^24 has a precise interger part and a fractional part, just need\n      // to trunc towards 0 for the result integer.\n      if (Math.abs(f) <= 2 ** 24) {\n        return { input: f32(f), expected: i32(Math.trunc(f)) };\n      }\n\n      // All f32s between 2 ** 24 and kValue.i32.negative.min/.positive.max are\n      // integers, so in theory one could use them directly, expect that number\n      // is actually f64 internally, so they need to be quantized to f32 first.\n      // Cannot just use trunc here, since that might produce a i32 value that\n      // is precise in f64, but not in f32.\n      return { input: f32(f), expected: i32(quantizeToF32(f)) };\n    });\n  },\n  f16: () => {\n    // Note that finite f16 values are always in range of i32.\n    return scalarF16Range().map(f => {\n      // Handles zeros and subnormals\n      if (Math.abs(f) < 1.0) {\n        return { input: f16(f), expected: i32(0) };\n      }\n\n      // All f16 no larger than <= 2^12 has a precise interger part and a fractional part, just need\n      // to trunc towards 0 for the result integer.\n      if (Math.abs(f) <= 2 ** 12) {\n        return { input: f16(f), expected: i32(Math.trunc(f)) };\n      }\n\n      // All f16s larger than 2 ** 12 are integers, so in theory one could use them directly, expect\n      // that number is actually f64 internally, so they need to be quantized to f16 first.\n      // Cannot just use trunc here, since that might produce a i32 value that is precise in f64,\n      // but not in f16.\n      return { input: f16(f), expected: i32(quantizeToF16(f)) };\n    });\n  },\n});\n"],"mappings":"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"}
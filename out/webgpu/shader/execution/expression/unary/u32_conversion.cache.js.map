{"version":3,"file":"u32_conversion.cache.js","names":["kValue","bool","f16","f32","i32","u32","fullI32Range","fullU32Range","quantizeToF16","quantizeToF32","scalarF16Range","scalarF32Range","reinterpretI32AsU32","makeCaseCache","d","input","expected","map","u","i","f","max","Math","floor","trunc"],"sources":["../../../../../../src/webgpu/shader/execution/expression/unary/u32_conversion.cache.ts"],"sourcesContent":["import { kValue } from '../../../../util/constants.js';\nimport { bool, f16, f32, i32, u32 } from '../../../../util/conversion.js';\nimport {\n  fullI32Range,\n  fullU32Range,\n  quantizeToF16,\n  quantizeToF32,\n  scalarF16Range,\n  scalarF32Range,\n} from '../../../../util/math.js';\nimport { reinterpretI32AsU32 } from '../../../../util/reinterpret.js';\nimport { makeCaseCache } from '../case_cache.js';\n\nexport const d = makeCaseCache('unary/u32_conversion', {\n  bool: () => {\n    return [\n      { input: bool(true), expected: u32(1) },\n      { input: bool(false), expected: u32(0) },\n    ];\n  },\n  u32: () => {\n    return fullU32Range().map(u => {\n      return { input: u32(u), expected: u32(u) };\n    });\n  },\n  i32: () => {\n    return fullI32Range().map(i => {\n      return { input: i32(i), expected: u32(reinterpretI32AsU32(i)) };\n    });\n  },\n  f32: () => {\n    return scalarF32Range().map(f => {\n      // Handles zeros, subnormals, and negatives\n      if (f < 1.0) {\n        return { input: f32(f), expected: u32(0) };\n      }\n\n      if (f >= kValue.u32.max) {\n        return { input: f32(f), expected: u32(kValue.u32.max) };\n      }\n\n      // All f32 no larger than 2^24 has a precise interger part and a fractional part, just need\n      // to trunc towards 0 for the result integer.\n      if (f <= 2 ** 24) {\n        return { input: f32(f), expected: u32(Math.floor(f)) };\n      }\n\n      // All f32s between 2 ** 24 and kValue.u32.max are integers, so in theory\n      // one could use them directly, expect that number is actually f64\n      // internally, so they need to be quantized to f32 first.\n      // Cannot just use floor here, since that might produce a u32 value that\n      // is precise in f64, but not in f32.\n      return { input: f32(f), expected: u32(quantizeToF32(f)) };\n    });\n  },\n  f16: () => {\n    // Note that all positive finite f16 values are in range of u32.\n    return scalarF16Range().map(f => {\n      // Handles zeros, subnormals, and negatives\n      if (f < 1.0) {\n        return { input: f16(f), expected: u32(0) };\n      }\n\n      // All f16 no larger than <= 2^12 has a precise interger part and a fractional part, just need\n      // to trunc towards 0 for the result integer.\n      if (f <= 2 ** 12) {\n        return { input: f16(f), expected: u32(Math.trunc(f)) };\n      }\n\n      // All f16s larger than 2 ** 12 are integers, so in theory one could use them directly, expect\n      // that number is actually f64 internally, so they need to be quantized to f16 first.\n      // Cannot just use trunc here, since that might produce a u32 value that is precise in f64,\n      // but not in f16.\n      return { input: f16(f), expected: u32(quantizeToF16(f)) };\n    });\n  },\n});\n"],"mappings":"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"}
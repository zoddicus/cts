{"version":3,"file":"f16_conversion.cache.js","names":["bool","f16","i32","u32","FP","FPInterval","fullI32Range","fullU32Range","scalarF16Range","scalarF32Range","sparseMatrixF16Range","sparseMatrixF32Range","makeCaseCache","f16FiniteRangeInterval","constants","negative","min","positive","max","f32_mat_cases","flatMap","cols","rows","map","nonConst","f32","generateMatrixToMatrixCases","correctlyRoundedMatrix","reduce","a","b","f16_mat_cases","d","input","expected","u32_non_const","u","correctlyRoundedInterval","u32_const","filter","v","contains","i32_non_const","i","i32_const","f32_non_const","generateScalarToIntervalCases","f32_const","f"],"sources":["../../../../../../src/webgpu/shader/execution/expression/unary/f16_conversion.cache.ts"],"sourcesContent":["import { bool, f16, i32, u32 } from '../../../../util/conversion.js';\nimport { FP, FPInterval } from '../../../../util/floating_point.js';\nimport {\n  fullI32Range,\n  fullU32Range,\n  scalarF16Range,\n  scalarF32Range,\n  sparseMatrixF16Range,\n  sparseMatrixF32Range,\n} from '../../../../util/math.js';\nimport { makeCaseCache } from '../case_cache.js';\n\nconst f16FiniteRangeInterval = new FPInterval(\n  'f32',\n  FP.f16.constants().negative.min,\n  FP.f16.constants().positive.max\n);\n\n// Cases: f32_matCxR_[non_]const\n// Note that f32 values may be not exactly representable in f16 and/or out of range.\nconst f32_mat_cases = ([2, 3, 4] as const)\n  .flatMap(cols =>\n    ([2, 3, 4] as const).flatMap(rows =>\n      ([true, false] as const).map(nonConst => ({\n        [`f32_mat${cols}x${rows}_${nonConst ? 'non_const' : 'const'}`]: () => {\n          return FP.f32.generateMatrixToMatrixCases(\n            sparseMatrixF32Range(cols, rows),\n            nonConst ? 'unfiltered' : 'finite',\n            FP.f16.correctlyRoundedMatrix\n          );\n        },\n      }))\n    )\n  )\n  .reduce((a, b) => ({ ...a, ...b }), {});\n\n// Cases: f16_matCxR_[non_]const\nconst f16_mat_cases = ([2, 3, 4] as const)\n  .flatMap(cols =>\n    ([2, 3, 4] as const).flatMap(rows =>\n      ([true, false] as const).map(nonConst => ({\n        [`f16_mat${cols}x${rows}_${nonConst ? 'non_const' : 'const'}`]: () => {\n          // Input matrix is of f16 types, use f16.generateMatrixToMatrixCases.\n          return FP.f16.generateMatrixToMatrixCases(\n            sparseMatrixF16Range(cols, rows),\n            nonConst ? 'unfiltered' : 'finite',\n            FP.f16.correctlyRoundedMatrix\n          );\n        },\n      }))\n    )\n  )\n  .reduce((a, b) => ({ ...a, ...b }), {});\n\nexport const d = makeCaseCache('unary/f16_conversion', {\n  bool: () => {\n    return [\n      { input: bool(true), expected: f16(1.0) },\n      { input: bool(false), expected: f16(0.0) },\n    ];\n  },\n  u32_non_const: () => {\n    return [...fullU32Range(), 65504].map(u => {\n      return { input: u32(u), expected: FP.f16.correctlyRoundedInterval(u) };\n    });\n  },\n  u32_const: () => {\n    return [...fullU32Range(), 65504]\n      .filter(v => f16FiniteRangeInterval.contains(v))\n      .map(u => {\n        return { input: u32(u), expected: FP.f16.correctlyRoundedInterval(u) };\n      });\n  },\n  i32_non_const: () => {\n    return [...fullI32Range(), 65504, -65504].map(i => {\n      return { input: i32(i), expected: FP.f16.correctlyRoundedInterval(i) };\n    });\n  },\n  i32_const: () => {\n    return [...fullI32Range(), 65504, -65504]\n      .filter(v => f16FiniteRangeInterval.contains(v))\n      .map(i => {\n        return { input: i32(i), expected: FP.f16.correctlyRoundedInterval(i) };\n      });\n  },\n  // Note that f32 values may be not exactly representable in f16 and/or out of range.\n  f32_non_const: () => {\n    return FP.f32.generateScalarToIntervalCases(\n      [...scalarF32Range(), 65535.996, -65535.996],\n      'unfiltered',\n      FP.f16.correctlyRoundedInterval\n    );\n  },\n  f32_const: () => {\n    return FP.f32.generateScalarToIntervalCases(\n      [...scalarF32Range(), 65535.996, -65535.996],\n      'finite',\n      FP.f16.correctlyRoundedInterval\n    );\n  },\n  // All f16 values are exactly representable in f16.\n  f16: () => {\n    return scalarF16Range().map(f => {\n      return { input: f16(f), expected: FP.f16.correctlyRoundedInterval(f) };\n    });\n  },\n  ...f32_mat_cases,\n  ...f16_mat_cases,\n});\n"],"mappings":"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"}
{"version":3,"file":"utils.js","names":["assert","unreachable","virtualMipSize","isBoundaryNegative","boundary","endsWith","generateCoordBoundaries","numDimensions","ret","Error","name","i","j","k","push","getMipLevelFromLevelSpec","mipLevelCount","levelSpec","isLevelSpecNegative","getCoordForSize","size","coord","map","v","Math","floor","axis","axisIndex","charCodeAt","axisSize","location","substring","getNumDimensions","dimension","getCoordinateForBoundaries","texture","mipLevel","slice","generateOffsets","undefined","val"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/utils.ts"],"sourcesContent":["import { assert, unreachable } from '../../../../../../common/util/util.js';\nimport { virtualMipSize } from '../../../../../util/texture/base.js';\n\n/* Valid types of Boundaries */\nexport type Boundary =\n  | 'in-bounds'\n  | 'x-min-wrap'\n  | 'x-min-boundary'\n  | 'x-max-wrap'\n  | 'x-max-boundary'\n  | 'y-min-wrap'\n  | 'y-min-boundary'\n  | 'y-max-wrap'\n  | 'y-max-boundary'\n  | 'z-min-wrap'\n  | 'z-min-boundary'\n  | 'z-max-wrap'\n  | 'z-max-boundary';\n\nexport function isBoundaryNegative(boundary: Boundary) {\n  return boundary.endsWith('min-wrap');\n}\n\n/**\n * Generates the boundary entries for the given number of dimensions\n *\n * @param numDimensions: The number of dimensions to generate for\n * @returns an array of generated coord boundaries\n */\nexport function generateCoordBoundaries(numDimensions: number): Boundary[] {\n  const ret: Boundary[] = ['in-bounds'];\n\n  if (numDimensions < 1 || numDimensions > 3) {\n    throw new Error(`invalid numDimensions: ${numDimensions}`);\n  }\n\n  const name = 'xyz';\n  for (let i = 0; i < numDimensions; ++i) {\n    for (const j of ['min', 'max']) {\n      for (const k of ['wrap', 'boundary']) {\n        ret.push(`${name[i]}-${j}-${k}` as Boundary);\n      }\n    }\n  }\n\n  return ret;\n}\n\nexport type LevelSpec = -1 | 0 | 'numLevels-1' | 'numLevels';\n\nexport function getMipLevelFromLevelSpec(mipLevelCount: number, levelSpec: LevelSpec): number {\n  switch (levelSpec) {\n    case -1:\n      return -1;\n    case 0:\n      return 0;\n    case 'numLevels':\n      return mipLevelCount;\n    case 'numLevels-1':\n      return mipLevelCount - 1;\n    default:\n      unreachable();\n  }\n}\n\nexport function isLevelSpecNegative(levelSpec: LevelSpec) {\n  return levelSpec === -1;\n}\n\nfunction getCoordForSize(size: [number, number, number], boundary: Boundary) {\n  const coord = size.map(v => Math.floor(v / 2));\n  switch (boundary) {\n    case 'in-bounds':\n      break;\n    default: {\n      const axis = boundary[0];\n      const axisIndex = axis.charCodeAt(0) - 'x'.charCodeAt(0);\n      const axisSize = size[axisIndex];\n      const location = boundary.substring(2);\n      let v = 0;\n      switch (location) {\n        case 'min-wrap':\n          v = -1;\n          break;\n        case 'min-boundary':\n          v = 0;\n          break;\n        case 'max-wrap':\n          v = axisSize;\n          break;\n        case 'max-boundary':\n          v = axisSize - 1;\n          break;\n        default:\n          unreachable();\n      }\n      coord[axisIndex] = v;\n    }\n  }\n  return coord;\n}\n\nfunction getNumDimensions(dimension: GPUTextureDimension) {\n  switch (dimension) {\n    case '1d':\n      return 1;\n    case '2d':\n      return 2;\n    case '3d':\n      return 3;\n  }\n}\n\nexport function getCoordinateForBoundaries<T>(\n  texture: GPUTexture,\n  mipLevel: number,\n  boundary: Boundary\n) {\n  const size = virtualMipSize(texture.dimension, texture, mipLevel);\n  const coord = getCoordForSize(size, boundary);\n  return coord.slice(0, getNumDimensions(texture.dimension)) as T;\n}\n\n/**\n * Generates a set of offset values to attempt in the range [-8, 7].\n *\n * @param numDimensions: The number of dimensions to generate for\n * @return an array of generated offset values\n */\nexport function generateOffsets(numDimensions: number) {\n  assert(numDimensions >= 2 && numDimensions <= 3);\n  const ret: Array<undefined | Array<number>> = [undefined];\n  for (const val of [-8, 0, 1, 7]) {\n    const v = [];\n    for (let i = 0; i < numDimensions; ++i) {\n      v.push(val);\n    }\n    ret.push(v);\n  }\n  return ret;\n}\n"],"mappings":"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"}
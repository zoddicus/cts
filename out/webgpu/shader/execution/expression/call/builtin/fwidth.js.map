{"version":3,"file":"fwidth.js","names":["anyOf","Type","toComparator","runFWidthTest","t","cases","builtin","non_uniform_discard","vectorize","vectorWidth","undefined","valueStride","wgslType","code","module","device","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","writeMask","bufferSize","length","inputBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","mappedAtCreation","outputBuffer","COPY_SRC","valuesData","Uint8Array","getMappedRange","i","v","index","inputs","input","x","copyTo","unmap","group","createBindGroup","entries","binding","resource","buffer","getBindGroupLayout","colorAttachment","createTexture","width","height","GPUTextureUsage","RENDER_ATTACHMENT","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setBindGroup","quad","draw","end","queue","submit","finish","expectGPUBufferValuesPassCheck","outputData","c","result","f32","read","expected","endsWith","cmp","compare","matched","Error","join","type","typedLength"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/fwidth.ts"],"sourcesContent":["import { GPUTest } from '../../../../../gpu_test.js';\nimport { anyOf } from '../../../../../util/compare.js';\nimport { Type, Value } from '../../../../../util/conversion.js';\nimport { FPInterval } from '../../../../../util/floating_point.js';\nimport { Case } from '../../case.js';\nimport { toComparator } from '../../expectation.js';\n\n/**\n * Run a test for a fwidth builtin function.\n * @param t the GPUTest\n * @param cases list of test cases to run\n * @param builtin the builtin function to test\n * @param non_uniform_discard if true, one of each pair of invocations will discard\n * @param vectorize if defined, the vector width to use (2, 3, or 4)\n */\nexport function runFWidthTest(\n  t: GPUTest,\n  cases: Case[],\n  builtin: string,\n  non_uniform_discard: boolean,\n  vectorize?: number\n) {\n  ////////////////////////////////////////////////////////////////\n  // The four input values for a given case are distributed to across the invocations in a quad.\n  // We will populate a storage buffer with these input values laid out sequentially:\n  // [ case0_input0, case0_input1, case0_input2, case0_input3, ...]\n  //\n  // The render pipeline will be launched several times over a viewport size of (2, 2). Each draw\n  // call will execute a single quad (four fragment invocation), which will exercise one test case.\n  // Each of these draw calls will use a different instance index, which is forwarded to the\n  // fragment shader. Each invocation will determine its index into the storage buffer using its\n  // fragment position and the instance index for that draw call.\n  //\n  // Consider two draw calls that test 2 cases (c0, c1).\n  //\n  // The mapping from fragment position to case input is:\n  // Quad 0: | c0_i0 | c0_i1 |     Quad 1: | c1_i0 | c1_i1 |\n  //         | c0_i2 | c0_i3 |             | c1_i2 | c1_i3 |\n  //\n  ////////////////////////////////////////////////////////////////\n\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  let vectorWidth = 1;\n  if (vectorize !== undefined) {\n    vectorWidth = vectorize;\n  }\n\n  // Determine the WGSL type to use in the shader, and the stride in bytes between values.\n  let valueStride = 4;\n  let wgslType = 'f32';\n  if (vectorize) {\n    wgslType = `vec${vectorize}f`;\n    valueStride = vectorize * 4;\n    if (vectorize === 3) {\n      valueStride = 16;\n    }\n  }\n\n  // Define a vertex shader that draws a triangle over the full viewport, and a fragment shader that\n  // calls the fwidth builtin with a value loaded from that fragment's index into the storage\n  // buffer (determined using the quad index and fragment position, as described above).\n  const code = `\nstruct CaseInfo {\n  @builtin(position) position: vec4f,\n  @location(0) @interpolate(flat) quad_idx: u32,\n}\n\n@vertex\nfn vert(@builtin(vertex_index) vertex_idx: u32,\n        @builtin(instance_index) instance_idx: u32) -> CaseInfo {\n  const kVertices = array(\n    vec2f(-2, -2),\n    vec2f( 2, -2),\n    vec2f( 0,  2),\n  );\n  return CaseInfo(vec4(kVertices[vertex_idx], 0, 1), instance_idx);\n}\n\n@group(0) @binding(0) var<storage, read> inputs : array<${wgslType}>;\n@group(0) @binding(1) var<storage, read_write> outputs : array<${wgslType}>;\n\n@fragment\nfn frag(info : CaseInfo) {\n  let inv_idx = u32(info.position.x) + u32(info.position.y)*2;\n  let index = info.quad_idx*4 + inv_idx;\n  let input = inputs[index];\n  ${non_uniform_discard ? 'if inv_idx == 0 { discard; }' : ''}\n  outputs[index] = ${builtin}(input);\n}\n`;\n\n  // Create the render pipeline.\n  const module = t.device.createShaderModule({ code });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    fragment: { module, targets: [{ format: 'rgba8unorm', writeMask: 0 }] },\n  });\n\n  // Create storage buffers to hold the inputs and outputs.\n  const bufferSize = cases.length * 4 * valueStride;\n  const inputBuffer = t.device.createBuffer({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE,\n    mappedAtCreation: true,\n  });\n  const outputBuffer = t.device.createBuffer({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  // Populate the input storage buffer with case input values.\n  const valuesData = new Uint8Array(inputBuffer.getMappedRange());\n  for (let i = 0; i < cases.length / vectorWidth; i++) {\n    for (let v = 0; v < vectorWidth; v++) {\n      const index = i * vectorWidth + v;\n      if (index >= cases.length) {\n        break;\n      }\n      const inputs = cases[index].input as ReadonlyArray<Value>;\n      for (let x = 0; x < 4; x++) {\n        inputs[x].copyTo(valuesData, (i * 4 + x) * valueStride + v * 4);\n      }\n    }\n  }\n  inputBuffer.unmap();\n\n  // Create a bind group for the storage buffers.\n  const group = t.device.createBindGroup({\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n    layout: pipeline.getBindGroupLayout(0),\n  });\n\n  // Create a texture to use as a color attachment.\n  // We only need this for launching the desired number of fragment invocations.\n  const colorAttachment = t.device.createTexture({\n    size: { width: 2, height: 2 },\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  // Submit the render pass to the device.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginRenderPass({\n    colorAttachments: [\n      {\n        view: colorAttachment.createView(),\n        loadOp: 'clear',\n        storeOp: 'discard',\n      },\n    ],\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  for (let quad = 0; quad < cases.length / vectorWidth; quad++) {\n    pass.draw(3, 1, undefined, quad);\n  }\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  // Check the outputs match the expected results.\n  t.expectGPUBufferValuesPassCheck(\n    outputBuffer,\n    (outputData: Uint8Array) => {\n      for (let i = 0; i < cases.length / vectorWidth; i++) {\n        for (let v = 0; v < vectorWidth; v++) {\n          const index = i * vectorWidth + v;\n          if (index >= cases.length) {\n            break;\n          }\n          const c = cases[index];\n\n          for (let x = 0; x < 4; x++) {\n            if (non_uniform_discard && x === 0) {\n              continue;\n            }\n\n            const index = (i * 4 + x) * valueStride + v * 4;\n            const result = Type.f32.read(outputData, index);\n\n            let expected = c.expected;\n            if (builtin.endsWith('Fine')) {\n              expected = toComparator((expected as FPInterval[])[x]);\n            } else {\n              expected = anyOf(...(expected as FPInterval[]));\n            }\n\n            const cmp = expected.compare(result);\n            if (!cmp.matched) {\n              return new Error(`\n    inputs: (${(c.input as Value[]).join(', ')})\n  expected: ${cmp.expected}\n\n  returned: ${result}`);\n            }\n          }\n        }\n      }\n      return undefined;\n    },\n    {\n      type: Uint8Array,\n      typedLength: bufferSize,\n    }\n  );\n}\n"],"mappings":"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"}
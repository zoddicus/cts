{"version":3,"file":"textureGather.spec.js","names":["description","makeTestGroup","isDepthTextureFormat","isEncodableTextureFormat","kCompressedTextureFormats","kDepthStencilFormats","kEncodableTextureFormats","appendComponentTypeForFormatToTextureType","checkCallResults","chooseTextureSize","createTextureWithRandomDataAndGetTexels","doTextureCalls","generateSamplePointsCube","generateTextureBuiltinInputs2D","isFillable","kCubeSamplePointMethods","kSamplePointMethods","kShortAddressModes","kShortAddressModeToAddressMode","kShortShaderStages","skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice","WGSLTextureSampleTest","kTestableColorFormats","g","test","specURL","desc","params","u","combine","filter","t","format","beginSubcases","beforeAllSubcases","skipIfTextureFormatNotSupported","filt","fn","C","samplePoints","stage","modeU","modeV","minFilter","offset","width","height","minSize","minBlocks","descriptor","size","mipLevelCount","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","texture","sampler","addressModeU","addressModeV","magFilter","mipmapFilter","calls","method","textureBuiltin","component","hashInputs","map","coords","builtin","coordType","componentType","textureType","viewDescriptor","results","res","expectOK","mode","viewDimension","depthOrArrayLayers","isCompatibility","textureBindingViewDimension","addressModeW","dimension","A","arrayIndex","num","type","arrayIndexType","skipIfTextureViewDimensionNotSupported"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureGather.spec.ts"],"sourcesContent":["export const description = `\nExecution tests for the 'textureGather' builtin function\n\n- TODO: Test un-encodable formats.\n\nA texture gather operation reads from a 2D, 2D array, cube, or cube array texture, computing a four-component vector as follows:\n * Find the four texels that would be used in a sampling operation with linear filtering, from mip level 0:\n   - Use the specified coordinate, array index (when present), and offset (when present).\n   - The texels are adjacent, forming a square, when considering their texture space coordinates (u,v).\n   - Selected texels at the texture edge, cube face edge, or cube corners are handled as in ordinary texture sampling.\n * For each texel, read one channel and convert it into a scalar value.\n   - For non-depth textures, a zero-based component parameter specifies the channel to use.\n     * If the texture format supports the specified channel, i.e. has more than component channels:\n       - Yield scalar value v[component] when the texel value is v.\n     * Otherwise:\n       - Yield 0.0 when component is 1 or 2.\n       - Yield 1.0 when component is 3 (the alpha channel).\n   - For depth textures, yield the texel value. (Depth textures only have one channel.)\n * Yield the four-component vector, arranging scalars produced by the previous step into components according to the relative coordinates of the texels, as follows:\n   - Result component  Relative texel coordinate\n      x (umin,vmax)\n      y (umax,vmax)\n      z (umax,vmin)\n      w (umin,vmin)\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport {\n  isDepthTextureFormat,\n  isEncodableTextureFormat,\n  kCompressedTextureFormats,\n  kDepthStencilFormats,\n  kEncodableTextureFormats,\n} from '../../../../../format_info.js';\n\nimport {\n  appendComponentTypeForFormatToTextureType,\n  checkCallResults,\n  chooseTextureSize,\n  createTextureWithRandomDataAndGetTexels,\n  doTextureCalls,\n  generateSamplePointsCube,\n  generateTextureBuiltinInputs2D,\n  isFillable,\n  kCubeSamplePointMethods,\n  kSamplePointMethods,\n  kShortAddressModes,\n  kShortAddressModeToAddressMode,\n  kShortShaderStages,\n  skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice,\n  TextureCall,\n  vec2,\n  vec3,\n  WGSLTextureSampleTest,\n} from './texture_utils.js';\n\nconst kTestableColorFormats = [...kEncodableTextureFormats, ...kCompressedTextureFormats] as const;\n\nexport const g = makeTestGroup(WGSLTextureSampleTest);\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nC: i32, u32\nT: i32, u32, f32\n\nfn textureGather(component: C, t: texture_2d<T>, s: sampler, coords: vec2<f32>) -> vec4<T>\nfn textureGather(component: C, t: texture_2d<T>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<T>\n\nParameters:\n * component:\n    - The index of the channel to read from the selected texels.\n    - When provided, the component expression must a creation-time expression (e.g. 1).\n    - Its value must be at least 0 and at most 3. Values outside of this range will result in a shader-creation error.\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(t, t.params.filt, t.params.format);\n  })\n  .fn(async t => {\n    const { format, C, samplePoints, stage, modeU, modeV, filt: minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGather',\n      sampler,\n      descriptor,\n      offset,\n      component: true,\n      hashInputs: [stage, format, C, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, component, offset }) => {\n      return {\n        builtin: 'textureGather',\n        coordType: 'f',\n        coords,\n        component,\n        componentType: C === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nT: i32, u32, f32\n\nfn textureGather(component: C, t: texture_cube<T>, s: sampler, coords: vec3<f32>) -> vec4<T>\n\nParameters:\n * component:\n    - The index of the channel to read from the selected texels.\n    - When provided, the component expression must a creation-time expression (e.g. 1).\n    - Its value must be at least 0 and at most 3. Values outside of this range will result in a shader-creation error.\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('samplePoints', kCubeSamplePointMethods)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(t, t.params.filt, t.params.format);\n  })\n  .fn(async t => {\n    const { format, C, stage, samplePoints, mode, filt: minFilter } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube';\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = 6;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      component: true,\n      textureBuiltin: 'textureGather',\n      hashInputs: [stage, format, C, samplePoints, mode, minFilter],\n    }).map(({ coords, component }) => {\n      return {\n        builtin: 'textureGather',\n        component,\n        componentType: C === 'i32' ? 'i' : 'u',\n        coordType: 'f',\n        coords,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = appendComponentTypeForFormatToTextureType('texture_cube', format);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nC: i32, u32\nT: i32, u32, f32\n\nfn textureGather(component: C, t: texture_2d_array<T>, s: sampler, coords: vec2<f32>, array_index: C) -> vec4<T>\nfn textureGather(component: C, t: texture_2d_array<T>, s: sampler, coords: vec2<f32>, array_index: C, offset: vec2<i32>) -> vec4<T>\n\nParameters:\n * component:\n    - The index of the channel to read from the selected texels.\n    - When provided, the component expression must a creation-time expression (e.g. 1).\n    - Its value must be at least 0 and at most 3. Values outside of this range will result in a shader-creation error.\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(t, t.params.filt, t.params.format);\n  })\n  .fn(async t => {\n    const { format, stage, samplePoints, C, A, modeU, modeV, filt: minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGather',\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      component: true,\n      hashInputs: [stage, format, samplePoints, C, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, component, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureGather',\n        component,\n        componentType: C === 'i32' ? 'i' : 'u',\n        coordType: 'f',\n        coords,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d_array', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nC: i32, u32\nT: i32, u32, f32\nA: i32, u32\n\nfn textureGather(component: C, t: texture_cube_array<T>, s: sampler, coords: vec3<f32>, array_index: A) -> vec4<T>\n\nParameters:\n * component:\n    - The index of the channel to read from the selected texels.\n    - When provided, the component expression must a creation-time expression (e.g. 1).\n    - Its value must be at least 0 and at most 3. Values outside of this range will result in a shader-creation error.\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kTestableColorFormats)\n      .filter(t => isFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n    skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(t, t.params.filt, t.params.format);\n  })\n  .fn(async t => {\n    const { format, C, A, stage, samplePoints, mode, filt: minFilter } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      component: true,\n      textureBuiltin: 'textureGather',\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [stage, format, C, samplePoints, mode, minFilter],\n    }).map(({ coords, component, arrayIndex }) => {\n      return {\n        builtin: 'textureGather',\n        component,\n        componentType: C === 'i32' ? 'i' : 'u',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        coordType: 'f',\n        coords,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = appendComponentTypeForFormatToTextureType('texture_cube_array', format);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nfn textureGather(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureGather(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, modeU, modeV, filt: minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGather',\n      sampler,\n      descriptor,\n      offset,\n      hashInputs: [stage, format, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, offset }) => {\n      return {\n        builtin: 'textureGather',\n        coordType: 'f',\n        coords,\n        offset,\n      };\n    });\n    const textureType = 'texture_depth_2d';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nfn textureGather(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, mode, filt: minFilter } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube';\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = 6;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      textureBuiltin: 'textureGather',\n      hashInputs: [stage, format, samplePoints, mode, minFilter],\n    }).map(({ coords, component }) => {\n      return {\n        builtin: 'textureGather',\n        coordType: 'f',\n        coords,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = 'texture_depth_cube';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nA: i32, u32\n\nfn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>\nfn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(t, t.params.filt, t.params.format);\n  })\n  .fn(async t => {\n    const { format, stage, samplePoints, A, modeU, modeV, filt: minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGather',\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      hashInputs: [stage, format, samplePoints, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureGather',\n        coordType: 'f',\n        coords,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = 'texture_depth_2d_array';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegather')\n  .desc(\n    `\nA: i32, u32\n\nfn textureGather(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n  })\n  .fn(async t => {\n    const { format, A, stage, samplePoints, mode, filt: minFilter } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      textureBuiltin: 'textureGather',\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [stage, format, samplePoints, mode, minFilter],\n    }).map(({ coords, arrayIndex }) => {\n      return {\n        builtin: 'textureGather',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        coordType: 'f',\n        coords,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = 'texture_depth_cube_array';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n"],"mappings":"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"}
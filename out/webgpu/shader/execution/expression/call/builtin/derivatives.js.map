{"version":3,"file":"derivatives.js","names":["Type","toComparator","packScalarsToVector","runDerivativeTest","t","cases","builtin","non_uniform_discard","vectorize","type","f32","undefined","packed","resultType","dir","valueStride","wgslType","code","module","device","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","writeMask","bufferSize","length","inputBuffer","createBufferTracked","size","usage","GPUBufferUsage","STORAGE","mappedAtCreation","outputBuffer","COPY_SRC","valuesData","Uint8Array","getMappedRange","i","inputs","input","copyTo","unmap","group","createBindGroup","entries","binding","resource","buffer","getBindGroupLayout","colorAttachment","createTextureTracked","width","height","GPUTextureUsage","RENDER_ATTACHMENT","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setBindGroup","quad","draw","end","queue","submit","finish","expectGPUBufferValuesPassCheck","outputData","c","d","index","result","read","cmp","expected","compare","matched","endsWith","c0","cmp0","Error","join","typedLength"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/derivatives.ts"],"sourcesContent":["import { GPUTest } from '../../../../../gpu_test.js';\nimport { Type, Value } from '../../../../../util/conversion.js';\nimport { Case } from '../../case.js';\nimport { toComparator } from '../../expectation.js';\nimport { packScalarsToVector } from '../../expression.js';\n\n/**\n * Run a test for a derivative builtin function.\n * @param t the GPUTest\n * @param cases list of test cases to run\n * @param builtin the builtin function to test\n * @param non_uniform_discard if true, one of each pair of invocations will discard\n * @param vectorize if defined, the vector width to use (2, 3, or 4)\n */\nexport function runDerivativeTest(\n  t: GPUTest,\n  cases: Case[],\n  builtin: string,\n  non_uniform_discard: boolean,\n  vectorize?: number\n) {\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  let type: Type = Type.f32;\n  if (vectorize !== undefined) {\n    const packed = packScalarsToVector([type, type], type, cases, vectorize);\n    cases = packed.cases;\n    type = packed.resultType;\n  }\n\n  ////////////////////////////////////////////////////////////////\n  // The two input values for a given case are distributed to two different invocations in a quad.\n  // We will populate a storage buffer with these input values laid out sequentially:\n  // [ case_0_input_1, case_0_input_0, case_1_input_1, case_1_input_0, ...]\n  //\n  // The render pipeline will be launched several times over a viewport size of (2, 2). Each draw\n  // call will execute a single quad (four fragment invocation), which will exercise two test cases.\n  // Each of these draw calls will use a different instance index, which is forwarded to the\n  // fragment shader. Each invocation will determine its index into the storage buffer using its\n  // fragment position and the instance index for that draw call.\n  //\n  // Consider two draw calls that test 4 cases (c_0, c_1, c_2, c_3).\n  //\n  // For derivatives along the 'x' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_0_i_0 |     Quad 1: | c_2_i_1 | c_2_i_0 |\n  //         | c_1_i_1 | c_1_i_0 |             | c_3_i_1 | c_3_i_0 |\n  //\n  // For derivatives along the 'y' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_1_i_1 |     Quad 1: | c_2_i_1 | c_3_i_1 |\n  //         | c_0_i_0 | c_1_i_0 |             | c_2_i_0 | c_3_i_0 |\n  //\n  ////////////////////////////////////////////////////////////////\n\n  // Determine the direction of the derivative ('x' or 'y') from the builtin name.\n  const dir = builtin[3];\n\n  // Determine the WGSL type to use in the shader, and the stride in bytes between values.\n  let valueStride = 4;\n  let wgslType = 'f32';\n  if (vectorize) {\n    wgslType = `vec${vectorize}f`;\n    valueStride = vectorize * 4;\n    if (vectorize === 3) {\n      valueStride = 16;\n    }\n  }\n\n  // Define a vertex shader that draws a triangle over the full viewport, and a fragment shader that\n  // calls the derivative builtin with a value loaded from that fragment's index into the storage\n  // buffer (determined using the quad index and fragment position, as described above).\n  const code = `\nstruct CaseInfo {\n  @builtin(position) position: vec4f,\n  @location(0) @interpolate(flat, either) quad_idx: u32,\n}\n\n@vertex\nfn vert(@builtin(vertex_index) vertex_idx: u32,\n        @builtin(instance_index) instance_idx: u32) -> CaseInfo {\n  const kVertices = array(\n    vec2f(-2, -2),\n    vec2f( 2, -2),\n    vec2f( 0,  2),\n  );\n  return CaseInfo(vec4(kVertices[vertex_idx], 0, 1), instance_idx);\n}\n\n@group(0) @binding(0) var<storage, read> inputs : array<${wgslType}>;\n@group(0) @binding(1) var<storage, read_write> outputs : array<${wgslType}>;\n\n@fragment\nfn frag(info : CaseInfo) {\n  let case_idx = u32(info.position.${dir === 'x' ? 'y' : 'x'});\n  let inv_idx = u32(info.position.${dir});\n  let index = info.quad_idx*4 + case_idx*2 + inv_idx;\n  let input = inputs[index];\n  ${non_uniform_discard ? 'if inv_idx == 0 { discard; }' : ''}\n  outputs[index] = ${builtin}(input);\n}\n`;\n\n  // Create the render pipeline.\n  const module = t.device.createShaderModule({ code });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    fragment: { module, targets: [{ format: 'rgba8unorm', writeMask: 0 }] },\n  });\n\n  // Create storage buffers to hold the inputs and outputs.\n  const bufferSize = cases.length * 2 * valueStride;\n  const inputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE,\n    mappedAtCreation: true,\n  });\n  const outputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  // Populate the input storage buffer with case input values.\n  const valuesData = new Uint8Array(inputBuffer.getMappedRange());\n  for (let i = 0; i < cases.length; i++) {\n    const inputs = cases[i].input as ReadonlyArray<Value>;\n    inputs[0].copyTo(valuesData, (i * 2 + 1) * valueStride);\n    inputs[1].copyTo(valuesData, i * 2 * valueStride);\n  }\n  inputBuffer.unmap();\n\n  // Create a bind group for the storage buffers.\n  const group = t.device.createBindGroup({\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n    layout: pipeline.getBindGroupLayout(0),\n  });\n\n  // Create a texture to use as a color attachment.\n  // We only need this for launching the desired number of fragment invocations.\n  const colorAttachment = t.createTextureTracked({\n    size: { width: 2, height: 2 },\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  // Submit the render pass to the device.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginRenderPass({\n    colorAttachments: [\n      {\n        view: colorAttachment.createView(),\n        loadOp: 'clear',\n        storeOp: 'discard',\n      },\n    ],\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  for (let quad = 0; quad < cases.length / 2; quad++) {\n    pass.draw(3, 1, undefined, quad);\n  }\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  // Check the outputs match the expected results.\n  t.expectGPUBufferValuesPassCheck(\n    outputBuffer,\n    (outputData: Uint8Array) => {\n      for (let i = 0; i < cases.length; i++) {\n        const c = cases[i];\n\n        // Both invocations involved in the derivative should get the same result.\n        for (let d = 0; d < 2; d++) {\n          if (non_uniform_discard && d === 0) {\n            continue;\n          }\n\n          const index = (i * 2 + d) * valueStride;\n          const result = type.read(outputData, index);\n          const cmp = toComparator(c.expected).compare(result);\n          if (!cmp.matched) {\n            // If this is a coarse derivative, the implementation is also allowed to calculate only\n            // one of the two derivatives and return that result to all of the invocations.\n            if (!builtin.endsWith('Fine')) {\n              const c0 = cases[i % 2 === 0 ? i + 1 : i - 1];\n              const cmp0 = toComparator(c0.expected).compare(result);\n              if (!cmp0.matched) {\n                return new Error(`\n  1st pair: (${(c.input as Value[]).join(', ')})\n  expected: ${cmp.expected}\n\n  2nd pair: (${(c0.input as Value[]).join(', ')})\n  expected: ${cmp0.expected}\n\n  returned: ${result}`);\n              }\n            } else {\n              return new Error(`\n    inputs: (${(c.input as Value[]).join(', ')})\n  expected: ${cmp.expected}\n\n  returned: ${result}`);\n            }\n          }\n        }\n      }\n      return undefined;\n    },\n    {\n      type: Uint8Array,\n      typedLength: bufferSize,\n    }\n  );\n}\n"],"mappings":"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"}
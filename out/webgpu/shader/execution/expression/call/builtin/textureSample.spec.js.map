{"version":3,"file":"textureSample.spec.js","names":["description","makeTestGroup","unreachable","isCompressedTextureFormat","kCompressedTextureFormats","kEncodableTextureFormats","kTextureFormatInfo","GPUTest","TextureTestMixin","hashU32","putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer","generateSamplePoints2D","generateSamplePoints3D","kSamplePointMethods","doTextureCalls","checkCallResults","createTextureWithRandomDataAndGetTexels","generateSamplePointsCube","kCubeSamplePointMethods","chooseTextureSize","generateCoordBoundaries","generateOffsets","kTestableColorFormats","getDepthOrArrayLayersForViewDimension","viewDimension","getTextureTypeForTextureViewDimension","g","test","specURL","desc","paramsSubcasesOnly","u","combine","unimplemented","params","filter","t","type","format","color","canPotentialFilter","isFillable","endsWith","beginSubcases","beforeAllSubcases","skipIfTextureFormatNotSupported","info","selectDeviceOrSkipTestCase","selectDeviceForTextureFormatOrSkipTestCase","fn","sample_points","addressModeU","addressModeV","minFilter","offset","width","height","minSize","minBlocks","descriptor","size","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","texture","calls","method","textureWidth","textureHeight","map","c","i","hash","builtin","coordType","coords","undefined","sampler","magFilter","viewDescriptor","results","res","expectOK","combineWithParams","ddx","ddy","uvwStart","mipmapFilter","mipLevelCount","depthOrArrayLayers","dimension","isCompatibility","textureBindingViewDimension","textureDepthOrArrayLayers","textureType"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSample.spec.ts"],"sourcesContent":["export const description = `\nSamples a texture.\n\nnote: uniformity validation is covered in src/webgpu/shader/validation/uniformity/uniformity.spec.ts\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../../../common/util/util.js';\nimport {\n  isCompressedTextureFormat,\n  kCompressedTextureFormats,\n  kEncodableTextureFormats,\n  kTextureFormatInfo,\n} from '../../../../../format_info.js';\nimport { GPUTest, TextureTestMixin } from '../../../../../gpu_test.js';\nimport { hashU32 } from '../../../../../util/math.js';\n\nimport {\n  vec2,\n  vec3,\n  TextureCall,\n  putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer,\n  generateSamplePoints2D,\n  generateSamplePoints3D,\n  kSamplePointMethods,\n  doTextureCalls,\n  checkCallResults,\n  createTextureWithRandomDataAndGetTexels,\n  generateSamplePointsCube,\n  kCubeSamplePointMethods,\n  SamplePointMethods,\n  chooseTextureSize,\n} from './texture_utils.js';\nimport { generateCoordBoundaries, generateOffsets } from './utils.js';\n\nconst kTestableColorFormats = [...kEncodableTextureFormats, ...kCompressedTextureFormats] as const;\n\nfunction getDepthOrArrayLayersForViewDimension(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '2d':\n      return 1;\n    case '3d':\n      return 8;\n    case 'cube':\n      return 6;\n    default:\n      unreachable();\n  }\n}\n\nfunction getTextureTypeForTextureViewDimension(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '2d':\n      return 'texture_2d<f32>';\n    case '3d':\n      return 'texture_3d<f32>';\n    case 'cube':\n      return 'texture_cube<f32>';\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('sampled_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(1))\n  )\n  .unimplemented();\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kTestableColorFormats)\n      .filter(t => {\n        const type = kTextureFormatInfo[t.format].color?.type;\n        const canPotentialFilter = type === 'float' || type === 'unfilterable-float';\n        // We can't easily put random bytes into compressed textures if they are float formats\n        // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n        const isFillable = !isCompressedTextureFormat(t.format) || !t.format.endsWith('float');\n        return canPotentialFilter && isFillable;\n      })\n      .combine('sample_points', kSamplePointMethods)\n      .beginSubcases()\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = kTextureFormatInfo[format];\n    if (info.color?.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    } else {\n      t.selectDeviceForTextureFormatOrSkipTestCase(t.params.format);\n    }\n  })\n  .fn(async t => {\n    const { format, sample_points, addressModeU, addressModeV, minFilter, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n\n    const calls: TextureCall<vec2>[] = generateSamplePoints2D(50, minFilter === 'nearest', {\n      method: sample_points,\n      textureWidth: texture.width,\n      textureHeight: texture.height,\n    }).map((c, i) => {\n      const hash = hashU32(i);\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords: c,\n        offset: offset ? [(hash & 0xf) - 8, ((hash >> 4) & 0xf) - 8] : undefined,\n      };\n    });\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU,\n      addressModeV,\n      minFilter,\n      magFilter: minFilter,\n    };\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      'texture_2d<f32>',\n      sampler,\n      calls\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      'texture_2d<f32>',\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords,derivatives')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\ntest mip level selection based on derivatives\n    `\n  )\n  .params(u =>\n    u\n      .combine('format', kTestableColorFormats)\n      .filter(t => {\n        const type = kTextureFormatInfo[t.format].color?.type;\n        const canPotentialFilter = type === 'float' || type === 'unfilterable-float';\n        // We can't easily put random bytes into compressed textures if they are float formats\n        // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n        const isFillable = !isCompressedTextureFormat(t.format) || !t.format.endsWith('float');\n        return canPotentialFilter && isFillable;\n      })\n      .combine('mipmapFilter', ['nearest', 'linear'] as const)\n      .beginSubcases()\n      // note: this is the derivative we want at sample time. It is not the value\n      // passed directly to the shader. This way if we change the texture size\n      // or render target size we can compute the correct values to achieve the\n      // same results.\n      .combineWithParams([\n        { ddx: 0.5, ddy: 0.5 }, // test mag filter\n        { ddx: 1, ddy: 1 }, // test level 0\n        { ddx: 2, ddy: 1 }, // test level 1 via ddx\n        { ddx: 1, ddy: 4 }, // test level 2 via ddy\n        { ddx: 1.5, ddy: 1.5 }, // test mix between 1 and 2\n        { ddx: 6, ddy: 6 }, // test mix between 2 and 3 (there is no 3 so we should get just 2)\n        { ddx: 1.5, ddy: 1.5, offset: [7, -8] as const }, // test mix between 1 and 2 with offset\n        { ddx: 1.5, ddy: 1.5, offset: [3, -3] as const }, // test mix between 1 and 2 with offset\n        { ddx: 1.5, ddy: 1.5, uvwStart: [-3.5, -4] as const }, // test mix between 1 and 2 with negative coords\n      ])\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = kTextureFormatInfo[format];\n    if (info.color?.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    } else {\n      t.selectDeviceForTextureFormatOrSkipTestCase(t.params.format);\n    }\n  })\n  .fn(async t => {\n    const { format, mipmapFilter, ddx, ddy, uvwStart, offset } = t.params;\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      mipLevelCount: 3,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: 'repeat',\n      addressModeV: 'repeat',\n      minFilter: 'linear',\n      magFilter: 'linear',\n      mipmapFilter,\n    };\n    const viewDescriptor = {};\n    await putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer(\n      t,\n      descriptor,\n      viewDescriptor,\n      sampler,\n      { ddx, ddy, uvwStart, offset }\n    );\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>\nfn textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n\n* TODO: test 3d compressed textures formats. Just remove the filter below 'viewDimension'\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kTestableColorFormats)\n      .filter(t => {\n        const type = kTextureFormatInfo[t.format].color?.type;\n        const canPotentialFilter = type === 'float' || type === 'unfilterable-float';\n        // We can't easily put random bytes into compressed textures if they are float formats\n        // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n        const isFillable = !isCompressedTextureFormat(t.format) || !t.format.endsWith('float');\n        return canPotentialFilter && isFillable;\n      })\n      .combine('viewDimension', ['3d', 'cube'] as const)\n      .filter(t => !isCompressedTextureFormat(t.format) || t.viewDimension === 'cube')\n      .combine('sample_points', kCubeSamplePointMethods)\n      .filter(t => t.sample_points !== 'cube-edges' || t.viewDimension !== '3d')\n      .beginSubcases()\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeW', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.viewDimension !== 'cube' || t.offset !== true)\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = kTextureFormatInfo[format];\n    if (info.color?.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    } else {\n      t.selectDeviceForTextureFormatOrSkipTestCase(t.params.format);\n    }\n  })\n  .fn(async t => {\n    const { format, viewDimension, sample_points, addressModeU, addressModeV, minFilter, offset } =\n      t.params;\n\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateSamplePoints3D(50, minFilter === 'nearest', {\n            method: sample_points as SamplePointMethods,\n            textureWidth: texture.width,\n            textureHeight: texture.height,\n            textureDepthOrArrayLayers: texture.depthOrArrayLayers,\n          })\n        : generateSamplePointsCube(50, minFilter === 'nearest', {\n            method: sample_points,\n            textureWidth: texture.width,\n            textureDepthOrArrayLayers: texture.depthOrArrayLayers,\n          })\n    ).map((c, i) => {\n      const hash = hashU32(i);\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords: c,\n        offset: offset\n          ? [(hash & 0xf) - 8, ((hash >> 4) & 0xf) - 8, ((hash >> 8) & 0xf) - 8]\n          : undefined,\n      };\n    });\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU,\n      addressModeV,\n      minFilter,\n      magFilter: minFilter,\n    };\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(t, texture, viewDescriptor, textureType, sampler, calls);\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: C) -> vec4<f32>\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: C, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      /* array_index not param'd as out-of-bounds is implementation specific */\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: C) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .paramsSubcasesOnly(\n    u =>\n      u\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n        .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n        .combine('coords', generateCoordBoundaries(3))\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(3))\n  )\n  .unimplemented();\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: C) -> f32\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: C, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      /* array_index not param'd as out-of-bounds is implementation specific */\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('depth_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: C) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .paramsSubcasesOnly(\n    u =>\n      u\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n        .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n        .combine('coords', generateCoordBoundaries(3))\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n"],"mappings":"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"}
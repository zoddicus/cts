{"version":3,"file":"textureSample.spec.js","names":["description","makeTestGroup","kEncodableTextureFormats","kTextureFormatInfo","GPUTest","TextureTestMixin","hashU32","kTexelRepresentationInfo","createRandomTexelView","putDataInTextureThenDrawAndCheckResults","generateSamplePoints","kSamplePointMethods","generateCoordBoundaries","generateOffsets","g","test","specURL","desc","params","u","combine","unimplemented","paramsSubcasesOnly","filter","t","type","format","color","beforeAllSubcases","skipIfTextureFormatNotSupported","hasFloat32","componentOrder","some","c","info","componentInfo","dataType","bitLength","selectDeviceOrSkipTestCase","fn","descriptor","size","width","height","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texelView","calls","minFilter","method","sample_points","textureWidth","textureHeight","map","i","hash","builtin","coordType","coords","offset","undefined","sampler","addressModeU","addressModeV","magFilter","res","device","texels","expectOK","beginSubcases"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSample.spec.ts"],"sourcesContent":["export const description = `\nSamples a texture.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { kEncodableTextureFormats, kTextureFormatInfo } from '../../../../../format_info.js';\nimport { GPUTest, TextureTestMixin } from '../../../../../gpu_test.js';\nimport { hashU32 } from '../../../../../util/math.js';\nimport { kTexelRepresentationInfo } from '../../../../../util/texture/texel_data.js';\n\nimport {\n  vec2,\n  createRandomTexelView,\n  TextureCall,\n  putDataInTextureThenDrawAndCheckResults,\n  generateSamplePoints,\n  kSamplePointMethods,\n} from './texture_utils.js';\nimport { generateCoordBoundaries, generateOffsets } from './utils.js';\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('control_flow')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nTests that 'textureSample' can only be called in uniform control flow.\n`\n  )\n  .params(u => u.combine('stage', ['fragment', 'vertex', 'compute'] as const))\n  .unimplemented();\n\ng.test('sampled_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(1))\n  )\n  .unimplemented();\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kEncodableTextureFormats)\n      .filter(t => {\n        const type = kTextureFormatInfo[t.format].color?.type;\n        return type === 'float' || type === 'unfilterable-float';\n      })\n      .combine('sample_points', kSamplePointMethods)\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t => {\n    const format = kTexelRepresentationInfo[t.params.format];\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    const hasFloat32 = format.componentOrder.some(c => {\n      const info = format.componentInfo[c]!;\n      return info.dataType === 'float' && info.bitLength === 32;\n    });\n    if (hasFloat32) {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(async t => {\n    const descriptor: GPUTextureDescriptor = {\n      format: t.params.format,\n      size: { width: 8, height: 8 },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const texelView = createRandomTexelView(descriptor);\n    const calls: TextureCall<vec2>[] = generateSamplePoints(50, t.params.minFilter === 'nearest', {\n      method: t.params.sample_points,\n      textureWidth: 8,\n      textureHeight: 8,\n    }).map((c, i) => {\n      const hash = hashU32(i) & 0xff;\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords: c,\n        offset: t.params.offset ? [(hash & 15) - 8, (hash >> 4) - 8] : undefined,\n      };\n    });\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: t.params.addressModeU,\n      addressModeV: t.params.addressModeV,\n      minFilter: t.params.minFilter,\n      magFilter: t.params.minFilter,\n    };\n    const res = await putDataInTextureThenDrawAndCheckResults(\n      t.device,\n      { texels: texelView, descriptor },\n      sampler,\n      calls\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords,derivatives')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\ntest mip level selection based on derivatives\n    `\n  )\n  .unimplemented();\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>\nfn textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('texture_type', ['texture_3d', 'texture_cube'] as const)\n      .beginSubcases()\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(3))\n      .combine('offset', generateOffsets(3))\n  )\n  .unimplemented();\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: C) -> vec4<f32>\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: C, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      /* array_index not param'd as out-of-bounds is implementation specific */\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: C) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .paramsSubcasesOnly(\n    u =>\n      u\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n        .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n        .combine('coords', generateCoordBoundaries(3))\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(3))\n  )\n  .unimplemented();\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: C) -> f32\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: C, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n      .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('coords', generateCoordBoundaries(2))\n      /* array_index not param'd as out-of-bounds is implementation specific */\n      .combine('offset', generateOffsets(2))\n  )\n  .unimplemented();\n\ng.test('depth_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: C) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .paramsSubcasesOnly(\n    u =>\n      u\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n        .combine('S', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n        .combine('coords', generateCoordBoundaries(3))\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n"],"mappings":"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"}
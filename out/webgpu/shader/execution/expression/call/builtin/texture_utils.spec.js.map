{"version":3,"file":"texture_utils.spec.js","names":["description","makeTestGroup","assert","isMultisampledTextureFormat","kDepthStencilFormats","GPUTest","getTextureDimensionFromView","virtualMipSize","kTexelRepresentationInfo","kShaderStages","chooseTextureSize","createTextureWithRandomDataAndGetTexels","graphWeights","isSupportedViewFormatCombo","makeRandomDepthComparisonTexelGenerator","queryMipLevelMixWeightsForDevice","readTextureToTexelViews","texelsApproximatelyEqual","g","texelFormat","texel","rep","componentOrder","map","component","join","test","desc","params","u","combine","filter","t","format","viewDimension","beforeAllSubcases","skipIfTextureViewDimensionNotSupported","selectDeviceForTextureFormatOrSkipTestCase","fn","size","minSize","minBlocks","descriptor","dimension","mipLevelCount","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","isCompatibility","textureBindingViewDimension","generator","combineWithParams","srcFormat","texelViewFormat","unless","sampleCount","texels","expectedTexelViews","texture","actualTexelViews","length","errors","mipLevel","actualMipLevelTexelView","expectedMipLevelTexelView","mipLevelSize","actualRep","expectedRep","z","y","x","actual","color","expected","maxFractionalDiff","actualStr","expectedStr","push","validateWeights","stage","builtin","weights","kNumMixSteps","showWeights","v","i","toString","padStart","expect","dx","dy","slope","kMinPercentUniqueWeights","Set","sampleLevelWeights","softwareMixToGPUMixGradWeights"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.spec.ts"],"sourcesContent":["export const description = `\nTests for texture_utils.ts\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { assert } from '../../../../../../common/util/util.js';\nimport { isMultisampledTextureFormat, kDepthStencilFormats } from '../../../../../format_info.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport { getTextureDimensionFromView, virtualMipSize } from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { kShaderStages } from '../../../../validation/decl/util.js';\n\nimport {\n  chooseTextureSize,\n  createTextureWithRandomDataAndGetTexels,\n  graphWeights,\n  isSupportedViewFormatCombo,\n  makeRandomDepthComparisonTexelGenerator,\n  queryMipLevelMixWeightsForDevice,\n  readTextureToTexelViews,\n  texelsApproximatelyEqual,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction texelFormat(texel: Readonly<PerTexelComponent<number>>, rep: TexelRepresentationInfo) {\n  return rep.componentOrder.map(component => `${component}: ${texel[component]}`).join(', ');\n}\n\ng.test('createTextureWithRandomDataAndGetTexels_with_generator')\n  .desc(\n    `\n    Test createTextureWithRandomDataAndGetTexels with a generator. Generators\n    are only used with textureXXXCompare builtins as we need specific random\n    values to test these builtins with a depth reference value.\n    `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('viewDimension', ['2d', '2d-array', 'cube', 'cube-array'] as const)\n      .filter(t => isSupportedViewFormatCombo(t.format, t.viewDimension))\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureViewDimensionNotSupported(t.params.viewDimension);\n    t.selectDeviceForTextureFormatOrSkipTestCase(t.params.format);\n  })\n  .fn(async t => {\n    const { format, viewDimension } = t.params;\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 4, format, viewDimension });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: getTextureDimensionFromView(viewDimension),\n      size,\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    await createTextureWithRandomDataAndGetTexels(t, descriptor, {\n      generator: makeRandomDepthComparisonTexelGenerator(descriptor, 'equal'),\n    });\n    // We don't expect any particular results. We just expect no validation errors.\n  });\n\ng.test('readTextureToTexelViews')\n  .desc('test readTextureToTexelViews for various formats and dimensions')\n  .params(u =>\n    u\n      .combineWithParams([\n        { srcFormat: 'r8unorm', texelViewFormat: 'rgba32float' },\n        { srcFormat: 'r8sint', texelViewFormat: 'rgba32sint' },\n        { srcFormat: 'r8uint', texelViewFormat: 'rgba32uint' },\n        { srcFormat: 'rgba32float', texelViewFormat: 'rgba32float' },\n        { srcFormat: 'rgba32uint', texelViewFormat: 'rgba32uint' },\n        { srcFormat: 'rgba32sint', texelViewFormat: 'rgba32sint' },\n        { srcFormat: 'depth24plus', texelViewFormat: 'rgba32float' },\n        { srcFormat: 'depth24plus', texelViewFormat: 'r32float' },\n        { srcFormat: 'depth24plus-stencil8', texelViewFormat: 'r32float' },\n        { srcFormat: 'stencil8', texelViewFormat: 'rgba32sint' },\n      ] as const)\n      .combine('viewDimension', ['1d', '2d', '2d-array', '3d', 'cube', 'cube-array'] as const)\n      .filter(t => isSupportedViewFormatCombo(t.srcFormat, t.viewDimension))\n      .combine('sampleCount', [1, 4] as const)\n      .unless(\n        t =>\n          t.sampleCount > 1 &&\n          (!isMultisampledTextureFormat(t.srcFormat) || t.viewDimension !== '2d')\n      )\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureViewDimensionNotSupported(t.params.viewDimension);\n  })\n  .fn(async t => {\n    const { srcFormat, texelViewFormat, viewDimension, sampleCount } = t.params;\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 4, format: srcFormat, viewDimension });\n    const descriptor: GPUTextureDescriptor = {\n      format: srcFormat,\n      dimension: getTextureDimensionFromView(viewDimension),\n      size,\n      mipLevelCount: viewDimension === '1d' || sampleCount > 1 ? 1 : 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      sampleCount,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    const { texels: expectedTexelViews, texture } = await createTextureWithRandomDataAndGetTexels(\n      t,\n      descriptor\n    );\n    const actualTexelViews = await readTextureToTexelViews(t, texture, descriptor, texelViewFormat);\n\n    assert(actualTexelViews.length === expectedTexelViews.length, 'num mip levels match');\n\n    const errors = [];\n    for (let mipLevel = 0; mipLevel < actualTexelViews.length; ++mipLevel) {\n      const actualMipLevelTexelView = actualTexelViews[mipLevel];\n      const expectedMipLevelTexelView = expectedTexelViews[mipLevel];\n      const mipLevelSize = virtualMipSize(texture.dimension, size, mipLevel);\n\n      const actualRep = kTexelRepresentationInfo[actualMipLevelTexelView.format];\n      const expectedRep = kTexelRepresentationInfo[expectedMipLevelTexelView.format];\n\n      for (let z = 0; z < mipLevelSize[2]; ++z) {\n        for (let y = 0; y < mipLevelSize[1]; ++y) {\n          for (let x = 0; x < mipLevelSize[0]; ++x) {\n            const actual = actualMipLevelTexelView.color({ x, y, z });\n            const expected = expectedMipLevelTexelView.color({ x, y, z });\n            // This currently expects the exact same values in actual vs expected.\n            // It's possible this needs to be relaxed slightly but only for non-integer formats.\n            // For now, if the tests pass everywhere, we'll keep it at 0 tolerance.\n            const maxFractionalDiff = 0;\n            if (\n              !texelsApproximatelyEqual(\n                actual,\n                actualMipLevelTexelView.format,\n                expected,\n                expectedMipLevelTexelView.format,\n                maxFractionalDiff\n              )\n            ) {\n              const actualStr = texelFormat(actual, actualRep);\n              const expectedStr = texelFormat(expected, expectedRep);\n              errors.push(\n                `texel at ${x}, ${y}, ${z}, expected: ${expectedStr}, actual: ${actualStr}`\n              );\n            }\n          }\n        }\n      }\n\n      assert(errors.length === 0, errors.join('\\n'));\n    }\n  });\n\nfunction validateWeights(t: GPUTest, stage: string, builtin: string, weights: number[]) {\n  const kNumMixSteps = weights.length - 1;\n  const showWeights = () => `\n${weights.map((v, i) => `${i.toString().padStart(2)}: ${v}`).join('\\n')}\n\ne = expected\nA = actual\n${graphWeights(32, weights)}\n`;\n\n  t.expect(\n    weights[0] === 0,\n    `stage: ${stage}, ${builtin}, weight 0 expected 0 but was ${weights[0]}\\n${showWeights()}`\n  );\n  t.expect(\n    weights[kNumMixSteps] === 1,\n    `stage: ${stage}, ${builtin}, top weight expected 1 but was ${\n      weights[kNumMixSteps]\n    }\\n${showWeights()}`\n  );\n\n  const dx = 1 / kNumMixSteps;\n  for (let i = 0; i < kNumMixSteps; ++i) {\n    const dy = weights[i + 1] - weights[i];\n    // dy / dx because dy might be 0\n    const slope = dy / dx;\n\n    // Validate the slope is not going down.\n    assert(\n      slope >= 0,\n      `stage: ${stage}, ${builtin}, weight[${i}] was not <= weight[${i + 1}]\\n${showWeights()}`\n    );\n\n    // Validate the slope is not going up too steeply.\n    // The correct slope is 1 / kNumMixSteps but Mac AMD and Mac Intel\n    // have the wrong mix weights. 2 is enough to pass Mac AMD which we\n    // decided is ok but will fail on Mac Intel in compute stage which we\n    // decides is not ok.\n    assert(\n      slope <= 2,\n      `stage: ${stage}, ${builtin}, slope from weight[${i}] to weight[${\n        i + 1\n      }] is > 2.\\n${showWeights()}`\n    );\n  }\n\n  // Test that we don't have a mostly flat set of weights.\n  // Note: Ideally every value is unique but 66% is enough to pass AMD Mac\n  // which we decided was ok but high enough to fail Intel Mac in a compute stage\n  // which we decided is not ok.\n  const kMinPercentUniqueWeights = 66;\n  t.expect(\n    new Set(weights).size >= ((weights.length * kMinPercentUniqueWeights * 0.01) | 0),\n    `stage: ${stage}, ${builtin}, expected at least ~${kMinPercentUniqueWeights}% unique weights\\n${showWeights()}`\n  );\n}\n\ng.test('weights')\n  .desc(\n    `\nTest the mip level weights are linear.\n\nGiven 2 mip levels, textureSampleLevel(....., mipLevel) should return\nmix(colorFromLevel0, colorFromLevel1, mipLevel).\n\nSimilarly, textureSampleGrad(...., ddx, ...) where ddx is\nvec2(mix(1.0, 2.0, mipLevel) / textureWidth, 0) should so return\nmix(colorFromLevel0, colorFromLevel1, mipLevel).\n\nIf we put 0,0,0,0 in level 0 and 1,1,1,1 in level 1 then we should arguably\nbe able to assert\n\n    for (mipLevel = 0; mipLevel <= 1, mipLevel += 0.01) {\n      assert(textureSampleLevel(t, s, vec2f(0.5), mipLevel) === mipLevel)\n      ddx = vec2(mix(1.0, 2.0, mipLevel) / textureWidth, 0)\n      assert(textureSampleGrad(t, s, vec2f(0.5), ddx, vec2f(0)) === mipLevel)\n    }\n\nUnfortunately, the GPUs do not do this. In particular:\n\nAMD Mac goes like this: Not great but we allow it\n\n +----------------+\n |             ***|\n |           **   |\n |          *     |\n |        **      |\n |      **        |\n |     *          |\n |   **           |\n |***             |\n +----------------+\n\n Intel Mac goes like this in a compute stage\n\n +----------------+\n |         *******|\n |         *      |\n |        *       |\n |        *       |\n |       *        |\n |       *        |\n |      *         |\n |*******         |\n +----------------+\n\nWhere as they should go like this\n\n +----------------+\n |              **|\n |            **  |\n |          **    |\n |        **      |\n |      **        |\n |    **          |\n |  **            |\n |**              |\n +----------------+\n\nTo make the texture builtin tests pass, they use the mix weights we query from the GPU\neven if they are arguably bad. This test is to surface the failure of the GPU\nto use mix weights the approximate a linear interpolation.\n\nWe allow the AMD case as but disallow extreme Intel case. WebGPU implementations\nare supposed to work around this issue by poly-filling on devices that fail this test.\n`\n  )\n  .params(u => u.combine('stage', kShaderStages))\n  .fn(async t => {\n    const { stage } = t.params;\n    const weights = await queryMipLevelMixWeightsForDevice(t, t.params.stage);\n    validateWeights(t, stage, 'textureSampleLevel', weights.sampleLevelWeights);\n    validateWeights(t, stage, 'textureSampleGrad', weights.softwareMixToGPUMixGradWeights);\n  });\n"],"mappings":"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"}
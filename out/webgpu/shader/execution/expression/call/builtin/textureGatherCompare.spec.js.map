{"version":3,"file":"textureGatherCompare.spec.js","names":["description","makeTestGroup","kCompareFunctions","isDepthTextureFormat","isEncodableTextureFormat","kDepthStencilFormats","checkCallResults","chooseTextureSize","createTextureWithRandomDataAndGetTexels","doTextureCalls","generateSamplePointsCube","generateTextureBuiltinInputs2D","kCubeSamplePointMethods","kSamplePointMethods","WGSLTextureSampleTest","g","test","specURL","desc","params","u","combine","filter","t","format","beginSubcases","beforeAllSubcases","skipIfTextureFormatNotSupported","fn","samplePoints","A","addressModeU","addressModeV","minFilter","compare","offset","width","height","minSize","minBlocks","depthOrArrayLayers","descriptor","size","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","texture","sampler","magFilter","mipmapFilter","calls","method","textureBuiltin","arrayIndex","num","type","depthRef","hashInputs","map","coords","builtin","coordType","arrayIndexType","textureType","viewDescriptor","results","res","expectOK","skipIfTextureViewDimensionNotSupported","addressMode","viewDimension","isCompatibility","textureBindingViewDimension","addressModeW","dimension","C"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureGatherCompare.spec.ts"],"sourcesContent":["export const description = `\nExecution tests for the 'textureGatherCompare' builtin function\n\nA texture gather compare operation performs a depth comparison on four texels in a depth texture and collects the results into a single vector, as follows:\n * Find the four texels that would be used in a depth sampling operation with linear filtering, from mip level 0:\n   - Use the specified coordinate, array index (when present), and offset (when present).\n   - The texels are adjacent, forming a square, when considering their texture space coordinates (u,v).\n   - Selected texels at the texture edge, cube face edge, or cube corners are handled as in ordinary texture sampling.\n * For each texel, perform a comparison against the depth reference value, yielding a 0.0 or 1.0 value, as controlled by the comparison sampler parameters.\n * Yield the four-component vector where the components are the comparison results with the texels with relative texel coordinates as follows:\n\n   Result component  Relative texel coordinate\n    x                (umin,vmax)\n    y                (umax,vmax)\n    z                (umax,vmin)\n    w                (umin,vmin)\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { kCompareFunctions } from '../../../../../capability_info.js';\nimport {\n  isDepthTextureFormat,\n  isEncodableTextureFormat,\n  kDepthStencilFormats,\n} from '../../../../../format_info.js';\n\nimport {\n  checkCallResults,\n  chooseTextureSize,\n  createTextureWithRandomDataAndGetTexels,\n  doTextureCalls,\n  generateSamplePointsCube,\n  generateTextureBuiltinInputs2D,\n  kCubeSamplePointMethods,\n  kSamplePointMethods,\n  TextureCall,\n  vec2,\n  vec3,\n  WGSLTextureSampleTest,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(WGSLTextureSampleTest);\n\ng.test('array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegathercompare')\n  .desc(\n    `\nA: i32, u32\n\nfn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> vec4<f32>\nfn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler_comparison\n * coords: The texture coordinates\n * array_index: The 0-based array index.\n * depth_ref: The reference value to compare the sampled depth value against\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('addressModeU', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('addressModeV', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('compare', kCompareFunctions)\n      .combine('offset', [false, true] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n  })\n  .fn(async t => {\n    const { format, samplePoints, A, addressModeU, addressModeV, minFilter, compare, offset } =\n      t.params;\n\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU,\n      addressModeV,\n      compare,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGatherCompare',\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      depthRef: true,\n      offset,\n      hashInputs: [format, samplePoints, A, addressModeU, addressModeV, minFilter, offset],\n    }).map(({ coords, arrayIndex, depthRef, offset }) => {\n      return {\n        builtin: 'textureGatherCompare',\n        coordType: 'f',\n        coords,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        depthRef,\n        offset,\n      };\n    });\n    const textureType = 'texture_depth_2d_array';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(t, texture, viewDescriptor, textureType, sampler, calls);\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n\ng.test('array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegathercompare')\n  .desc(\n    `\nA: i32, u32\n\nfn textureGatherCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler_comparison\n * coords: The texture coordinates\n * array_index: The 0-based array index.\n * depth_ref: The reference value to compare the sampled depth value against\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('compare', kCompareFunctions)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n  })\n  .fn(async t => {\n    const { format, A, samplePoints, addressMode, minFilter, compare } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      addressModeW: addressMode,\n      compare,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      textureBuiltin: 'textureGatherCompare',\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      depthRef: true,\n      hashInputs: [format, samplePoints, addressMode, minFilter],\n    }).map(({ coords, depthRef, arrayIndex }) => {\n      return {\n        builtin: 'textureGatherCompare',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        coordType: 'f',\n        coords,\n        depthRef,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = 'texture_depth_cube_array';\n    const results = await doTextureCalls(t, texture, viewDescriptor, textureType, sampler, calls);\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegathercompare')\n  .desc(\n    `\nfn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> vec4<f32>\nfn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler_comparison\n * coords: The texture coordinates\n * depth_ref: The reference value to compare the sampled depth value against\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .beginSubcases()\n      .combine('C', ['i32', 'u32'] as const)\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('compare', kCompareFunctions)\n      .combine('offset', [false, true] as const)\n  )\n  .fn(async t => {\n    const { format, C, samplePoints, addressMode, compare, minFilter, offset } = t.params;\n\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      compare,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      textureBuiltin: 'textureGatherCompare',\n      sampler,\n      descriptor,\n      offset,\n      depthRef: true,\n      hashInputs: [format, C, samplePoints, addressMode, minFilter, compare, offset],\n    }).map(({ coords, depthRef, offset }) => {\n      return {\n        builtin: 'textureGatherCompare',\n        coordType: 'f',\n        coords,\n        depthRef,\n        offset,\n      };\n    });\n    const textureType = 'texture_depth_2d';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(t, texture, viewDescriptor, textureType, sampler, calls);\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturegathercompare')\n  .desc(\n    `\nfn textureGatherCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> vec4<f32>\n\nParameters:\n * t: The depth texture to read from\n * s: The sampler_comparison\n * coords: The texture coordinates\n * depth_ref: The reference value to compare the sampled depth value against\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      // MAINTENANCE_TODO: Remove when support for depth24plus, depth24plus-stencil8, and depth32float-stencil8 is added.\n      .filter(t => isEncodableTextureFormat(t.format))\n      .combine('minFilter', ['nearest', 'linear'] as const)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('addressMode', ['clamp-to-edge', 'repeat', 'mirror-repeat'] as const)\n      .combine('compare', kCompareFunctions)\n  )\n  .fn(async t => {\n    const { format, samplePoints, addressMode, minFilter, compare } = t.params;\n\n    const viewDimension: GPUTextureViewDimension = 'cube';\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = 6;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: addressMode,\n      addressModeV: addressMode,\n      addressModeW: addressMode,\n      compare,\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      depthRef: true,\n      textureBuiltin: 'textureGatherCompare',\n      hashInputs: [format, samplePoints, addressMode, minFilter, compare],\n    }).map(({ coords, depthRef }) => {\n      return {\n        builtin: 'textureGatherCompare',\n        coordType: 'f',\n        coords,\n        depthRef,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = 'texture_depth_cube';\n    const results = await doTextureCalls(t, texture, viewDescriptor, textureType, sampler, calls);\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results\n    );\n    t.expectOK(res);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,kDAAkD;AAChF,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE;EACEC,oBAAoB;EACpBC,wBAAwB;EACxBC,oBAAoB;AACf,+BAA+B;;AAEtC;EACEC,gBAAgB;EAChBC,iBAAiB;EACjBC,uCAAuC;EACvCC,cAAc;EACdC,wBAAwB;EACxBC,8BAA8B;EAC9BC,uBAAuB;EACvBC,mBAAmB;;;;EAInBC,qBAAqB;AAChB,oBAAoB;;AAE3B,OAAO,MAAMC,CAAC,GAAGd,aAAa,CAACa,qBAAqB,CAAC;;AAErDC,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,kDAAkD,CAAC;AAC3DC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAEhB,oBAAoB;AACvC;AAAA,CACCiB,MAAM,CAAC,CAAAC,CAAC,KAAIpB,oBAAoB,CAACoB,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAInB,wBAAwB,CAACmB,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CH,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDI,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAER,mBAAmB,CAAC;AAC5CQ,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,cAAc,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC9EA,OAAO,CAAC,SAAS,EAAEnB,iBAAiB,CAAC;AACrCmB,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAK,iBAAiB,CAAC,CAAAH,CAAC,KAAI;EACtBA,CAAC,CAACI,+BAA+B,CAACJ,CAAC,CAACJ,MAAM,CAACK,MAAM,CAAC;AACpD,CAAC,CAAC;AACDI,EAAE,CAAC,OAAML,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEK,YAAY,EAAEC,CAAC,EAAEC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,CAAC,CAAC;EACvFZ,CAAC,CAACJ,MAAM;;EAEV,MAAM,CAACiB,KAAK,EAAEC,MAAM,CAAC,GAAG9B,iBAAiB,CAAC,EAAE+B,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEf,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAMgB,kBAAkB,GAAG,CAAC;;EAE5B,MAAMC,UAAgC,GAAG;IACvCjB,MAAM;IACNkB,IAAI,EAAE,EAAEN,KAAK,EAAEC,MAAM,EAAEG,kBAAkB,CAAC,CAAC;IAC3CG,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAMxC,uCAAuC,CAACe,CAAC,EAAEkB,UAAU,CAAC;EACxF,MAAMQ,OAA6B,GAAG;IACpClB,YAAY;IACZC,YAAY;IACZE,OAAO;IACPD,SAAS;IACTiB,SAAS,EAAEjB,SAAS;IACpBkB,YAAY,EAAElB;EAChB,CAAC;;EAED,MAAMmB,KAA0B,GAAGzC,8BAA8B,CAAC,EAAE,EAAE;IACpE0C,MAAM,EAAExB,YAAY;IACpByB,cAAc,EAAE,sBAAsB;IACtCL,OAAO;IACPR,UAAU;IACVc,UAAU,EAAE,EAAEC,GAAG,EAAER,OAAO,CAACR,kBAAkB,EAAEiB,IAAI,EAAE3B,CAAC,CAAC,CAAC;IACxD4B,QAAQ,EAAE,IAAI;IACdvB,MAAM;IACNwB,UAAU,EAAE,CAACnC,MAAM,EAAEK,YAAY,EAAEC,CAAC,EAAEC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEE,MAAM;EACrF,CAAC,CAAC,CAACyB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEN,UAAU,EAAEG,QAAQ,EAAEvB,MAAM,CAAC,CAAC,KAAK;IACnD,OAAO;MACL2B,OAAO,EAAE,sBAAsB;MAC/BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNN,UAAU;MACVS,cAAc,EAAElC,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MACvC4B,QAAQ;MACRvB;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM8B,WAAW,GAAG,wBAAwB;EAC5C,MAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,OAAO,GAAG,MAAM1D,cAAc,CAACc,CAAC,EAAEyB,OAAO,EAAEkB,cAAc,EAAED,WAAW,EAAEhB,OAAO,EAAEG,KAAK,CAAC;EAC7F,MAAMgB,GAAG,GAAG,MAAM9D,gBAAgB;IAChCiB,CAAC;IACD,EAAEwB,MAAM,EAAEN,UAAU,EAAEyB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXhB,OAAO;IACPG,KAAK;IACLe;EACF,CAAC;EACD5C,CAAC,CAAC8C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJrD,CAAC,CAACC,IAAI,CAAC,iBAAiB,CAAC;AACtBC,OAAO,CAAC,kDAAkD,CAAC;AAC3DC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAEhB,oBAAoB;AACvC;AAAA,CACCiB,MAAM,CAAC,CAAAC,CAAC,KAAIpB,oBAAoB,CAACoB,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAInB,wBAAwB,CAACmB,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CH,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDI,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAET,uBAAuB,CAAC;AAChDS,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,SAAS,EAAEnB,iBAAiB;AACzC,CAAC;AACAwB,iBAAiB,CAAC,CAAAH,CAAC,KAAI;EACtBA,CAAC,CAAC+C,sCAAsC,CAAC,YAAY,CAAC;AACxD,CAAC,CAAC;AACD1C,EAAE,CAAC,OAAML,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEM,CAAC,EAAED,YAAY,EAAE0C,WAAW,EAAEtC,SAAS,EAAEC,OAAO,CAAC,CAAC,GAAGX,CAAC,CAACJ,MAAM;;EAE7E,MAAMqD,aAAsC,GAAG,YAAY;EAC3D,MAAM9B,IAAI,GAAGnC,iBAAiB,CAAC,EAAE+B,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEf,MAAM,EAAEgD,aAAa,CAAC,CAAC,CAAC;;EAEnF,MAAM/B,UAAgC,GAAG;IACvCjB,MAAM;IACN,IAAID,CAAC,CAACkD,eAAe,IAAI,EAAEC,2BAA2B,EAAEF,aAAa,CAAC,CAAC,CAAC;IACxE9B,IAAI;IACJC,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAMxC,uCAAuC,CAACe,CAAC,EAAEkB,UAAU,CAAC;EACxF,MAAMQ,OAA6B,GAAG;IACpClB,YAAY,EAAEwC,WAAW;IACzBvC,YAAY,EAAEuC,WAAW;IACzBI,YAAY,EAAEJ,WAAW;IACzBrC,OAAO;IACPD,SAAS;IACTiB,SAAS,EAAEjB,SAAS;IACpBkB,YAAY,EAAElB;EAChB,CAAC;;EAED,MAAMmB,KAA0B,GAAG1C,wBAAwB,CAAC,EAAE,EAAE;IAC9D2C,MAAM,EAAExB,YAAY;IACpBoB,OAAO;IACPR,UAAU;IACVa,cAAc,EAAE,sBAAsB;IACtCC,UAAU,EAAE,EAAEC,GAAG,EAAER,OAAO,CAACR,kBAAkB,GAAG,CAAC,EAAEiB,IAAI,EAAE3B,CAAC,CAAC,CAAC;IAC5D4B,QAAQ,EAAE,IAAI;IACdC,UAAU,EAAE,CAACnC,MAAM,EAAEK,YAAY,EAAE0C,WAAW,EAAEtC,SAAS;EAC3D,CAAC,CAAC,CAAC2B,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEH,QAAQ,EAAEH,UAAU,CAAC,CAAC,KAAK;IAC3C,OAAO;MACLO,OAAO,EAAE,sBAAsB;MAC/BP,UAAU;MACVS,cAAc,EAAElC,CAAC,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;MACvCiC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNH;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAMQ,cAAc,GAAG;IACrBU,SAAS,EAAEJ;EACb,CAAC;EACD,MAAMP,WAAW,GAAG,0BAA0B;EAC9C,MAAME,OAAO,GAAG,MAAM1D,cAAc,CAACc,CAAC,EAAEyB,OAAO,EAAEkB,cAAc,EAAED,WAAW,EAAEhB,OAAO,EAAEG,KAAK,CAAC;EAC7F,MAAMgB,GAAG,GAAG,MAAM9D,gBAAgB;IAChCiB,CAAC;IACD,EAAEwB,MAAM,EAAEN,UAAU,EAAEyB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXhB,OAAO;IACPG,KAAK;IACLe;EACF,CAAC;EACD5C,CAAC,CAAC8C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJrD,CAAC,CAACC,IAAI,CAAC,mBAAmB,CAAC;AACxBC,OAAO,CAAC,kDAAkD,CAAC;AAC3DC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAEhB,oBAAoB;AACvC;AAAA,CACCiB,MAAM,CAAC,CAAAC,CAAC,KAAIpB,oBAAoB,CAACoB,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAInB,wBAAwB,CAACmB,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CH,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDI,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,CAAU,CAAC;AACrCA,OAAO,CAAC,cAAc,EAAER,mBAAmB,CAAC;AAC5CQ,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,SAAS,EAAEnB,iBAAiB,CAAC;AACrCmB,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC7C,CAAC;AACAO,EAAE,CAAC,OAAML,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEqD,CAAC,EAAEhD,YAAY,EAAE0C,WAAW,EAAErC,OAAO,EAAED,SAAS,EAAEE,MAAM,CAAC,CAAC,GAAGZ,CAAC,CAACJ,MAAM;;EAErF,MAAM,CAACiB,KAAK,EAAEC,MAAM,CAAC,GAAG9B,iBAAiB,CAAC,EAAE+B,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEf,MAAM,CAAC,CAAC,CAAC;EAC/E,MAAMiB,UAAgC,GAAG;IACvCjB,MAAM;IACNkB,IAAI,EAAE,EAAEN,KAAK,EAAEC,MAAM,CAAC,CAAC;IACvBM,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAMxC,uCAAuC,CAACe,CAAC,EAAEkB,UAAU,CAAC;EACxF,MAAMQ,OAA6B,GAAG;IACpClB,YAAY,EAAEwC,WAAW;IACzBvC,YAAY,EAAEuC,WAAW;IACzBrC,OAAO;IACPD,SAAS;IACTiB,SAAS,EAAEjB,SAAS;IACpBkB,YAAY,EAAElB;EAChB,CAAC;;EAED,MAAMmB,KAA0B,GAAGzC,8BAA8B,CAAC,EAAE,EAAE;IACpE0C,MAAM,EAAExB,YAAY;IACpByB,cAAc,EAAE,sBAAsB;IACtCL,OAAO;IACPR,UAAU;IACVN,MAAM;IACNuB,QAAQ,EAAE,IAAI;IACdC,UAAU,EAAE,CAACnC,MAAM,EAAEqD,CAAC,EAAEhD,YAAY,EAAE0C,WAAW,EAAEtC,SAAS,EAAEC,OAAO,EAAEC,MAAM;EAC/E,CAAC,CAAC,CAACyB,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEH,QAAQ,EAAEvB,MAAM,CAAC,CAAC,KAAK;IACvC,OAAO;MACL2B,OAAO,EAAE,sBAAsB;MAC/BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNH,QAAQ;MACRvB;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAM8B,WAAW,GAAG,kBAAkB;EACtC,MAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,OAAO,GAAG,MAAM1D,cAAc,CAACc,CAAC,EAAEyB,OAAO,EAAEkB,cAAc,EAAED,WAAW,EAAEhB,OAAO,EAAEG,KAAK,CAAC;EAC7F,MAAMgB,GAAG,GAAG,MAAM9D,gBAAgB;IAChCiB,CAAC;IACD,EAAEwB,MAAM,EAAEN,UAAU,EAAEyB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXhB,OAAO;IACPG,KAAK;IACLe;EACF,CAAC;EACD5C,CAAC,CAAC8C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC;;AAEJrD,CAAC,CAACC,IAAI,CAAC,mBAAmB,CAAC;AACxBC,OAAO,CAAC,kDAAkD,CAAC;AAC3DC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAEhB,oBAAoB;AACvC;AAAA,CACCiB,MAAM,CAAC,CAAAC,CAAC,KAAIpB,oBAAoB,CAACoB,CAAC,CAACC,MAAM,CAAC;AAC3C;AAAA,CACCF,MAAM,CAAC,CAAAC,CAAC,KAAInB,wBAAwB,CAACmB,CAAC,CAACC,MAAM,CAAC,CAAC;AAC/CH,OAAO,CAAC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAU,CAAC;AACpDI,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,cAAc,EAAET,uBAAuB,CAAC;AAChDS,OAAO,CAAC,aAAa,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,eAAe,CAAU,CAAC;AAC7EA,OAAO,CAAC,SAAS,EAAEnB,iBAAiB;AACzC,CAAC;AACA0B,EAAE,CAAC,OAAML,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEK,YAAY,EAAE0C,WAAW,EAAEtC,SAAS,EAAEC,OAAO,CAAC,CAAC,GAAGX,CAAC,CAACJ,MAAM;;EAE1E,MAAMqD,aAAsC,GAAG,MAAM;EACrD,MAAM,CAACpC,KAAK,EAAEC,MAAM,CAAC,GAAG9B,iBAAiB,CAAC,EAAE+B,OAAO,EAAE,CAAC,EAAEC,SAAS,EAAE,CAAC,EAAEf,MAAM,EAAEgD,aAAa,CAAC,CAAC,CAAC;EAC9F,MAAMhC,kBAAkB,GAAG,CAAC;;EAE5B,MAAMC,UAAgC,GAAG;IACvCjB,MAAM;IACN,IAAID,CAAC,CAACkD,eAAe,IAAI,EAAEC,2BAA2B,EAAEF,aAAa,CAAC,CAAC,CAAC;IACxE9B,IAAI,EAAE,EAAEN,KAAK,EAAEC,MAAM,EAAEG,kBAAkB,CAAC,CAAC;IAC3CG,KAAK,EAAEC,eAAe,CAACC,QAAQ,GAAGD,eAAe,CAACE;EACpD,CAAC;EACD,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC,CAAC,GAAG,MAAMxC,uCAAuC,CAACe,CAAC,EAAEkB,UAAU,CAAC;EACxF,MAAMQ,OAA6B,GAAG;IACpClB,YAAY,EAAEwC,WAAW;IACzBvC,YAAY,EAAEuC,WAAW;IACzBI,YAAY,EAAEJ,WAAW;IACzBrC,OAAO;IACPD,SAAS;IACTiB,SAAS,EAAEjB,SAAS;IACpBkB,YAAY,EAAElB;EAChB,CAAC;;EAED,MAAMmB,KAA0B,GAAG1C,wBAAwB,CAAC,EAAE,EAAE;IAC9D2C,MAAM,EAAExB,YAAY;IACpBoB,OAAO;IACPR,UAAU;IACViB,QAAQ,EAAE,IAAI;IACdJ,cAAc,EAAE,sBAAsB;IACtCK,UAAU,EAAE,CAACnC,MAAM,EAAEK,YAAY,EAAE0C,WAAW,EAAEtC,SAAS,EAAEC,OAAO;EACpE,CAAC,CAAC,CAAC0B,GAAG,CAAC,CAAC,EAAEC,MAAM,EAAEH,QAAQ,CAAC,CAAC,KAAK;IAC/B,OAAO;MACLI,OAAO,EAAE,sBAAsB;MAC/BC,SAAS,EAAE,GAAG;MACdF,MAAM;MACNH;IACF,CAAC;EACH,CAAC,CAAC;EACF,MAAMQ,cAAc,GAAG;IACrBU,SAAS,EAAEJ;EACb,CAAC;EACD,MAAMP,WAAW,GAAG,oBAAoB;EACxC,MAAME,OAAO,GAAG,MAAM1D,cAAc,CAACc,CAAC,EAAEyB,OAAO,EAAEkB,cAAc,EAAED,WAAW,EAAEhB,OAAO,EAAEG,KAAK,CAAC;EAC7F,MAAMgB,GAAG,GAAG,MAAM9D,gBAAgB;IAChCiB,CAAC;IACD,EAAEwB,MAAM,EAAEN,UAAU,EAAEyB,cAAc,CAAC,CAAC;IACtCD,WAAW;IACXhB,OAAO;IACPG,KAAK;IACLe;EACF,CAAC;EACD5C,CAAC,CAAC8C,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC,CAAC"}
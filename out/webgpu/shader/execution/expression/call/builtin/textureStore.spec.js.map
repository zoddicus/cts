{"version":3,"file":"textureStore.spec.js","names":["description","makeTestGroup","unreachable","iterRange","GPUTest","TextureTestMixin","kFloat32Format","kFloat16Format","numberToFloatBits","pack4x8unorm","pack4x8snorm","virtualMipSize","TexelFormats","generateCoordBoundaries","g","test","specURL","desc","params","u","combineWithParams","beginSubcases","combine","unimplemented","inputArray","format","_shaderType","beforeAllSubcases","t","selectDeviceOrSkipTestCase","skipIfTextureFormatNotUsableAsStorageTexture","fn","values","numChannels","zeroVal","wgsl","v","length","numTexels","textureSize","width","height","depthOrArrayLayers","texture","createTextureTracked","dimension","size","mipLevelCount","usage","GPUTextureUsage","STORAGE_BINDING","COPY_SRC","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bg","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","bytesPerTexel","zeroChannel","buffer","copyWholeTextureToNewBufferSimple","uintsPerTexel","expected","Uint32Array","x","idx","Math","floor","channel","shaderVal","vals","maskedVal","lowChannels","bits","expectGPUBufferValuesEqual","r","b","a","kWidth","getTextureSize","dim","array","texelsPerArray","textureType","indexToCoord","type","outOfBoundsValue","getMipTexels","mip","texels","kDims","filter","mipCount","texel_format","num_texels","view_texels","texture_size","mip_size","oob_value","coords","wgx_size","num_wgs_x","baseArrayLayer","arrayLayerCount","baseMipLevel","m","expectedOutput","kArrayLevels","arrayLevels","baseLevel","view_dim","base_texels","view_size","baseOffset"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureStore.spec.ts"],"sourcesContent":["export const description = `\nWrites a single texel to a texture.\n\nThe channel format T depends on the storage texel format F.\nSee the texel format table for the mapping of texel format to channel format.\n\nNote: An out-of-bounds access occurs if:\n * any element of coords is outside the range [0, textureDimensions(t)) for the corresponding element, or\n * array_index is outside the range of [0, textureNumLayers(t))\n\nIf an out-of-bounds access occurs, the built-in function should not be executed.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { unreachable, iterRange } from '../../../../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../../../../gpu_test.js';\nimport {\n  kFloat32Format,\n  kFloat16Format,\n  numberToFloatBits,\n  pack4x8unorm,\n  pack4x8snorm,\n} from '../../../../../util/conversion.js';\nimport { virtualMipSize } from '../../../../../util/texture/base.js';\nimport { TexelFormats } from '../../../../types.js';\n\nimport { generateCoordBoundaries } from './utils.js';\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('store_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_1d<F,write>, coords: C, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(1))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\ng.test('store_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_2d<F,write>, coords: vec2<C>, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(2))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\ng.test('store_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_2d_array<F,write>, coords: vec2<C>, array_index: C, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * array_index The 0-based texture array index\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams(TexelFormats)\n        .beginSubcases()\n        .combine('coords', generateCoordBoundaries(2))\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n\ng.test('store_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_3d<F,write>, coords: vec3<C>, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(3))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\n// Returns shader input values for texel format tests.\n// Values are intentionally simple to avoid rounding issues.\nfunction inputArray(format: string): number[] {\n  switch (format) {\n    case 'rgba8snorm':\n      return [-1.1, 1.0, -0.6, -0.3, 0, 0.3, 0.6, 1.0, 1.1];\n    case 'rgba8unorm':\n    case 'bgra8unorm':\n      return [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.1];\n    case 'rgba8uint':\n    case 'rgba16uint':\n    case 'rgba32uint':\n    case 'r32uint':\n    case 'rg32uint':\n      // Stick within 8-bit ranges for simplicity.\n      return [0, 8, 16, 24, 32, 64, 100, 128, 200, 255];\n    case 'rgba8sint':\n    case 'rgba16sint':\n    case 'rgba32sint':\n    case 'r32sint':\n    case 'rg32sint':\n      // Stick within 8-bit ranges for simplicity.\n      return [-128, -100, -64, -32, -16, -8, 0, 8, 16, 32, 64, 100, 127];\n    case 'rgba16float':\n    case 'rgba32float':\n    case 'r32float':\n    case 'rg32float':\n      // Stick with simple values.\n      return [-100, -50, -32, -16, -8, -1, 0, 1, 8, 16, 32, 50, 100];\n    default:\n      unreachable(`unhandled format ${format}`);\n      break;\n  }\n  return [];\n}\n\ng.test('texel_formats')\n  .desc(`Test storage of texel formats`)\n  .params(u => u.combineWithParams([...TexelFormats, { format: 'bgra8unorm', _shaderType: 'f32' }]))\n  .beforeAllSubcases(t => {\n    if (t.params.format === 'bgra8unorm') {\n      t.selectDeviceOrSkipTestCase('bgra8unorm-storage');\n    } else {\n      t.skipIfTextureFormatNotUsableAsStorageTexture(t.params.format as GPUTextureFormat);\n    }\n  })\n  .fn(t => {\n    const { format, _shaderType } = t.params;\n    const values = inputArray(format);\n\n    let numChannels = 4;\n    switch (format) {\n      case 'r32uint':\n      case 'r32sint':\n      case 'r32float':\n        numChannels = 1;\n        break;\n      case 'rg32uint':\n      case 'rg32sint':\n      case 'rg32float':\n        numChannels = 2;\n        break;\n      default:\n        break;\n    }\n\n    let zeroVal = ``;\n    if (numChannels > 1) {\n      zeroVal = `val[idx % ${numChannels}] = 0;`;\n    }\n\n    let wgsl = `\nconst range = array(`;\n    for (const v of values) {\n      wgsl += `${v},\\n`;\n    }\n\n    wgsl += `\n);\n\n@group(0) @binding(0)\nvar tex : texture_storage_1d<${format}, write>;\n\n@compute @workgroup_size(${values.length})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  let idx = gid.x;\n  let scalarVal = range[idx];\n  let vecVal = vec4(scalarVal);\n  var val = vec4<${_shaderType}>(vecVal);\n  ${zeroVal}\n  textureStore(tex, gid.x, val);\n}\n`;\n\n    const numTexels = values.length;\n    const textureSize: GPUExtent3D = { width: numTexels, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.createTextureTracked({\n      format: format as GPUTextureFormat,\n      dimension: '1d',\n      size: textureSize,\n      mipLevelCount: 1,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: format as GPUTextureFormat,\n            dimension: '1d',\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(1, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    let bytesPerTexel = 4;\n    switch (format) {\n      case 'rgba16uint':\n      case 'rgba16sint':\n      case 'rgba16float':\n      case 'rg32uint':\n      case 'rg32sint':\n      case 'rg32float':\n        bytesPerTexel = 8;\n        break;\n      case 'rgba32uint':\n      case 'rgba32sint':\n      case 'rgba32float':\n        bytesPerTexel = 16;\n        break;\n      default:\n        break;\n    }\n\n    let zeroChannel = 0;\n    const buffer = t.copyWholeTextureToNewBufferSimple(texture, 0);\n    const uintsPerTexel = bytesPerTexel / 4;\n    const expected = new Uint32Array([\n      ...iterRange(numTexels * uintsPerTexel, x => {\n        const idx = Math.floor(x / uintsPerTexel);\n        const channel = idx % numChannels;\n        zeroChannel = zeroChannel % numChannels;\n        const shaderVal = values[idx];\n        switch (format) {\n          case 'rgba8unorm': {\n            const vals = [shaderVal, shaderVal, shaderVal, shaderVal];\n            vals[zeroChannel++] = 0;\n            return pack4x8unorm(vals[0], vals[1], vals[2], vals[3]);\n          }\n          case 'bgra8unorm': {\n            const vals = [shaderVal, shaderVal, shaderVal, shaderVal];\n            vals[zeroChannel++] = 0;\n            return pack4x8unorm(vals[2], vals[1], vals[0], vals[3]);\n          }\n          case 'rgba8snorm': {\n            const vals = [shaderVal, shaderVal, shaderVal, shaderVal];\n            vals[zeroChannel++] = 0;\n            return pack4x8snorm(vals[0], vals[1], vals[2], vals[3]);\n          }\n          case 'r32uint':\n          case 'r32sint':\n            return shaderVal;\n          case 'rg32uint':\n          case 'rgba32uint':\n          case 'rg32sint':\n          case 'rgba32sint': {\n            const maskedVal = channel === zeroChannel++ ? 0 : shaderVal;\n            return maskedVal;\n          }\n          case 'rgba8uint':\n          case 'rgba8sint': {\n            const vals = [shaderVal, shaderVal, shaderVal, shaderVal];\n            vals[zeroChannel++] = 0;\n            return (\n              ((vals[3] & 0xff) << 24) |\n              ((vals[2] & 0xff) << 16) |\n              ((vals[1] & 0xff) << 8) |\n              (vals[0] & 0xff)\n            );\n          }\n          case 'rgba16uint':\n          case 'rgba16sint': {\n            // 4 channels split over 2 uint32s.\n            // Determine if this pair has the zero channel.\n            const vals = [shaderVal, shaderVal];\n            const lowChannels = (x & 0x1) === 0;\n            if (lowChannels) {\n              if (zeroChannel < 2) {\n                vals[zeroChannel] = 0;\n              }\n            } else {\n              if (zeroChannel >= 2) {\n                vals[zeroChannel - 2] = 0;\n              }\n              zeroChannel++;\n            }\n            return ((vals[1] & 0xffff) << 16) | (vals[0] & 0xffff);\n          }\n          case 'r32float': {\n            return numberToFloatBits(shaderVal, kFloat32Format);\n          }\n          case 'rg32float':\n          case 'rgba32float': {\n            const maskedVal = channel === zeroChannel++ ? 0 : shaderVal;\n            return numberToFloatBits(maskedVal, kFloat32Format);\n          }\n          case 'rgba16float': {\n            // 4 channels split over 2 uint32s.\n            // Determine if this pair has the zero channel.\n            const bits = numberToFloatBits(shaderVal, kFloat16Format);\n            const vals = [bits, bits];\n            const lowChannels = (x & 0x1) === 0;\n            if (lowChannels) {\n              if (zeroChannel < 2) {\n                vals[zeroChannel] = 0;\n              }\n            } else {\n              if (zeroChannel >= 2) {\n                vals[zeroChannel - 2] = 0;\n              }\n              zeroChannel++;\n            }\n            return ((vals[1] & 0xffff) << 16) | (vals[0] & 0xffff);\n          }\n          default:\n            unreachable(`unhandled format ${format}`);\n            break;\n        }\n        return 0;\n      }),\n    ]);\n    t.expectGPUBufferValuesEqual(buffer, expected);\n  });\n\ng.test('bgra8unorm_swizzle')\n  .desc('Test bgra8unorm swizzling')\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('bgra8unorm-storage');\n  })\n  .fn(t => {\n    const values = [\n      { r: -1.1, g: 0.6, b: 0.4, a: 1 },\n      { r: 1.1, g: 0.6, b: 0.4, a: 1 },\n      { r: 0.4, g: -1.1, b: 0.6, a: 1 },\n      { r: 0.4, g: 1.1, b: 0.6, a: 1 },\n      { r: 0.6, g: 0.4, b: -1.1, a: 1 },\n      { r: 0.6, g: 0.4, b: 1.1, a: 1 },\n      { r: 0.2, g: 0.4, b: 0.6, a: 1 },\n      { r: -0.2, g: -0.4, b: -0.6, a: 1 },\n    ];\n    let wgsl = `\n@group(0) @binding(0) var tex : texture_storage_1d<bgra8unorm, write>;\n\nconst values = array(`;\n    for (const v of values) {\n      wgsl += `vec4(${v.r},${v.g},${v.b},${v.a}),\\n`;\n    }\n    wgsl += `);\n\n@compute @workgroup_size(${values.length})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  let value = values[gid.x];\n  textureStore(tex, gid.x, value);\n}`;\n\n    const numTexels = values.length;\n    const textureSize: GPUExtent3D = { width: numTexels, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.createTextureTracked({\n      format: 'bgra8unorm',\n      dimension: '1d',\n      size: textureSize,\n      mipLevelCount: 1,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: 'bgra8unorm',\n            dimension: '1d',\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(1, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    const buffer = t.copyWholeTextureToNewBufferSimple(texture, 0);\n    const expected = new Uint32Array([\n      ...iterRange(numTexels, x => {\n        const { r, g, b, a } = values[x];\n        return pack4x8unorm(b, g, r, a);\n      }),\n    ]);\n    t.expectGPUBufferValuesEqual(buffer, expected);\n  });\n\n// Texture width for dimensions >1D.\n// Sized such that mip level 2 will be at least 256 bytes/row.\nconst kWidth = 256;\n\n// Returns the texture geometry based on a given number of texels.\nfunction getTextureSize(numTexels: number, dim: GPUTextureDimension, array: number): GPUExtent3D {\n  const size: GPUExtent3D = { width: 1, height: 1, depthOrArrayLayers: 1 };\n  switch (dim) {\n    case '1d':\n      size.width = numTexels;\n      break;\n    case '2d': {\n      const texelsPerArray = numTexels / array;\n      size.width = kWidth;\n      size.height = texelsPerArray / kWidth;\n      size.depthOrArrayLayers = array;\n      break;\n    }\n    case '3d':\n      size.width = kWidth;\n      size.height = numTexels / (2 * kWidth);\n      size.depthOrArrayLayers = 2;\n      break;\n  }\n  return size;\n}\n\n// WGSL declaration type for the texture.\nfunction textureType(dim: GPUTextureDimension): string {\n  return `texture_storage_${dim}<r32uint, write>`;\n}\n\n// Defines a function to convert linear global id into a texture coordinate.\nfunction indexToCoord(dim: GPUTextureDimension, type: string): string {\n  switch (dim) {\n    case '1d':\n      return `\nfn indexToCoord(id : u32) -> ${type} {\n  return ${type}(id);\n}`;\n      break;\n    case '2d':\n      return `\nfn indexToCoord(id : u32) -> vec2<${type}> {\n  return vec2<${type}>(${type}(id % width), ${type}(id / width));\n}`;\n      break;\n    case '3d':\n      return `\nfn indexToCoord(id : u32) -> vec3<${type}> {\n  const half = numTexels / depth;\n  let half_id = id % half;\n  return vec3<${type}>(${type}(half_id % width), ${type}(half_id / width), ${type}(id / half));\n}`;\n      break;\n  }\n  return ``;\n}\n\n// Mutates 'coords' to produce an out-of-bounds value.\n// 1D workgroups are launched so 'gid.x' is the linear id.\n//\n// This code is only executed for odd global ids (gid.x % 2 == 1).\n// All the values are chosen such they will further divide the odd invocations.\nfunction outOfBoundsValue(dim: GPUTextureDimension, type: string): string {\n  switch (dim) {\n    case '1d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords = -coords;\n        } else {\n          coords = coords + numTexels;\n        }`;\n      } else {\n        return `coords = coords + numTexels;`;\n      }\n      break;\n    }\n    case '2d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords.x = -coords.x;\n        } else {\n          coords.y = coords.y + height;\n        }`;\n      } else {\n        return `if gid.x % 3 == 1 {\n          coords.x = coords.x + width;\n        } else {\n          coords.y = coords.y + height;\n        }`;\n      }\n      break;\n    }\n    case '3d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords.x = -coords.x;\n        } else if gid.x % 5 == 0 {\n          coords.y = coords.y + height;\n        } else {\n          coords.z = coords.z + depth;\n        }`;\n      } else {\n        return `if gid.x % 3 == 1 {\n          coords.x = coords.x + width;\n        } else if gid.x % 5 == 1 {\n          coords.y = coords.y + height;\n        } else {\n          coords.z = 2 * depth;\n        }`;\n      }\n      break;\n    }\n  }\n  return ``;\n}\n\n// Returns the number of texels for a given mip level.\n//\n// 1D textures cannot have multiple mip levels so always return the input number of texels.\nfunction getMipTexels(numTexels: number, dim: GPUTextureDimension, mip: number): number {\n  let texels = numTexels;\n  if (mip === 0) {\n    return texels;\n  }\n  if (dim === '2d') {\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n  } else if (dim === '3d') {\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n  }\n  return texels;\n}\n\nconst kDims = ['1d', '2d', '3d'] as const;\n\ng.test('out_of_bounds')\n  .desc('Test that textureStore on out-of-bounds coordinates have no effect')\n  .params(u =>\n    u\n      .combine('dim', kDims)\n      .combine('coords', ['i32', 'u32'] as const)\n      .combine('mipCount', [1, 2, 3] as const)\n      .combine('mip', [0, 1, 2] as const)\n      .filter(t => {\n        if (t.dim === '1d') {\n          return t.mipCount === 1 && t.mip === 0;\n        }\n        if (t.dim === '3d') {\n          return t.mipCount <= 2 && t.mip < t.mipCount;\n        }\n        return t.mip < t.mipCount;\n      })\n  )\n  .fn(t => {\n    const texel_format = 'r32uint';\n    // Chosen such that the even at higher mip counts,\n    // the texture is laid out without padding.\n    // This simplifies the checking code below.\n    //\n    // Mip level | 1d   | 2d       | 3d\n    // -----------------------------------------\n    // 0         | 4096 | 256 x 16 | 256 x 8 x 2\n    // 1         | -    | 128 x 8  | 128 x 4 x 1\n    // 2         | -    | 64  x 4  | -\n    const num_texels = 4096;\n    const view_texels = getMipTexels(num_texels, t.params.dim, t.params.mip);\n\n    const texture_size = getTextureSize(num_texels, t.params.dim, 1);\n    const mip_size = virtualMipSize(t.params.dim, texture_size, t.params.mip);\n    const texture = t.createTextureTracked({\n      format: texel_format,\n      dimension: t.params.dim,\n      size: texture_size,\n      mipLevelCount: t.params.mipCount,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n\n    const oob_value = outOfBoundsValue(t.params.dim, t.params.coords);\n    const wgx_size = 32;\n    const num_wgs_x = view_texels / wgx_size;\n\n    const wgsl = `\n@group(0) @binding(0) var tex : ${textureType(t.params.dim)};\n\nconst numTexels = ${view_texels};\nconst width = ${mip_size[0]};\nconst height = ${mip_size[1]};\nconst depth = ${mip_size[2]};\n\n${indexToCoord(t.params.dim, t.params.coords)}\n\n@compute @workgroup_size(${wgx_size})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  var coords = indexToCoord(gid.x);\n  if gid.x % 2 == 1 {\n    ${oob_value}\n  }\n  textureStore(tex, coords, vec4u(gid.x));\n}`;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: texel_format,\n            dimension: t.params.dim,\n            baseArrayLayer: 0,\n            arrayLayerCount: 1,\n            baseMipLevel: t.params.mip,\n            mipLevelCount: 1,\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(num_wgs_x, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    for (let m = 0; m < t.params.mipCount; m++) {\n      const buffer = t.copyWholeTextureToNewBufferSimple(texture, m);\n      if (m === t.params.mip) {\n        const expectedOutput = new Uint32Array([\n          ...iterRange(view_texels, x => {\n            if (x >= view_texels) {\n              return 0;\n            }\n            if (x % 2 === 1) {\n              return 0;\n            }\n            return x;\n          }),\n        ]);\n        t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n      } else {\n        const expectedOutput = new Uint32Array([\n          ...iterRange(getMipTexels(num_texels, t.params.dim, m), x => 0),\n        ]);\n        t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n      }\n    }\n  });\n\nconst kArrayLevels = 4;\n\ng.test('out_of_bounds_array')\n  .desc('Test that out-of-bounds array coordinates to textureStore have no effect')\n  .params(u =>\n    u\n      .combine('baseLevel', [0, 1, 2, 3] as const)\n      .combine('arrayLevels', [1, 2, 3, 4] as const)\n      .combine('type', ['i32', 'u32'] as const)\n      .filter(t => {\n        if (t.arrayLevels <= t.baseLevel) {\n          return false;\n        }\n        if (kArrayLevels < t.baseLevel + t.arrayLevels) {\n          return false;\n        }\n        return true;\n      })\n  )\n  .fn(t => {\n    const dim = '2d';\n    const view_dim = '2d-array';\n    const texel_format = 'r32uint';\n    const width = 64;\n    const height = 64;\n    const base_texels = width * height;\n    const num_texels = base_texels * kArrayLevels;\n    const view_texels = base_texels * t.params.arrayLevels;\n    const texture_size: GPUExtent3D = { width, height, depthOrArrayLayers: kArrayLevels };\n    const view_size: GPUExtent3D = { width, height, depthOrArrayLayers: t.params.arrayLevels };\n\n    const texture = t.createTextureTracked({\n      format: texel_format,\n      dimension: dim,\n      size: texture_size,\n      mipLevelCount: 1,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n\n    const wgx_size = 32;\n    const num_wgs_x = num_texels / wgx_size;\n\n    let oob_value = `layer = layer + layers;`;\n    if (t.params.type === 'i32') {\n      oob_value = `if gid.x % 3 == 0 {\n        layer = -(layer + layers);\n      } else {\n        layer = layer + layers;\n      }`;\n    }\n\n    const wgsl = `\n@group(0) @binding(0) var tex : texture_storage_2d_array<r32uint, write>;\n\nconst numTexels = ${view_texels};\nconst width = ${view_size.width};\nconst height = ${view_size.height ?? 1};\nconst layers = ${view_size.depthOrArrayLayers ?? 1};\nconst layerTexels = numTexels / layers;\n\n@compute @workgroup_size(${wgx_size})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  let layer_id = gid.x % layerTexels;\n  var x = ${t.params.type}(layer_id % width);\n  var y = ${t.params.type}(layer_id / width);\n  var layer = ${t.params.type}(gid.x / layerTexels);\n  if gid.x % 2 == 1 {\n    ${oob_value}\n  }\n  textureStore(tex, vec2(x, y), layer, vec4u(gid.x));\n}`;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: texel_format,\n            dimension: view_dim,\n            baseArrayLayer: t.params.baseLevel,\n            arrayLayerCount: t.params.arrayLevels,\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(num_wgs_x, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    const buffer = t.copyWholeTextureToNewBufferSimple(texture, 0);\n    const expectedOutput = new Uint32Array([\n      ...iterRange(num_texels, x => {\n        const baseOffset = base_texels * t.params.baseLevel;\n        if (x < baseOffset) {\n          return 0;\n        }\n        if (base_texels * (t.params.baseLevel + t.params.arrayLevels) <= x) {\n          return 0;\n        }\n        if (x % 2 === 1) {\n          return 0;\n        }\n        return x - baseOffset;\n      }),\n    ]);\n    t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n  });\n"],"mappings":"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"}
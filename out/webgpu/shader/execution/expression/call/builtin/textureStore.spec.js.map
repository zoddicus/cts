{"version":3,"file":"textureStore.spec.js","names":["description","makeTestGroup","iterRange","GPUTest","TextureTestMixin","virtualMipSize","TexelFormats","generateCoordBoundaries","g","test","specURL","desc","params","u","combineWithParams","beginSubcases","combine","unimplemented","kWidth","getTextureSize","numTexels","dim","array","size","width","height","depthOrArrayLayers","texelsPerArray","textureType","indexToCoord","type","outOfBoundsValue","getMipTexels","mip","texels","kDims","filter","t","mipCount","fn","texel_format","num_texels","view_texels","texture_size","mip_size","texture","device","createTexture","format","dimension","mipLevelCount","usage","GPUTextureUsage","STORAGE_BINDING","COPY_SRC","trackForCleanup","oob_value","coords","wgx_size","num_wgs_x","wgsl","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bg","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","baseArrayLayer","arrayLayerCount","baseMipLevel","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","m","buffer","copyWholeTextureToNewBufferSimple","expectedOutput","Uint32Array","x","expectGPUBufferValuesEqual","kArrayLevels","arrayLevels","baseLevel","view_dim","base_texels","view_size","baseOffset"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureStore.spec.ts"],"sourcesContent":["export const description = `\nWrites a single texel to a texture.\n\nThe channel format T depends on the storage texel format F.\nSee the texel format table for the mapping of texel format to channel format.\n\nNote: An out-of-bounds access occurs if:\n * any element of coords is outside the range [0, textureDimensions(t)) for the corresponding element, or\n * array_index is outside the range of [0, textureNumLayers(t))\n\nIf an out-of-bounds access occurs, the built-in function should not be executed.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { iterRange } from '../../../../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../../../../gpu_test.js';\nimport { virtualMipSize } from '../../../../../util/texture/base.js';\nimport { TexelFormats } from '../../../../types.js';\n\nimport { generateCoordBoundaries } from './utils.js';\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('store_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_1d<F,write>, coords: C, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(1))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\ng.test('store_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_2d<F,write>, coords: vec2<C>, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(2))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\ng.test('store_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_2d_array<F,write>, coords: vec2<C>, array_index: C, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * array_index The 0-based texture array index\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams(TexelFormats)\n        .beginSubcases()\n        .combine('coords', generateCoordBoundaries(2))\n        .combine('C', ['i32', 'u32'] as const)\n        .combine('C_value', [-1, 0, 1, 2, 3, 4] as const)\n    /* array_index not param'd as out-of-bounds is implementation specific */\n  )\n  .unimplemented();\n\ng.test('store_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturestore')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureStore(t: texture_storage_3d<F,write>, coords: vec3<C>, value: vec4<T>)\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * value The new texel value\n`\n  )\n  .params(u =>\n    u\n      .combineWithParams(TexelFormats)\n      .beginSubcases()\n      .combine('coords', generateCoordBoundaries(3))\n      .combine('C', ['i32', 'u32'] as const)\n  )\n  .unimplemented();\n\n// Texture width for dimensions >1D.\n// Sized such that mip level 2 will be at least 256 bytes/row.\nconst kWidth = 256;\n\n// Returns the texture geometry based on a given number of texels.\nfunction getTextureSize(numTexels: number, dim: GPUTextureDimension, array: number): GPUExtent3D {\n  const size: GPUExtent3D = { width: 1, height: 1, depthOrArrayLayers: 1 };\n  switch (dim) {\n    case '1d':\n      size.width = numTexels;\n      break;\n    case '2d': {\n      const texelsPerArray = numTexels / array;\n      size.width = kWidth;\n      size.height = texelsPerArray / kWidth;\n      size.depthOrArrayLayers = array;\n      break;\n    }\n    case '3d':\n      size.width = kWidth;\n      size.height = numTexels / (2 * kWidth);\n      size.depthOrArrayLayers = 2;\n      break;\n  }\n  return size;\n}\n\n// WGSL declaration type for the texture.\nfunction textureType(dim: GPUTextureDimension): string {\n  return `texture_storage_${dim}<r32uint, write>`;\n}\n\n// Defines a function to convert linear global id into a texture coordinate.\nfunction indexToCoord(dim: GPUTextureDimension, type: string): string {\n  switch (dim) {\n    case '1d':\n      return `\nfn indexToCoord(id : u32) -> ${type} {\n  return ${type}(id);\n}`;\n      break;\n    case '2d':\n      return `\nfn indexToCoord(id : u32) -> vec2<${type}> {\n  return vec2<${type}>(${type}(id % width), ${type}(id / width));\n}`;\n      break;\n    case '3d':\n      return `\nfn indexToCoord(id : u32) -> vec3<${type}> {\n  const half = numTexels / depth;\n  let half_id = id % half;\n  return vec3<${type}>(${type}(half_id % width), ${type}(half_id / width), ${type}(id / half));\n}`;\n      break;\n  }\n  return ``;\n}\n\n// Mutates 'coords' to produce an out-of-bounds value.\n// 1D workgroups are launched so 'gid.x' is the linear id.\n//\n// This code is only executed for odd global ids (gid.x % 2 == 1).\n// All the values are chosen such they will further divide the odd invocations.\nfunction outOfBoundsValue(dim: GPUTextureDimension, type: string): string {\n  switch (dim) {\n    case '1d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords = -coords;\n        } else {\n          coords = coords + numTexels;\n        }`;\n      } else {\n        return `coords = coords + numTexels;`;\n      }\n      break;\n    }\n    case '2d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords.x = -coords.x;\n        } else {\n          coords.y = coords.y + height;\n        }`;\n      } else {\n        return `if gid.x % 3 == 1 {\n          coords.x = coords.x + width;\n        } else {\n          coords.y = coords.y + height;\n        }`;\n      }\n      break;\n    }\n    case '3d': {\n      if (type === 'i32') {\n        return `if gid.x % 3 == 0 {\n          coords.x = -coords.x;\n        } else if gid.x % 5 == 0 {\n          coords.y = coords.y + height;\n        } else {\n          coords.z = coords.z + depth;\n        }`;\n      } else {\n        return `if gid.x % 3 == 1 {\n          coords.x = coords.x + width;\n        } else if gid.x % 5 == 1 {\n          coords.y = coords.y + height;\n        } else {\n          coords.z = 2 * depth;\n        }`;\n      }\n      break;\n    }\n  }\n  return ``;\n}\n\n// Returns the number of texels for a given mip level.\n//\n// 1D textures cannot have multiple mip levels so always return the input number of texels.\nfunction getMipTexels(numTexels: number, dim: GPUTextureDimension, mip: number): number {\n  let texels = numTexels;\n  if (mip === 0) {\n    return texels;\n  }\n  if (dim === '2d') {\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n  } else if (dim === '3d') {\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n    texels /= 1 << mip;\n  }\n  return texels;\n}\n\nconst kDims = ['1d', '2d', '3d'] as const;\n\ng.test('out_of_bounds')\n  .desc('Test that textureStore on out-of-bounds coordinates have no effect')\n  .params(u =>\n    u\n      .combine('dim', kDims)\n      .combine('coords', ['i32', 'u32'] as const)\n      .combine('mipCount', [1, 2, 3] as const)\n      .combine('mip', [0, 1, 2] as const)\n      .filter(t => {\n        if (t.dim === '1d') {\n          return t.mipCount === 1 && t.mip === 0;\n        }\n        if (t.dim === '3d') {\n          return t.mipCount <= 2 && t.mip < t.mipCount;\n        }\n        return t.mip < t.mipCount;\n      })\n  )\n  .fn(t => {\n    const texel_format = 'r32uint';\n    // Chosen such that the even at higher mip counts,\n    // the texture is laid out without padding.\n    // This simplifies the checking code below.\n    //\n    // Mip level | 1d   | 2d       | 3d\n    // -----------------------------------------\n    // 0         | 4096 | 256 x 16 | 256 x 8 x 2\n    // 1         | -    | 128 x 8  | 128 x 4 x 1\n    // 2         | -    | 64  x 4  | -\n    const num_texels = 4096;\n    const view_texels = getMipTexels(num_texels, t.params.dim, t.params.mip);\n\n    const texture_size = getTextureSize(num_texels, t.params.dim, 1);\n    const mip_size = virtualMipSize(t.params.dim, texture_size, t.params.mip);\n    const texture = t.device.createTexture({\n      format: texel_format,\n      dimension: t.params.dim,\n      size: texture_size,\n      mipLevelCount: t.params.mipCount,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n    t.trackForCleanup(texture);\n\n    const oob_value = outOfBoundsValue(t.params.dim, t.params.coords);\n    const wgx_size = 32;\n    const num_wgs_x = view_texels / wgx_size;\n\n    const wgsl = `\n@group(0) @binding(0) var tex : ${textureType(t.params.dim)};\n\nconst numTexels = ${view_texels};\nconst width = ${mip_size[0]};\nconst height = ${mip_size[1]};\nconst depth = ${mip_size[2]};\n\n${indexToCoord(t.params.dim, t.params.coords)}\n\n@compute @workgroup_size(${wgx_size})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  var coords = indexToCoord(gid.x);\n  if gid.x % 2 == 1 {\n    ${oob_value}\n  }\n  textureStore(tex, coords, vec4u(gid.x));\n}`;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: texel_format,\n            dimension: t.params.dim,\n            baseArrayLayer: 0,\n            arrayLayerCount: 1,\n            baseMipLevel: t.params.mip,\n            mipLevelCount: 1,\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(num_wgs_x, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    for (let m = 0; m < t.params.mipCount; m++) {\n      const buffer = t.copyWholeTextureToNewBufferSimple(texture, m);\n      if (m === t.params.mip) {\n        const expectedOutput = new Uint32Array([\n          ...iterRange(view_texels, x => {\n            if (x >= view_texels) {\n              return 0;\n            }\n            if (x % 2 === 1) {\n              return 0;\n            }\n            return x;\n          }),\n        ]);\n        t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n      } else {\n        const expectedOutput = new Uint32Array([\n          ...iterRange(getMipTexels(num_texels, t.params.dim, m), x => 0),\n        ]);\n        t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n      }\n    }\n  });\n\nconst kArrayLevels = 4;\n\ng.test('out_of_bounds_array')\n  .desc('Test that out-of-bounds array coordinates to textureStore have no effect')\n  .params(u =>\n    u\n      .combine('baseLevel', [0, 1, 2, 3] as const)\n      .combine('arrayLevels', [1, 2, 3, 4] as const)\n      .combine('type', ['i32', 'u32'] as const)\n      .filter(t => {\n        if (t.arrayLevels <= t.baseLevel) {\n          return false;\n        }\n        if (kArrayLevels < t.baseLevel + t.arrayLevels) {\n          return false;\n        }\n        return true;\n      })\n  )\n  .fn(t => {\n    const dim = '2d';\n    const view_dim = '2d-array';\n    const texel_format = 'r32uint';\n    const width = 64;\n    const height = 64;\n    const base_texels = width * height;\n    const num_texels = base_texels * kArrayLevels;\n    const view_texels = base_texels * t.params.arrayLevels;\n    const texture_size: GPUExtent3D = { width, height, depthOrArrayLayers: kArrayLevels };\n    const view_size: GPUExtent3D = { width, height, depthOrArrayLayers: t.params.arrayLevels };\n\n    const texture = t.device.createTexture({\n      format: texel_format,\n      dimension: dim,\n      size: texture_size,\n      mipLevelCount: 1,\n      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n    t.trackForCleanup(texture);\n\n    const wgx_size = 32;\n    const num_wgs_x = num_texels / wgx_size;\n\n    let oob_value = `layer = layer + layers;`;\n    if (t.params.type === 'i32') {\n      oob_value = `if gid.x % 3 == 0 {\n        layer = -(layer + layers);\n      } else {\n        layer = layer + layers;\n      }`;\n    }\n\n    const wgsl = `\n@group(0) @binding(0) var tex : texture_storage_2d_array<r32uint, write>;\n\nconst numTexels = ${view_texels};\nconst width = ${view_size.width};\nconst height = ${view_size.height ?? 1};\nconst layers = ${view_size.depthOrArrayLayers ?? 1};\nconst layerTexels = numTexels / layers;\n\n@compute @workgroup_size(${wgx_size})\nfn main(@builtin(global_invocation_id) gid : vec3u) {\n  let layer_id = gid.x % layerTexels;\n  var x = ${t.params.type}(layer_id % width);\n  var y = ${t.params.type}(layer_id / width);\n  var layer = ${t.params.type}(gid.x / layerTexels);\n  if gid.x % 2 == 1 {\n    ${oob_value}\n  }\n  textureStore(tex, vec2(x, y), layer, vec4u(gid.x));\n}`;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    const bg = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: texture.createView({\n            format: texel_format,\n            dimension: view_dim,\n            baseArrayLayer: t.params.baseLevel,\n            arrayLayerCount: t.params.arrayLevels,\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n          }),\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatchWorkgroups(num_wgs_x, 1, 1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    const buffer = t.copyWholeTextureToNewBufferSimple(texture, 0);\n    const expectedOutput = new Uint32Array([\n      ...iterRange(num_texels, x => {\n        const baseOffset = base_texels * t.params.baseLevel;\n        if (x < baseOffset) {\n          return 0;\n        }\n        if (base_texels * (t.params.baseLevel + t.params.arrayLevels) <= x) {\n          return 0;\n        }\n        if (x % 2 === 1) {\n          return 0;\n        }\n        return x - baseOffset;\n      }),\n    ]);\n    t.expectGPUBufferValuesEqual(buffer, expectedOutput);\n  });\n"],"mappings":"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"}
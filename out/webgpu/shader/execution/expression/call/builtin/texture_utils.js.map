{"version":3,"file":"texture_utils.js","names":["assert","range","unreachable","isCompressedTextureFormat","kEncodableTextureFormats","kTextureFormatInfo","float32ToUint32","align","clamp","dotProduct","hashU32","lerp","quantizeToF32","physicalMipSizeFromTexture","virtualMipSize","kTexelRepresentationInfo","TexelView","createTextureFromTexelViews","reifyExtent3D","getLimitValue","v","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getValueBetweenMinAndMaxTexelValueInclusive","rep","normalized","numericRange","min","max","getTexelViewFormatForTextureFormat","format","endsWith","createRandomTexelView","info","generator","coords","texel","component","componentOrder","rnd","x","y","z","charCodeAt","quantize","fromTexelsAsColors","createRandomTexelViewMipmap","mipLevelCount","dimension","size","tSize","width","height","depthOrArrayLayers","i","kTextureCallArgNames","toArray","Array","repl","bitsToNumber","unpackBits","Uint8Array","pack","encode","apply","a","b","op","length","map","add","softwareTextureReadMipLevel","call","texture","sampler","mipLevel","texels","descriptor","textureSize","addressMode","addressModeU","addressModeV","addressModeW","load","at","color","Math","floor","builtin","offset","undefined","samples","filter","minFilter","p0","p1","p1W","p0W","push","weight","p","round","out","ss","sample","c","n","softwareTextureRead","ddx","ddy","texSize","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","maxLevel","mipmapFilter","clampedMipLevel","baseMipLevel","nextMipLevel","ceil","t0","t1","mix","values","checkCallResults","device","calls","results","errs","maxFractionalDiff","getMaxFractionalDiffForTextureFormat","callIdx","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","g","e","absDiff","abs","ulpDiff","relDiff","desc","describeTextureCall","toFixed","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","gpuTexture","result","doTextureCalls","destroy","layoutTwoColumns","join","Error","softwareRasterize","targetSize","options","uvwStart","screenSpaceUMult","screenSpaceVMult","expData","Float32Array","fragY","fragX","coordType","rgba","R","G","B","A","asRgba32Float","set","fromTextureDataByReference","buffer","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","drawTexture","t","samplerDesc","renderTarget","createTexture","usage","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","trackForCleanup","uMult","vMult","offsetWGSL","code","shaderModule","createShaderModule","pipeline","createRenderPipeline","layout","vertex","module","fragment","targets","primitive","topology","createSampler","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","setBindGroup","draw","end","queue","submit","finish","includes","checkTextureMatchesExpectedTexelView","actualTexture","expectedTexelView","expectTexelViewComparisonIsOkInTexture","putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer","createTextureWithRandomDataAndGetTexels","fillTextureWithRandomBytes","hashBase","toString","split","reduce","sum","blocksAcross","blockWidth","blocksDown","blockHeight","bytes","bytesNeeded","data","writeTexture","s_readTextureToRGBA32DeviceToPipeline","WeakMap","readTextureToTexelViews","get","createComputePipeline","compute","readBuffers","uniformValues","Uint32Array","uniformBuffer","createBuffer","byteLength","GPUBufferUsage","UNIFORM","COPY_DST","writeBuffer","storageBuffer","STORAGE","readBuffer","MAP_READ","pass","beginComputePass","dispatchWorkgroups","copyBufferToBuffer","texelViews","mapAsync","GPUMapMode","READ","getMappedRange","slice","unmap","coord","run","numTexels","sampledTexelWeights","Map","unclassifiedStack","Set","unclassified","pop","setA","setB","keys","forEach","isCandidate","has","some","letter","idx","String","fromCharCode","orderedTexelIndices","lines","line","padEnd","texelIdx","weights","w","columnA","columnB","widthA","l","repeat","kSamplePointMethods","generateSamplePoints","nearest","args","method","r","textureWidth","textureHeight","f","radius","loops","PI","cos","sin","kSubdivisionsPerTexel","q","v1","v2","wgslTypeFor","type","wgslExpr","binKey","name","value","buildBinnedCalls","fields","prototype","startsWith","bitcastToU32","expr","binCalls","bins","key","binIdx","structs","body","dataFields","callCount","binned","dataBuffer","rtWidth","gpuSampler","resultBuffer","copyTextureToBuffer","outIdx","bin"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["import { assert, range, unreachable } from '../../../../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  isCompressedTextureFormat,\n  kEncodableTextureFormats,\n  kTextureFormatInfo,\n} from '../../../../../format_info.js';\nimport { GPUTest, TextureTestMixinType } from '../../../../../gpu_test.js';\nimport { float32ToUint32 } from '../../../../../util/conversion.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lerp,\n  quantizeToF32,\n} from '../../../../../util/math.js';\nimport { physicalMipSizeFromTexture, virtualMipSize } from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../../../util/texture/texel_view.js';\nimport { createTextureFromTexelViews } from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\n\nfunction getLimitValue(v: number) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getValueBetweenMinAndMaxTexelValueInclusive(\n  rep: TexelRepresentationInfo,\n  normalized: number\n) {\n  return lerp(\n    getLimitValue(rep.numericRange!.min),\n    getLimitValue(rep.numericRange!.max),\n    normalized\n  );\n}\n\n/**\n * We need the software rendering to do the same interpolation as the hardware\n * rendered so for -srgb formats we set the TexelView to an -srgb format as\n * TexelView handles this case. Note: It might be nice to add rgba32float-srgb\n * or something similar to TexelView.\n */\nexport function getTexelViewFormatForTextureFormat(format: GPUTextureFormat) {\n  return format.endsWith('-srgb') ? 'rgba8unorm-srgb' : 'rgba32float';\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nexport function createRandomTexelView(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n}): TexelView {\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  const generator = (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(coords.x, coords.y, coords.z, component.charCodeAt(0));\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = getValueBetweenMinAndMaxTexelValueInclusive(rep, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(info.format as EncodableTextureFormat, generator);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nexport function createRandomTexelViewMipmap(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  dimension?: GPUTextureDimension;\n}): TexelView[] {\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  const size = reifyExtent3D(info.size);\n  const tSize = [size.width, size.height, size.depthOrArrayLayers] as const;\n  return range(mipLevelCount, i =>\n    createRandomTexelView({\n      format: info.format,\n      size: virtualMipSize(dimension, tSize, i),\n    })\n  );\n}\n\nexport type vec2 = [number, number];\nexport type vec3 = [number, number, number];\nexport type vec4 = [number, number, number, number];\nexport type Dimensionality = number | vec2 | vec3;\n\ntype TextureCallArgKeys = keyof TextureCallArgs<number>;\nconst kTextureCallArgNames: TextureCallArgKeys[] = [\n  'coords',\n  'mipLevel',\n  'arrayIndex',\n  'ddx',\n  'ddy',\n  'offset',\n];\n\nexport interface TextureCallArgs<T extends Dimensionality> {\n  coords?: T;\n  mipLevel?: number;\n  arrayIndex?: number;\n  ddx?: T;\n  ddy?: T;\n  offset?: T;\n}\n\nexport interface TextureCall<T extends Dimensionality> extends TextureCallArgs<T> {\n  builtin: 'textureSample' | 'textureLoad';\n  coordType: 'f';\n}\n\nfunction toArray(coords: Dimensionality): number[] {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel: PerTexelComponent<number>, repl: TexelRepresentationInfo) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a: number[], b: number[], op: (x: number, y: number) => number) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\nconst add = (a: number[], b: number[]) => apply(a, b, (x, y) => x + y);\n\nexport interface Texture {\n  texels: TexelView[];\n  descriptor: GPUTextureDescriptor;\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nexport function softwareTextureReadMipLevel<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  mipLevel: number\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[texture.texels[mipLevel].format];\n  const tSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    [tSize.width, tSize.height, tSize.depthOrArrayLayers],\n    mipLevel\n  );\n  const addressMode = [\n    sampler.addressModeU ?? 'clamp-to-edge',\n    sampler.addressModeV ?? 'clamp-to-edge',\n    sampler.addressModeW ?? 'clamp-to-edge',\n  ];\n\n  const load = (at: number[]) =>\n    texture.texels[mipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0),\n    });\n\n  switch (call.builtin) {\n    case 'textureSample': {\n      const coords = toArray(call.coords!);\n\n      // convert normalized to absolute texel coordinate\n      // ┌───┬───┬───┬───┐\n      // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n      // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │ b │\n      // └───┴───┴───┴───┘\n      let at = coords.map((v, i) => v * textureSize[i] - 0.5);\n\n      // Apply offset in whole texel units\n      // This means the offset is added at each mip level in texels. There's no\n      // scaling for each level.\n      if (call.offset !== undefined) {\n        at = add(at, toArray(call.offset));\n      }\n\n      const samples: { at: number[]; weight: number }[] = [];\n\n      const filter = sampler.minFilter;\n      switch (filter) {\n        case 'linear': {\n          // 'p0' is the lower texel for 'at'\n          const p0 = at.map(v => Math.floor(v));\n          // 'p1' is the higher texel for 'at'\n          const p1 = p0.map(v => v + 1);\n\n          // interpolation weights for p0 and p1\n          const p1W = at.map((v, i) => v - p0[i]);\n          const p0W = p1W.map(v => 1 - v);\n\n          switch (coords.length) {\n            case 1:\n              samples.push({ at: p0, weight: p0W[0] });\n              samples.push({ at: p1, weight: p1W[0] });\n              break;\n            case 2: {\n              samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n              samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n              samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n              samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n              break;\n            }\n          }\n          break;\n        }\n        case 'nearest': {\n          const p = at.map(v => Math.round(quantizeToF32(v)));\n          samples.push({ at: p, weight: 1 });\n          break;\n        }\n        default:\n          unreachable();\n      }\n\n      const out: PerTexelComponent<number> = {};\n      const ss = [];\n      for (const sample of samples) {\n        // Apply sampler address mode\n        const c = sample.at.map((v, i) => {\n          switch (addressMode[i]) {\n            case 'clamp-to-edge':\n              return clamp(v, { min: 0, max: textureSize[i] - 1 });\n            case 'mirror-repeat': {\n              const n = Math.floor(v / textureSize[i]);\n              v = v - n * textureSize[i];\n              return (n & 1) !== 0 ? textureSize[i] - v - 1 : v;\n            }\n            case 'repeat':\n              return v - Math.floor(v / textureSize[i]) * textureSize[i];\n            default:\n              unreachable();\n          }\n        });\n        const v = load(c);\n        ss.push(v);\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * sample.weight;\n        }\n      }\n\n      return out;\n    }\n    case 'textureLoad': {\n      return load(toArray(call.coords!));\n    }\n  }\n}\n\n/**\n * The software version of a texture builtin (eg: textureSample)\n * Note that this is not a complete implementation. Rather it's only\n * what's needed to generate the correct expected value for the tests.\n */\nexport function softwareTextureRead<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  assert(call.ddx !== undefined);\n  assert(call.ddy !== undefined);\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  const texSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = [texSize.width, texSize.height];\n\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx: readonly number[] = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy: readonly number[] = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  // Compute the mip level the same way textureSampleGrad does\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  // MAINTENANCE_TODO: handle texture view baseMipLevel and mipLevelCount?\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n\n  const mipLevelCount = texture.texels.length;\n  const maxLevel = mipLevelCount - 1;\n\n  switch (sampler.mipmapFilter) {\n    case 'linear': {\n      const clampedMipLevel = clamp(mipLevel, { min: 0, max: maxLevel });\n      const baseMipLevel = Math.floor(clampedMipLevel);\n      const nextMipLevel = Math.ceil(clampedMipLevel);\n      const t0 = softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n      const t1 = softwareTextureReadMipLevel<T>(call, texture, sampler, nextMipLevel);\n      const mix = mipLevel % 1;\n      const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix },\n      ];\n      const out: PerTexelComponent<number> = {};\n      for (const { v, weight } of values) {\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * weight;\n        }\n      }\n      return out;\n    }\n    default: {\n      const baseMipLevel = Math.floor(\n        clamp(mipLevel + 0.5, { min: 0, max: texture.texels.length - 1 })\n      );\n      return softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n    }\n  }\n}\n\nexport type TextureTestOptions = {\n  ddx?: number; // the derivative we want at sample time\n  ddy?: number;\n  uvwStart?: readonly [number, number]; // the starting uv value (these are used make the coordinates negative as it uncovered issues on some hardware)\n  offset?: readonly [number, number]; // a constant offset\n};\n\n/**\n * Checks the result of each call matches the expected result.\n */\nexport async function checkCallResults<T extends Dimensionality>(\n  device: GPUDevice,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[],\n  results: PerTexelComponent<number>[]\n) {\n  const errs: string[] = [];\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  const maxFractionalDiff = getMaxFractionalDiffForTextureFormat(texture.descriptor.format);\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    const got = results[callIdx];\n    const expect = softwareTextureReadMipLevel(call, texture, sampler, 0);\n\n    const gULP = rep.bitsToULPFromZero(rep.numberToBits(got));\n    const eULP = rep.bitsToULPFromZero(rep.numberToBits(expect));\n    for (const component of rep.componentOrder) {\n      const g = got[component]!;\n      const e = expect[component]!;\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n      const relDiff = absDiff / Math.max(Math.abs(g), Math.abs(e));\n      if (ulpDiff > 3 && relDiff > maxFractionalDiff) {\n        const desc = describeTextureCall(call);\n        errs.push(`component was not as expected:\n      call: ${desc}\n component: ${component}\n       got: ${g}\n  expected: ${e}\n  abs diff: ${absDiff.toFixed(4)}\n  rel diff: ${(relDiff * 100).toFixed(2)}%\n  ulp diff: ${ulpDiff}\n  sample points:\n`);\n        const expectedSamplePoints = [\n          'expected:',\n          ...(await identifySamplePoints(texture.descriptor, (texels: TexelView) => {\n            return Promise.resolve(\n              softwareTextureReadMipLevel(\n                call,\n                { texels: [texels], descriptor: texture.descriptor },\n                sampler,\n                0\n              )\n            );\n          })),\n        ];\n        const gotSamplePoints = [\n          'got:',\n          ...(await identifySamplePoints(texture.descriptor, async (texels: TexelView) => {\n            const gpuTexture = createTextureFromTexelViews(device, [texels], texture.descriptor);\n            const result = (await doTextureCalls(device, gpuTexture, sampler, [call]))[0];\n            gpuTexture.destroy();\n            return result;\n          })),\n        ];\n        errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n        errs.push('', '');\n      }\n    }\n  }\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\n/**\n * \"Renders a quad\" to a TexelView with the given parameters,\n * sampling from the given Texture.\n */\nexport function softwareRasterize<T extends Dimensionality>(\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  targetSize: [number, number],\n  options: TextureTestOptions\n) {\n  const [width, height] = targetSize;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0] } = options;\n  const format = 'rgba32float';\n\n  const textureSize = reifyExtent3D(texture.descriptor.size);\n\n  // MAINTENANCE_TODO: Consider passing these in as a similar computation\n  // happens in putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer.\n  // The issue is there, the calculation is \"what do we need to multiply the unitQuad\n  // by to get the derivatives we want\". The calculation here is \"what coordinate\n  // will we get for a given frag coordinate\". It turns out to be the same calculation\n  // but needs rephrasing them so they are more obviously the same would help\n  // consolidate them into one calculation.\n  const screenSpaceUMult = (ddx * width) / textureSize.width;\n  const screenSpaceVMult = (ddy * height) / textureSize.height;\n\n  const rep = kTexelRepresentationInfo[format];\n\n  const expData = new Float32Array(width * height * 4);\n  for (let y = 0; y < height; ++y) {\n    const fragY = height - y - 1 + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const fragX = x + 0.5;\n      // This code calculates the same value that will be passed to\n      // `textureSample` in the fragment shader for a given frag coord (see the\n      // WGSL code which uses the same formula, but using interpolation). That\n      // shader renders a clip space quad and includes a inter-stage \"uv\"\n      // coordinates that start with a unit quad (0,0) to (1,1) and is\n      // multiplied by ddx,ddy and as added in uStart and vStart\n      //\n      // uv = unitQuad * vec2(ddx, ddy) + vec2(vStart, uStart);\n      //\n      // softwareTextureRead<T> simulates a single call to `textureSample` so\n      // here we're computing the `uv` value that will be passed for a\n      // particular fragment coordinate. fragX / width, fragY / height provides\n      // the unitQuad value.\n      //\n      // ddx and ddy in this case are the derivative values we want to test. We\n      // pass those into the softwareTextureRead<T> as they would normally be\n      // derived from the change in coord.\n      const coords = [\n        (fragX / width) * screenSpaceUMult + uvwStart[0],\n        (fragY / height) * screenSpaceVMult + uvwStart[1],\n      ] as T;\n      const call: TextureCall<T> = {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        ddx: [ddx / textureSize.width, 0] as T,\n        ddy: [0, ddy / textureSize.height] as T,\n        offset: options.offset as T,\n      };\n      const sample = softwareTextureRead<T>(call, texture, sampler);\n      const rgba = { R: 0, G: 0, B: 0, A: 1, ...sample };\n      const asRgba32Float = new Float32Array(rep.pack(rgba));\n      expData.set(asRgba32Float, (y * width + x) * 4);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(format, new Uint8Array(expData.buffer), {\n    bytesPerRow: width * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: targetSize,\n  });\n}\n\n/**\n * Render textured quad to an rgba32float texture.\n */\nexport function drawTexture(\n  t: GPUTest & TextureTestMixinType,\n  texture: GPUTexture,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const device = t.device;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0, 0], offset } = options;\n\n  const format = 'rgba32float';\n  const renderTarget = device.createTexture({\n    format,\n    size: [32, 32],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  t.trackForCleanup(renderTarget);\n\n  // Compute the amount we need to multiply the unitQuad by get the\n  // derivatives we want.\n  const uMult = (ddx * renderTarget.width) / texture.width;\n  const vMult = (ddy * renderTarget.height) / texture.height;\n\n  const offsetWGSL = offset ? `, vec2i(${offset[0]},${offset[1]})` : '';\n\n  const code = `\nstruct InOut {\n  @builtin(position) pos: vec4f,\n  @location(0) uv: vec2f,\n};\n\n@vertex fn vs(@builtin(vertex_index) vertex_index : u32) -> InOut {\n  let positions = array(\n    vec2f(-1,  1), vec2f( 1,  1),\n    vec2f(-1, -1), vec2f( 1, -1),\n  );\n  let pos = positions[vertex_index];\n  return InOut(\n    vec4f(pos, 0, 1),\n    (pos * 0.5 + 0.5) * vec2f(${uMult}, ${vMult}) + vec2f(${uvwStart[0]}, ${uvwStart[1]}),\n  );\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n\n@fragment fn fs(v: InOut) -> @location(0) vec4f {\n  return textureSample(T, S, v.uv${offsetWGSL});\n}\n`;\n\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const sampler = device.createSampler(samplerDesc);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: texture.createView() },\n      { binding: 1, resource: sampler },\n    ],\n  });\n\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{ view: renderTarget.createView(), loadOp: 'clear', storeOp: 'store' }],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  device.queue.submit([encoder.finish()]);\n\n  return renderTarget;\n}\n\nfunction getMaxFractionalDiffForTextureFormat(format: GPUTextureFormat) {\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  if (format.includes('8unorm')) {\n    return 7 / 255;\n  } else if (format.includes('2unorm')) {\n    return 9 / 512;\n  } else if (format.includes('unorm')) {\n    return 7 / 255;\n  } else if (format.includes('8snorm')) {\n    return 7.9 / 128;\n  } else if (format.includes('snorm')) {\n    return 7.9 / 128;\n  } else if (format.endsWith('ufloat')) {\n    return 156.249;\n  } else if (format.endsWith('float')) {\n    return 44;\n  } else {\n    unreachable();\n  }\n}\n\nexport function checkTextureMatchesExpectedTexelView(\n  t: GPUTest & TextureTestMixinType,\n  format: GPUTextureFormat,\n  actualTexture: GPUTexture,\n  expectedTexelView: TexelView\n) {\n  const maxFractionalDiff = getMaxFractionalDiffForTextureFormat(format);\n  t.expectTexelViewComparisonIsOkInTexture(\n    { texture: actualTexture },\n    expectedTexelView,\n    [actualTexture.width, actualTexture.height],\n    { maxFractionalDiff }\n  );\n}\n\n/**\n * Puts data in a texture. Renders a quad to a rgba32float. Then \"software renders\"\n * to a TexelView the expected result and compares the rendered texture to the\n * expected TexelView.\n */\nexport async function putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer<\n  T extends Dimensionality,\n>(\n  t: GPUTest & TextureTestMixinType,\n  descriptor: GPUTextureDescriptor,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const { texture, texels } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n\n  const actualTexture = drawTexture(t, texture, samplerDesc, options);\n  const expectedTexelView = softwareRasterize<T>(\n    { descriptor, texels },\n    samplerDesc,\n    [actualTexture.width, actualTexture.height],\n    options\n  );\n\n  checkTextureMatchesExpectedTexelView(t, texture.format, actualTexture, expectedTexelView);\n}\n\n/**\n * Fills a texture with random data. Assumes all values are valid.\n * so this function is not useful for floating point formats, where it would\n * insert NaNs. This function mostly useful for compressed formats.\n */\nexport function fillTextureWithRandomBytes(device: GPUDevice, texture: GPUTexture) {\n  const info = kTextureFormatInfo[texture.format];\n  const hashBase = texture.format\n    .toString()\n    .split('')\n    .reduce((sum, c) => sum + c.charCodeAt(0), 0);\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = physicalMipSizeFromTexture(texture, mipLevel);\n    const blocksAcross = Math.ceil(size[0] / info.blockWidth);\n    const blocksDown = Math.ceil(size[1] / info.blockHeight);\n    const bytesPerRow = blocksAcross * info.color!.bytes;\n    const bytesNeeded = bytesPerRow * blocksDown * size[2];\n    const data = new Uint8Array(bytesNeeded);\n    for (let i = 0; i < bytesNeeded; ++i) {\n      data[i] = hashU32(hashBase, mipLevel, i);\n    }\n    device.queue.writeTexture(\n      { texture, mipLevel },\n      data,\n      { bytesPerRow, rowsPerImage: blocksDown },\n      size\n    );\n  }\n}\n\nconst s_readTextureToRGBA32DeviceToPipeline = new WeakMap<GPUDevice, GPUComputePipeline>();\n\nexport async function readTextureToTexelViews(\n  t: GPUTest,\n  texture: GPUTexture,\n  format: EncodableTextureFormat\n) {\n  const device = t.device;\n  let pipeline = s_readTextureToRGBA32DeviceToPipeline.get(device);\n  if (!pipeline) {\n    const module = device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var<uniform> mipLevel: u32;\n        @group(0) @binding(1) var tex: texture_2d<f32>;\n        @group(0) @binding(2) var<storage, read_write> data: array<vec4f>;\n        @compute @workgroup_size(1) fn cs(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n          let size = textureDimensions(tex, mipLevel);\n          let ndx = global_invocation_id.y * size.x + global_invocation_id.x;\n          data[ndx] = textureLoad(tex, global_invocation_id.xy, mipLevel);\n        }\n      `,\n    });\n    pipeline = device.createComputePipeline({ layout: 'auto', compute: { module } });\n    s_readTextureToRGBA32DeviceToPipeline.set(device, pipeline);\n  }\n\n  const encoder = device.createCommandEncoder();\n\n  const readBuffers = [];\n  const textureSize = [texture.width, texture.height, texture.depthOrArrayLayers] as const;\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = virtualMipSize(texture.dimension, textureSize, mipLevel);\n\n    const uniformValues = new Uint32Array([mipLevel, 0, 0, 0]); // min size is 16 bytes\n    const uniformBuffer = device.createBuffer({\n      size: uniformValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(uniformBuffer);\n    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);\n\n    const storageBuffer = device.createBuffer({\n      size: size[0] * size[1] * size[2] * 4 * 4, // rgba32float\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(storageBuffer);\n\n    const readBuffer = device.createBuffer({\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    t.trackForCleanup(readBuffer);\n    readBuffers.push({ size, readBuffer });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: uniformBuffer } },\n        { binding: 1, resource: texture.createView() },\n        { binding: 2, resource: { buffer: storageBuffer } },\n      ],\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(...size);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, readBuffer.size);\n  }\n\n  device.queue.submit([encoder.finish()]);\n\n  const texelViews: TexelView[] = [];\n\n  for (const { readBuffer, size } of readBuffers) {\n    await readBuffer.mapAsync(GPUMapMode.READ);\n\n    // need a copy of the data since unmapping will nullify the typedarray view.\n    const data = new Float32Array(readBuffer.getMappedRange()).slice();\n    readBuffer.unmap();\n\n    texelViews.push(\n      TexelView.fromTexelsAsColors(format, coord => {\n        const offset = (coord.z * size[0] * size[1] + coord.y * size[0] + coord.x) * 4;\n        return {\n          R: data[offset + 0],\n          G: data[offset + 1],\n          B: data[offset + 2],\n          A: data[offset + 3],\n        };\n      })\n    );\n  }\n\n  return texelViews;\n}\n\n/**\n * Fills a texture with random data and returns that data as\n * an array of TexelView.\n *\n * For compressed textures the texture is filled with random bytes\n * and then read back from the GPU by sampling so the GPU decompressed\n * the texture.\n *\n * For uncompressed textures the TexelViews are generated and then\n * copied to the texture.\n */\nexport async function createTextureWithRandomDataAndGetTexels(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor\n) {\n  if (isCompressedTextureFormat(descriptor.format)) {\n    const texture = t.device.createTexture(descriptor);\n    t.trackForCleanup(texture);\n\n    fillTextureWithRandomBytes(t.device, texture);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels };\n  } else {\n    const texels = createRandomTexelViewMipmap(descriptor);\n    const texture = createTextureFromTexelViews(t.device, texels, descriptor);\n    return { texture, texels };\n  }\n}\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * It works by making an index for every pixel in the texture. Then,\n * for each index it generates texture data using TexelView.fromTexelsAsColor\n * with a single [1, 1, 1, 1] texel at the texel for the current index.\n *\n * In then calls 'run' which renders a single `call`. `run` uses either\n * the software renderer or WebGPU. The result ends up being the weights\n * used when sampling that pixel. 0 = that texel was not sampled. > 0 =\n * it was sampled.\n *\n * This lets you see if the weights from the software renderer match the\n * weights from WebGPU.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   ┌───┬───┬───┬───┬───┬───┬───┬───┐\n * 0 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 1 │   │   │   │   │   │   │   │ a │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 2 │   │   │   │   │   │   │   │ b │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 3 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 4 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 5 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 6 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 7 │   │   │   │   │   │   │   │   │\n *   └───┴───┴───┴───┴───┴───┴───┴───┘\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints(\n  info: GPUTextureDescriptor,\n  run: (texels: TexelView) => Promise<PerTexelComponent<number>>\n) {\n  const textureSize = reifyExtent3D(info.size);\n  const numTexels = textureSize.width * textureSize.height;\n  // This isn't perfect. We already know there was an error. We're just\n  // generating info so it seems okay it's not perfect. This format will\n  // be used to generate weights by drawing with a texture of this format\n  // with a specific pixel set to [1, 1, 1, 1]. As such, if the result\n  // is > 0 then that pixel was sampled and the results are the weights.\n  //\n  // Ideally, this texture with a single pixel set to [1, 1, 1, 1] would\n  // be the same format we were originally testing, the one we already\n  // detected an error for. This way, whatever subtle issues there are\n  // from that format will affect the weight values we're computing. But,\n  // if that format is not encodable, for example if it's a compressed\n  // texture format, then we have no way to build a texture so we use\n  // rgba8unorm instead.\n  const format = (\n    kEncodableTextureFormats.includes(info.format as EncodableTextureFormat)\n      ? info.format\n      : 'rgba8unorm'\n  ) as EncodableTextureFormat;\n  const rep = kTexelRepresentationInfo[format];\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map<number, PerTexelComponent<number>>();\n  const unclassifiedStack = [new Set<number>(range(numTexels, v => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop()!;\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set<number>();\n    const setB = new Set<number>();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.\n    const results = await run(\n      TexelView.fromTexelsAsColors(\n        format,\n        (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n          const isCandidate = setA.has(coords.x + coords.y * textureSize.width);\n          const texel: PerTexelComponent<number> = {};\n          for (const component of rep.componentOrder) {\n            texel[component] = isCandidate ? 1 : 0;\n          }\n          return texel;\n        }\n      )\n    );\n    if (rep.componentOrder.some(c => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach(texel => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  // ┌───┬───┬───┬───┐\n  // │ a │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │ b │\n  // └───┴───┴───┴───┘\n  const letter = (idx: number) => String.fromCharCode(97 + idx); // 97: 'a'\n  const orderedTexelIndices: number[] = [];\n  const lines: string[] = [];\n  {\n    let line = '  ';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += `  ${x.toString().padEnd(2)}`;\n    }\n    lines.push(line);\n  }\n  {\n    let line = '  ┌';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += x === textureSize.width - 1 ? '───┐' : '───┬';\n    }\n    lines.push(line);\n  }\n  for (let y = 0; y < textureSize.height; y++) {\n    {\n      let line = `${y.toString().padEnd(2)}│`;\n      for (let x = 0; x < textureSize.width; x++) {\n        const texelIdx = x + y * textureSize.height;\n        const weight = sampledTexelWeights.get(texelIdx);\n        if (weight !== undefined) {\n          line += ` ${letter(orderedTexelIndices.length)} │`;\n          orderedTexelIndices.push(texelIdx);\n        } else {\n          line += '   │';\n        }\n      }\n      lines.push(line);\n    }\n    if (y < textureSize.height - 1) {\n      let line = '  ├';\n      for (let x = 0; x < textureSize.width; x++) {\n        line += x === textureSize.width - 1 ? '───┤' : '───┼';\n      }\n      lines.push(line);\n    }\n  }\n  {\n    let line = '  └';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += x === textureSize.width - 1 ? '───┘' : '───┴';\n    }\n    lines.push(line);\n  }\n\n  orderedTexelIndices.forEach((texelIdx, i) => {\n    const weights = sampledTexelWeights.get(texelIdx)!;\n    const y = Math.floor(texelIdx / textureSize.width);\n    const x = texelIdx - y * textureSize.height;\n    const w = rep.componentOrder.map(c => `${c}: ${weights[c]?.toFixed(5)}`).join(', ');\n    lines.push(`${letter(i)}: at: [${x}, ${y}], weights: [${w}]`);\n  });\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA: string[], columnB: string[]) {\n  const widthA = Math.max(...columnA.map(l => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out: string[] = new Array<string>(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'] as const;\nexport type SamplePointMethods = (typeof kSamplePointMethods)[number];\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nexport function generateSamplePoints(\n  n: number,\n  nearest: boolean,\n  args:\n    | {\n        method: 'texel-centre';\n        textureWidth: number;\n        textureHeight: number;\n      }\n    | {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n        textureWidth: number;\n        textureHeight: number;\n      }\n) {\n  const out: vec2[] = [];\n  switch (args.method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const x = Math.floor(lerp(0, args.textureWidth - 1, (r & 0xffff) / 0xffff)) + 0.5;\n        const y = Math.floor(lerp(0, args.textureHeight - 1, (r >>> 16) / 0xffff)) + 0.5;\n        out.push([x / args.textureWidth, y / args.textureHeight]);\n      }\n      break;\n    }\n    case 'spiral': {\n      for (let i = 0; i < n; i++) {\n        const f = i / (Math.max(n, 2) - 1);\n        const r = (args.radius ?? 1.5) * f;\n        const a = (args.loops ?? 2) * 2 * Math.PI * f;\n        out.push([0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a)]);\n      }\n      break;\n    }\n  }\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n  const q = [args.textureWidth * kSubdivisionsPerTexel, args.textureHeight * kSubdivisionsPerTexel];\n  return out.map(\n    c =>\n      c.map((v, i) => {\n        // Quantize to kSubdivisionsPerPixel\n        const v1 = Math.floor(v * q[i]);\n        // If it's nearest and we're on the edge of a texel then move us off the edge\n        // since the edge could choose one texel or another in nearest mode\n        const v2 = nearest && v1 % kSubdivisionsPerTexel === 0 ? v1 + 1 : v1;\n        // Convert back to texture coords\n        return v2 / q[i];\n      }) as vec2\n  );\n}\n\nfunction wgslTypeFor(data: Dimensionality, type: 'f' | 'i' | 'u'): string {\n  if (data instanceof Array) {\n    switch (data.length) {\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n    }\n  }\n  return '${type}32';\n}\n\nfunction wgslExpr(data: number | vec2 | vec3 | vec4): string {\n  if (data instanceof Array) {\n    switch (data.length) {\n      case 2:\n        return `vec2(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map(v => v.toString()).join(', ')})`;\n    }\n  }\n  return data.toString();\n}\n\nfunction binKey<T extends Dimensionality>(call: TextureCall<T>): string {\n  const keys: string[] = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        // offset must be a constant expression\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls<T extends Dimensionality>(calls: TextureCall<T>[]) {\n  const args: string[] = ['T']; // All texture builtins take the texture as the first argument\n  const fields: string[] = [];\n  const data: number[] = [];\n\n  const prototype = calls[0];\n  if (prototype.builtin.startsWith('textureSample')) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else {\n        args.push(`args.${name}`);\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, prototype.coordType)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        (prototype[name] === undefined) === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset') {\n        const bitcastToU32 = (value: number) => {\n          if (calls[0].coordType === 'f') {\n            return float32ToUint32(value);\n          }\n          return value;\n        };\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls<T extends Dimensionality>(calls: TextureCall<T>[]): number[][] {\n  const map = new Map<string, number>(); // key to bin index\n  const bins: number[][] = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nexport function describeTextureCall<T extends Dimensionality>(call: TextureCall<T>): string {\n  const args: string[] = ['texture: T'];\n  if (call.builtin.startsWith('textureSample')) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      args.push(`${name}: ${wgslExpr(value)}`);\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the fragment position as an index\n * (position.y * 256 + position.x) That index is then used to look up a\n * coordinate from a storage buffer which is used to call the WGSL texture\n * function to read/sample the texture, and then write to an rgba32float\n * texture.  We then read the rgba32float texture for the per \"call\" results.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n */\nexport async function doTextureCalls<T extends Dimensionality>(\n  device: GPUDevice,\n  gpuTexture: GPUTexture,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[]\n) {\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data: number[] = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map(callIdx => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',  \\n')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (frag_idx >= ${callCount}) & (frag_idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[frag_idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = device.createBuffer({\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const rtWidth = 256;\n  const renderTarget = device.createTexture({\n    format: 'rgba32float',\n    size: { width: rtWidth, height: Math.ceil(calls.length / rtWidth) },\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertex_index : u32) -> @builtin(position) vec4f {\n  let positions = array(\n    vec4f(-1,  1, 0, 1), vec4f( 1,  1, 0, 1),\n    vec4f(-1, -1, 0, 1), vec4f( 1, -1, 0, 1),\n  );\n  return positions[vertex_index];\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n@group(0) @binding(2) var<storage> data : Data;\n\n@fragment\nfn fs_main(@builtin(position) frag_pos : vec4f) -> @location(0) vec4f {\n  let frag_idx = u32(frag_pos.x) + u32(frag_pos.y) * ${renderTarget.width};\n  var result : vec4f;\n${body}\n  return result;\n}\n`;\n\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format: renderTarget.format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const gpuSampler = device.createSampler(sampler);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: gpuTexture.createView() },\n      { binding: 1, resource: gpuSampler },\n      { binding: 2, resource: { buffer: dataBuffer } },\n    ],\n  });\n\n  const bytesPerRow = align(16 * renderTarget.width, 256);\n  const resultBuffer = device.createBuffer({\n    size: renderTarget.height * bytesPerRow,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [\n      {\n        view: renderTarget.createView(),\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  encoder.copyTextureToBuffer(\n    { texture: renderTarget },\n    { buffer: resultBuffer, bytesPerRow },\n    { width: renderTarget.width, height: renderTarget.height }\n  );\n  device.queue.submit([encoder.finish()]);\n\n  await resultBuffer.mapAsync(GPUMapMode.READ);\n\n  const view = TexelView.fromTextureDataByReference(\n    renderTarget.format as EncodableTextureFormat,\n    new Uint8Array(resultBuffer.getMappedRange()),\n    {\n      bytesPerRow,\n      rowsPerImage: renderTarget.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [renderTarget.width, renderTarget.height],\n    }\n  );\n\n  let outIdx = 0;\n  const out = new Array<PerTexelComponent<number>>(calls.length);\n  for (const bin of binned) {\n    for (const callIdx of bin) {\n      const x = outIdx % rtWidth;\n      const y = Math.floor(outIdx / rtWidth);\n      out[callIdx] = view.color({ x, y, z: 0 });\n      outIdx++;\n    }\n  }\n\n  renderTarget.destroy();\n  resultBuffer.destroy();\n\n  return out;\n}\n"],"mappings":"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"}
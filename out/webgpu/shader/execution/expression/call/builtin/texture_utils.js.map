{"version":3,"file":"texture_utils.js","names":["assert","range","unreachable","float32ToUint32","align","clamp","dotProduct","hashU32","lerp","quantizeToF32","virtualMipSize","kTexelRepresentationInfo","TexelView","createTextureFromTexelView","createTextureFromTexelViews","reifyExtent3D","getLimitValue","v","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getValueBetweenMinAndMaxTexelValueInclusive","rep","normalized","numericRange","min","max","createRandomTexelView","info","format","generator","coords","texel","component","componentOrder","rnd","x","y","z","charCodeAt","quantize","fromTexelsAsColors","createRandomTexelViewMipmap","mipLevelCount","dimension","size","tSize","width","height","depthOrArrayLayers","i","kTextureCallArgNames","toArray","Array","repl","bitsToNumber","unpackBits","Uint8Array","pack","encode","apply","a","b","op","length","map","add","softwareTextureReadMipLevel","call","texture","sampler","mipLevel","texels","descriptor","textureSize","addressMode","addressModeU","addressModeV","addressModeW","load","at","color","Math","floor","builtin","offset","undefined","samples","filter","minFilter","p0","p1","p1W","p0W","push","weight","p","round","out","ss","sample","c","n","softwareTextureRead","ddx","ddy","texSize","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","maxLevel","mipmapFilter","clampedMipLevel","baseMipLevel","nextMipLevel","ceil","t0","t1","mix","values","putDataInTextureThenDrawAndCheckResults","device","calls","results","doTextureCalls","errs","callIdx","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","g","e","absDiff","abs","ulpDiff","relDiff","desc","describeTextureCall","toFixed","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","layoutTwoColumns","join","Error","softwareRasterize","targetSize","options","uvwStart","screenSpaceUMult","screenSpaceVMult","expData","Float32Array","fragY","fragX","coordType","rgba","R","G","B","A","asRgba32Float","set","fromTextureDataByReference","buffer","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer","t","renderTarget","createTexture","usage","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","trackForCleanup","uMult","vMult","offsetWGSL","code","shaderModule","createShaderModule","pipeline","createRenderPipeline","layout","vertex","module","fragment","targets","primitive","topology","gpuTexture","gpuSampler","createSampler","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","setBindGroup","draw","end","queue","submit","finish","expTexelView","maxFractionalDiff","includes","endsWith","expectTexelViewComparisonIsOkInTexture","run","numTexels","sampledTexelWeights","Map","unclassifiedStack","Set","unclassified","pop","setA","setB","keys","forEach","isCandidate","has","some","letter","idx","String","fromCharCode","orderedTexelIndices","lines","line","texelIdx","get","weights","w","columnA","columnB","widthA","l","repeat","kSamplePointMethods","generateSamplePoints","nearest","args","method","r","textureWidth","textureHeight","f","radius","loops","PI","cos","sin","kSubdivisionsPerTexel","q","v1","v2","wgslTypeFor","data","type","wgslExpr","toString","binKey","name","value","buildBinnedCalls","fields","prototype","startsWith","bitcastToU32","expr","binCalls","bins","key","binIdx","structs","body","dataFields","callCount","binned","dataBuffer","createBuffer","GPUBufferUsage","COPY_DST","STORAGE","writeBuffer","Uint32Array","rtWidth","resultBuffer","MAP_READ","copyTextureToBuffer","mapAsync","GPUMapMode","READ","getMappedRange","outIdx","bin","destroy"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["import { assert, range, unreachable } from '../../../../../../common/util/util.js';\nimport { EncodableTextureFormat } from '../../../../../format_info.js';\nimport { GPUTest, TextureTestMixinType } from '../../../../../gpu_test.js';\nimport { float32ToUint32 } from '../../../../../util/conversion.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lerp,\n  quantizeToF32,\n} from '../../../../../util/math.js';\nimport { virtualMipSize } from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../../../util/texture/texel_view.js';\nimport {\n  createTextureFromTexelView,\n  createTextureFromTexelViews,\n} from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\n\nfunction getLimitValue(v: number) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getValueBetweenMinAndMaxTexelValueInclusive(\n  rep: TexelRepresentationInfo,\n  normalized: number\n) {\n  return lerp(\n    getLimitValue(rep.numericRange!.min),\n    getLimitValue(rep.numericRange!.max),\n    normalized\n  );\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nexport function createRandomTexelView(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n}): TexelView {\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  const generator = (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(coords.x, coords.y, coords.z, component.charCodeAt(0));\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = getValueBetweenMinAndMaxTexelValueInclusive(rep, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(info.format as EncodableTextureFormat, generator);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nexport function createRandomTexelViewMipmap(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  dimension?: GPUTextureDimension;\n}): TexelView[] {\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  const size = reifyExtent3D(info.size);\n  const tSize = [size.width, size.height, size.depthOrArrayLayers] as const;\n  return range(mipLevelCount, i =>\n    createRandomTexelView({\n      format: info.format,\n      size: virtualMipSize(dimension, tSize, i),\n    })\n  );\n}\n\nexport type vec2 = [number, number];\nexport type vec3 = [number, number, number];\nexport type vec4 = [number, number, number, number];\nexport type Dimensionality = number | vec2 | vec3;\n\ntype TextureCallArgKeys = keyof TextureCallArgs<number>;\nconst kTextureCallArgNames: TextureCallArgKeys[] = [\n  'coords',\n  'mipLevel',\n  'arrayIndex',\n  'ddx',\n  'ddy',\n  'offset',\n];\n\nexport interface TextureCallArgs<T extends Dimensionality> {\n  coords?: T;\n  mipLevel?: number;\n  arrayIndex?: number;\n  ddx?: T;\n  ddy?: T;\n  offset?: T;\n}\n\nexport interface TextureCall<T extends Dimensionality> extends TextureCallArgs<T> {\n  builtin: 'textureSample' | 'textureLoad';\n  coordType: 'f';\n}\n\nfunction toArray(coords: Dimensionality): number[] {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel: PerTexelComponent<number>, repl: TexelRepresentationInfo) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a: number[], b: number[], op: (x: number, y: number) => number) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\nconst add = (a: number[], b: number[]) => apply(a, b, (x, y) => x + y);\n\nexport interface Texture {\n  texels: TexelView[];\n  descriptor: GPUTextureDescriptor;\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nexport function softwareTextureReadMipLevel<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  mipLevel = 0\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[texture.texels[mipLevel].format];\n  const tSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    [tSize.width, tSize.height, tSize.depthOrArrayLayers],\n    mipLevel\n  );\n  const addressMode = [\n    sampler.addressModeU ?? 'clamp-to-edge',\n    sampler.addressModeV ?? 'clamp-to-edge',\n    sampler.addressModeW ?? 'clamp-to-edge',\n  ];\n\n  const load = (at: number[]) =>\n    texture.texels[mipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0),\n    });\n\n  switch (call.builtin) {\n    case 'textureSample': {\n      const coords = toArray(call.coords!);\n\n      // convert normalized to absolute texel coordinate\n      // ┌───┬───┬───┬───┐\n      // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n      // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │ b │\n      // └───┴───┴───┴───┘\n      let at = coords.map((v, i) => v * textureSize[i] - 0.5);\n\n      // Apply offset in whole texel units\n      // This means the offset is added at each mip level in texels. There's no\n      // scaling for each level.\n      if (call.offset !== undefined) {\n        at = add(at, toArray(call.offset));\n      }\n\n      const samples: { at: number[]; weight: number }[] = [];\n\n      const filter = sampler.minFilter;\n      switch (filter) {\n        case 'linear': {\n          // 'p0' is the lower texel for 'at'\n          const p0 = at.map(v => Math.floor(v));\n          // 'p1' is the higher texel for 'at'\n          const p1 = p0.map(v => v + 1);\n\n          // interpolation weights for p0 and p1\n          const p1W = at.map((v, i) => v - p0[i]);\n          const p0W = p1W.map(v => 1 - v);\n\n          switch (coords.length) {\n            case 1:\n              samples.push({ at: p0, weight: p0W[0] });\n              samples.push({ at: p1, weight: p1W[0] });\n              break;\n            case 2: {\n              samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n              samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n              samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n              samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n              break;\n            }\n          }\n          break;\n        }\n        case 'nearest': {\n          const p = at.map(v => Math.round(quantizeToF32(v)));\n          samples.push({ at: p, weight: 1 });\n          break;\n        }\n        default:\n          unreachable();\n      }\n\n      const out: PerTexelComponent<number> = {};\n      const ss = [];\n      for (const sample of samples) {\n        // Apply sampler address mode\n        const c = sample.at.map((v, i) => {\n          switch (addressMode[i]) {\n            case 'clamp-to-edge':\n              return clamp(v, { min: 0, max: textureSize[i] - 1 });\n            case 'mirror-repeat': {\n              const n = Math.floor(v / textureSize[i]);\n              v = v - n * textureSize[i];\n              return (n & 1) !== 0 ? textureSize[i] - v - 1 : v;\n            }\n            case 'repeat':\n              return v - Math.floor(v / textureSize[i]) * textureSize[i];\n            default:\n              unreachable();\n          }\n        });\n        const v = load(c);\n        ss.push(v);\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * sample.weight;\n        }\n      }\n\n      return out;\n    }\n    case 'textureLoad': {\n      return load(toArray(call.coords!));\n    }\n  }\n}\n\n/**\n * The software version of a texture builtin (eg: textureSample)\n * Note that this is not a complete implementation. Rather it's only\n * what's needed to generate the correct expected value for the tests.\n */\nexport function softwareTextureRead<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  assert(call.ddx !== undefined);\n  assert(call.ddy !== undefined);\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  const texSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = [texSize.width, texSize.height];\n\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx: readonly number[] = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy: readonly number[] = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  // Compute the mip level the same way textureSampleGrad does\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  // MAINTENANCE_TODO: handle texture view baseMipLevel and mipLevelCount?\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n\n  const mipLevelCount = texture.texels.length;\n  const maxLevel = mipLevelCount - 1;\n\n  switch (sampler.mipmapFilter) {\n    case 'linear': {\n      const clampedMipLevel = clamp(mipLevel, { min: 0, max: maxLevel });\n      const baseMipLevel = Math.floor(clampedMipLevel);\n      const nextMipLevel = Math.ceil(clampedMipLevel);\n      const t0 = softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n      const t1 = softwareTextureReadMipLevel<T>(call, texture, sampler, nextMipLevel);\n      const mix = mipLevel % 1;\n      const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix },\n      ];\n      const out: PerTexelComponent<number> = {};\n      for (const { v, weight } of values) {\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * weight;\n        }\n      }\n      return out;\n    }\n    default: {\n      const baseMipLevel = Math.floor(\n        clamp(mipLevel + 0.5, { min: 0, max: texture.texels.length - 1 })\n      );\n      return softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n    }\n  }\n}\n\nexport type TextureTestOptions = {\n  ddx?: number; // the derivative we want at sample time\n  ddy?: number;\n  uvwStart?: readonly [number, number]; // the starting uv value (these are used make the coordinates negative as it uncovered issues on some hardware)\n  offset?: readonly [number, number]; // a constant offset\n};\n\n/**\n * Puts random data in a texture, generates a shader that implements `calls`\n * such that each call's result is written to the next consecutive texel of\n * a rgba32float texture. It then checks the result of each call matches\n * the expected result.\n */\nexport async function putDataInTextureThenDrawAndCheckResults<T extends Dimensionality>(\n  device: GPUDevice,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[]\n) {\n  const results = await doTextureCalls(device, texture, sampler, calls);\n  const errs: string[] = [];\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    const got = results[callIdx];\n    const expect = softwareTextureReadMipLevel(call, texture, sampler);\n\n    const gULP = rep.bitsToULPFromZero(rep.numberToBits(got));\n    const eULP = rep.bitsToULPFromZero(rep.numberToBits(expect));\n    for (const component of rep.componentOrder) {\n      const g = got[component]!;\n      const e = expect[component]!;\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n      const relDiff = absDiff / Math.max(Math.abs(g), Math.abs(e));\n      if (ulpDiff > 3 && relDiff > 0.03) {\n        const desc = describeTextureCall(call);\n        errs.push(`component was not as expected:\n      call: ${desc}\n component: ${component}\n       got: ${g}\n  expected: ${e}\n  abs diff: ${absDiff.toFixed(4)}\n  rel diff: ${(relDiff * 100).toFixed(2)}%\n  ulp diff: ${ulpDiff}\n  sample points:\n`);\n        const expectedSamplePoints = [\n          'expected:',\n          ...(await identifySamplePoints(texture.descriptor, (texels: TexelView) => {\n            return Promise.resolve(\n              softwareTextureReadMipLevel(\n                call,\n                { texels: [texels], descriptor: texture.descriptor },\n                sampler\n              )\n            );\n          })),\n        ];\n        const gotSamplePoints = [\n          'got:',\n          ...(await identifySamplePoints(\n            texture.descriptor,\n            async (texels: TexelView) =>\n              (\n                await doTextureCalls(\n                  device,\n                  { texels: [texels], descriptor: texture.descriptor },\n                  sampler,\n                  [call]\n                )\n              )[0]\n          )),\n        ];\n        errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n        errs.push('', '');\n      }\n    }\n  }\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\n/**\n * \"Renders a quad\" to a TexelView with the given parameters,\n * sampling from the given Texture.\n */\nexport function softwareRasterize<T extends Dimensionality>(\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  targetSize: [number, number],\n  options: TextureTestOptions\n) {\n  const [width, height] = targetSize;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0] } = options;\n  const format = 'rgba32float';\n\n  const textureSize = reifyExtent3D(texture.descriptor.size);\n\n  // MAINTENANCE_TODO: Consider passing these in as a similar computation\n  // happens in putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer.\n  // The issue is there, the calculation is \"what do we need to multiply the unitQuad\n  // by to get the derivatives we want\". The calculation here is \"what coordinate\n  // will we get for a given frag coordinate\". It turns out to be the same calculation\n  // but needs rephrasing them so they are more obviously the same would help\n  // consolidate them into one calculation.\n  const screenSpaceUMult = (ddx * width) / textureSize.width;\n  const screenSpaceVMult = (ddy * height) / textureSize.height;\n\n  const rep = kTexelRepresentationInfo[format];\n\n  const expData = new Float32Array(width * height * 4);\n  for (let y = 0; y < height; ++y) {\n    const fragY = height - y - 1 + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const fragX = x + 0.5;\n      // This code calculates the same value that will be passed to\n      // `textureSample` in the fragment shader for a given frag coord (see the\n      // WGSL code which uses the same formula, but using interpolation). That\n      // shader renders a clip space quad and includes a inter-stage \"uv\"\n      // coordinates that start with a unit quad (0,0) to (1,1) and is\n      // multiplied by ddx,ddy and as added in uStart and vStart\n      //\n      // uv = unitQuad * vec2(ddx, ddy) + vec2(vStart, uStart);\n      //\n      // softwareTextureRead<T> simulates a single call to `textureSample` so\n      // here we're computing the `uv` value that will be passed for a\n      // particular fragment coordinate. fragX / width, fragY / height provides\n      // the unitQuad value.\n      //\n      // ddx and ddy in this case are the derivative values we want to test. We\n      // pass those into the softwareTextureRead<T> as they would normally be\n      // derived from the change in coord.\n      const coords = [\n        (fragX / width) * screenSpaceUMult + uvwStart[0],\n        (fragY / height) * screenSpaceVMult + uvwStart[1],\n      ] as T;\n      const call: TextureCall<T> = {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        ddx: [ddx / textureSize.width, 0] as T,\n        ddy: [0, ddy / textureSize.height] as T,\n        offset: options.offset as T,\n      };\n      const sample = softwareTextureRead<T>(call, texture, sampler);\n      const rgba = { R: 0, G: 0, B: 0, A: 1, ...sample };\n      const asRgba32Float = new Float32Array(rep.pack(rgba));\n      expData.set(asRgba32Float, (y * width + x) * 4);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(format, new Uint8Array(expData.buffer), {\n    bytesPerRow: width * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: targetSize,\n  });\n}\n\n/**\n * Puts data in a texture. Renders a quad to a rgba32float. Then \"software renders\"\n * to a TexelView the expected result and compares the rendered texture to the\n * expected TexelView.\n */\nexport function putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer<\n  T extends Dimensionality,\n>(\n  t: GPUTest & TextureTestMixinType,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const device = t.device;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0, 0], offset } = options;\n\n  const format = 'rgba32float';\n  const renderTarget = device.createTexture({\n    format,\n    size: [32, 32],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  t.trackForCleanup(renderTarget);\n\n  const textureSize = reifyExtent3D(texture.descriptor.size);\n\n  // Compute the amount we need to multiply the unitQuad by get the\n  // derivatives we want.\n  const uMult = (ddx * renderTarget.width) / textureSize.width;\n  const vMult = (ddy * renderTarget.height) / textureSize.height;\n\n  const offsetWGSL = offset ? `, vec2i(${offset[0]},${offset[1]})` : '';\n\n  const code = `\nstruct InOut {\n  @builtin(position) pos: vec4f,\n  @location(0) uv: vec2f,\n};\n\n@vertex fn vs(@builtin(vertex_index) vertex_index : u32) -> InOut {\n  let positions = array(\n    vec2f(-1,  1), vec2f( 1,  1),\n    vec2f(-1, -1), vec2f( 1, -1),\n  );\n  let pos = positions[vertex_index];\n  return InOut(\n    vec4f(pos, 0, 1),\n    (pos * 0.5 + 0.5) * vec2f(${uMult}, ${vMult}) + vec2f(${uvwStart[0]}, ${uvwStart[1]}),\n  );\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n\n@fragment fn fs(v: InOut) -> @location(0) vec4f {\n  return textureSample(T, S, v.uv${offsetWGSL});\n}\n`;\n\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const gpuTexture = createTextureFromTexelViews(device, texture.texels, texture.descriptor);\n  t.trackForCleanup(gpuTexture);\n  const gpuSampler = device.createSampler(sampler);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: gpuTexture.createView() },\n      { binding: 1, resource: gpuSampler },\n    ],\n  });\n\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{ view: renderTarget.createView(), loadOp: 'clear', storeOp: 'store' }],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  device.queue.submit([encoder.finish()]);\n\n  const expTexelView = softwareRasterize<T>(\n    texture,\n    sampler,\n    [renderTarget.width, renderTarget.height],\n    options\n  );\n\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  let maxFractionalDiff = 0;\n  if (texture.descriptor.format.includes('8unorm')) {\n    maxFractionalDiff = 7 / 255;\n  } else if (texture.descriptor.format.includes('8snorm')) {\n    maxFractionalDiff = 7.9 / 128;\n  } else if (texture.descriptor.format.includes('2unorm')) {\n    maxFractionalDiff = 9 / 512;\n  } else if (texture.descriptor.format.endsWith('ufloat')) {\n    maxFractionalDiff = 156.249;\n  } else if (texture.descriptor.format.endsWith('float')) {\n    maxFractionalDiff = 44;\n  } else {\n    unreachable();\n  }\n\n  t.expectTexelViewComparisonIsOkInTexture(\n    { texture: renderTarget },\n    expTexelView,\n    [renderTarget.width, renderTarget.height],\n    { maxFractionalDiff }\n  );\n}\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   ┌───┬───┬───┬───┬───┬───┬───┬───┐\n * 0 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 1 │   │   │   │   │   │   │   │ a │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 2 │   │   │   │   │   │   │   │ b │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 3 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 4 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 5 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 6 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 7 │   │   │   │   │   │   │   │   │\n *   └───┴───┴───┴───┴───┴───┴───┴───┘\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints(\n  info: GPUTextureDescriptor,\n  run: (texels: TexelView) => Promise<PerTexelComponent<number>>\n) {\n  const textureSize = reifyExtent3D(info.size);\n  const numTexels = textureSize.width * textureSize.height;\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map<number, PerTexelComponent<number>>();\n  const unclassifiedStack = [new Set<number>(range(numTexels, v => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop()!;\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set<number>();\n    const setB = new Set<number>();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.\n    const results = await run(\n      TexelView.fromTexelsAsColors(\n        info.format as EncodableTextureFormat,\n        (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n          const isCandidate = setA.has(coords.x + coords.y * textureSize.width);\n          const texel: PerTexelComponent<number> = {};\n          for (const component of rep.componentOrder) {\n            texel[component] = isCandidate ? 1 : 0;\n          }\n          return texel;\n        }\n      )\n    );\n    if (rep.componentOrder.some(c => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach(texel => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  // ┌───┬───┬───┬───┐\n  // │ a │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │ b │\n  // └───┴───┴───┴───┘\n  const letter = (idx: number) => String.fromCharCode(97 + idx); // 97: 'a'\n  const orderedTexelIndices: number[] = [];\n  const lines: string[] = [];\n  {\n    let line = '  ';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += `  ${x} `;\n    }\n    lines.push(line);\n  }\n  {\n    let line = '  ┌';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += x === textureSize.width - 1 ? '───┐' : '───┬';\n    }\n    lines.push(line);\n  }\n  for (let y = 0; y < textureSize.height; y++) {\n    {\n      let line = `${y} │`;\n      for (let x = 0; x < textureSize.width; x++) {\n        const texelIdx = x + y * textureSize.height;\n        const weight = sampledTexelWeights.get(texelIdx);\n        if (weight !== undefined) {\n          line += ` ${letter(orderedTexelIndices.length)} │`;\n          orderedTexelIndices.push(texelIdx);\n        } else {\n          line += '   │';\n        }\n      }\n      lines.push(line);\n    }\n    if (y < textureSize.height - 1) {\n      let line = '  ├';\n      for (let x = 0; x < textureSize.width; x++) {\n        line += x === textureSize.width - 1 ? '───┤' : '───┼';\n      }\n      lines.push(line);\n    }\n  }\n  {\n    let line = '  └';\n    for (let x = 0; x < textureSize.width; x++) {\n      line += x === textureSize.width - 1 ? '───┘' : '───┴';\n    }\n    lines.push(line);\n  }\n\n  orderedTexelIndices.forEach((texelIdx, i) => {\n    const weights = sampledTexelWeights.get(texelIdx)!;\n    const y = Math.floor(texelIdx / textureSize.width);\n    const x = texelIdx - y * textureSize.height;\n    const w = rep.componentOrder.map(c => `${c}: ${weights[c]?.toFixed(5)}`).join(', ');\n    lines.push(`${letter(i)}: at: [${x}, ${y}], weights: [${w}]`);\n  });\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA: string[], columnB: string[]) {\n  const widthA = Math.max(...columnA.map(l => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out: string[] = new Array<string>(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'] as const;\nexport type SamplePointMethods = (typeof kSamplePointMethods)[number];\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nexport function generateSamplePoints(\n  n: number,\n  nearest: boolean,\n  args:\n    | {\n        method: 'texel-centre';\n        textureWidth: number;\n        textureHeight: number;\n      }\n    | {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n        textureWidth: number;\n        textureHeight: number;\n      }\n) {\n  const out: vec2[] = [];\n  switch (args.method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const x = Math.floor(lerp(0, args.textureWidth - 1, (r & 0xffff) / 0xffff)) + 0.5;\n        const y = Math.floor(lerp(0, args.textureHeight - 1, (r >>> 16) / 0xffff)) + 0.5;\n        out.push([x / args.textureWidth, y / args.textureHeight]);\n      }\n      break;\n    }\n    case 'spiral': {\n      for (let i = 0; i < n; i++) {\n        const f = i / (Math.max(n, 2) - 1);\n        const r = (args.radius ?? 1.5) * f;\n        const a = (args.loops ?? 2) * 2 * Math.PI * f;\n        out.push([0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a)]);\n      }\n      break;\n    }\n  }\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n  const q = [args.textureWidth * kSubdivisionsPerTexel, args.textureHeight * kSubdivisionsPerTexel];\n  return out.map(\n    c =>\n      c.map((v, i) => {\n        // Quantize to kSubdivisionsPerPixel\n        const v1 = Math.floor(v * q[i]);\n        // If it's nearest and we're on the edge of a texel then move us off the edge\n        // since the edge could choose one texel or another in nearest mode\n        const v2 = nearest && v1 % kSubdivisionsPerTexel === 0 ? v1 + 1 : v1;\n        // Convert back to texture coords\n        return v2 / q[i];\n      }) as vec2\n  );\n}\n\nfunction wgslTypeFor(data: Dimensionality, type: 'f' | 'i' | 'u'): string {\n  if (data instanceof Array) {\n    switch (data.length) {\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n    }\n  }\n  return '${type}32';\n}\n\nfunction wgslExpr(data: number | vec2 | vec3 | vec4): string {\n  if (data instanceof Array) {\n    switch (data.length) {\n      case 2:\n        return `vec2(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map(v => v.toString()).join(', ')})`;\n    }\n  }\n  return data.toString();\n}\n\nfunction binKey<T extends Dimensionality>(call: TextureCall<T>): string {\n  const keys: string[] = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        // offset must be a constant expression\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls<T extends Dimensionality>(calls: TextureCall<T>[]) {\n  const args: string[] = ['T']; // All texture builtins take the texture as the first argument\n  const fields: string[] = [];\n  const data: number[] = [];\n\n  const prototype = calls[0];\n  if (prototype.builtin.startsWith('textureSample')) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else {\n        args.push(`args.${name}`);\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, prototype.coordType)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        (prototype[name] === undefined) === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset') {\n        const bitcastToU32 = (value: number) => {\n          if (calls[0].coordType === 'f') {\n            return float32ToUint32(value);\n          }\n          return value;\n        };\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls<T extends Dimensionality>(calls: TextureCall<T>[]): number[][] {\n  const map = new Map<string, number>(); // key to bin index\n  const bins: number[][] = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nexport function describeTextureCall<T extends Dimensionality>(call: TextureCall<T>): string {\n  const args: string[] = ['texture: T'];\n  if (call.builtin.startsWith('textureSample')) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      args.push(`${name}: ${wgslExpr(value)}`);\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the fragment position as an index\n * (position.y * 256 + position.x) That index is then used to look up a\n * coordinate from a storage buffer which is used to call the WGSL texture\n * function to read/sample the texture, and then write to an rgba32float\n * texture.  We then read the rgba32float texture for the per \"call\" results.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n */\nexport async function doTextureCalls<T extends Dimensionality>(\n  device: GPUDevice,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[]\n) {\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data: number[] = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map(callIdx => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',  \\n')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (frag_idx >= ${callCount}) & (frag_idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[frag_idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = device.createBuffer({\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const rtWidth = 256;\n  const renderTarget = device.createTexture({\n    format: 'rgba32float',\n    size: { width: rtWidth, height: Math.ceil(calls.length / rtWidth) },\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertex_index : u32) -> @builtin(position) vec4f {\n  let positions = array(\n    vec4f(-1,  1, 0, 1), vec4f( 1,  1, 0, 1),\n    vec4f(-1, -1, 0, 1), vec4f( 1, -1, 0, 1),\n  );\n  return positions[vertex_index];\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n@group(0) @binding(2) var<storage> data : Data;\n\n@fragment\nfn fs_main(@builtin(position) frag_pos : vec4f) -> @location(0) vec4f {\n  let frag_idx = u32(frag_pos.x) + u32(frag_pos.y) * ${renderTarget.width};\n  var result : vec4f;\n${body}\n  return result;\n}\n`;\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format: renderTarget.format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const gpuTexture = createTextureFromTexelView(device, texture.texels[0], texture.descriptor);\n  const gpuSampler = device.createSampler(sampler);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: gpuTexture.createView() },\n      { binding: 1, resource: gpuSampler },\n      { binding: 2, resource: { buffer: dataBuffer } },\n    ],\n  });\n\n  const bytesPerRow = align(16 * renderTarget.width, 256);\n  const resultBuffer = device.createBuffer({\n    size: renderTarget.height * bytesPerRow,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{ view: renderTarget.createView(), loadOp: 'clear', storeOp: 'store' }],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  encoder.copyTextureToBuffer(\n    { texture: renderTarget },\n    { buffer: resultBuffer, bytesPerRow },\n    { width: renderTarget.width, height: renderTarget.height }\n  );\n  device.queue.submit([encoder.finish()]);\n\n  await resultBuffer.mapAsync(GPUMapMode.READ);\n\n  const view = TexelView.fromTextureDataByReference(\n    renderTarget.format as EncodableTextureFormat,\n    new Uint8Array(resultBuffer.getMappedRange()),\n    {\n      bytesPerRow,\n      rowsPerImage: renderTarget.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [renderTarget.width, renderTarget.height],\n    }\n  );\n\n  let outIdx = 0;\n  const out = new Array<PerTexelComponent<number>>(calls.length);\n  for (const bin of binned) {\n    for (const callIdx of bin) {\n      const x = outIdx % rtWidth;\n      const y = Math.floor(outIdx / rtWidth);\n      out[callIdx] = view.color({ x, y, z: 0 });\n      outIdx++;\n    }\n  }\n\n  renderTarget.destroy();\n  gpuTexture.destroy();\n  resultBuffer.destroy();\n\n  return out;\n}\n"],"mappings":"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"}
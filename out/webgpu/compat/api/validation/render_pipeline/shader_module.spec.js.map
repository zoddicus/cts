{"version":3,"file":"shader_module.spec.js","names":["description","makeTestGroup","CompatibilityTest","g","test","desc","params","u","combine","fn","t","entryPoint","module","device","createShaderModule","code","pipelineDescriptor","layout","vertex","fragment","targets","format","multisample","count","isValid","expectGPUError","createRenderPipeline"],"sources":["../../../../../../src/webgpu/compat/api/validation/render_pipeline/shader_module.spec.ts"],"sourcesContent":["export const description = `\nTests limitations of createRenderPipeline related to shader modules in compat mode.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { CompatibilityTest } from '../../../compatibility_test.js';\n\nexport const g = makeTestGroup(CompatibilityTest);\n\ng.test('sample_mask')\n  .desc(\n    `\nTests that you can not create a render pipeline with a shader module that uses sample_mask in compat mode.\n\n- Test that a pipeline with a shader that uses sample_mask fails.\n- Test that a pipeline that references a module that has a shader that uses sample_mask\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u.combine('entryPoint', ['fsWithoutSampleMaskUsage', 'fsWithSampleMaskUsage'] as const)\n  )\n  .fn(t => {\n    const { entryPoint } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n       @vertex fn vs() -> @builtin(position) vec4f {\n            return vec4f(1);\n        }\n        struct Output {\n            @builtin(sample_mask) mask_out: u32,\n            @location(0) color : vec4f,\n        }\n        @fragment fn fsWithoutSampleMaskUsage() -> @location(0) vec4f {\n            return vec4f(1.0, 1.0, 1.0, 1.0);\n        }\n        @fragment fn fsWithSampleMaskUsage() -> Output {\n            var o: Output;\n            // We need to make sure this sample_mask isn't optimized out even if its value equals \"no op\".\n            o.mask_out = 0xFFFFFFFFu;\n            o.color = vec4f(1.0, 1.0, 1.0, 1.0);\n            return o;\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n      multisample: {\n        count: 4,\n      },\n    };\n\n    const isValid = entryPoint === 'fsWithoutSampleMaskUsage';\n    t.expectGPUError(\n      'validation',\n      () => t.device.createRenderPipeline(pipelineDescriptor),\n      !isValid\n    );\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,+CAA+C;AAC7E,SAASC,iBAAiB,QAAQ,gCAAgC;;AAElE,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,iBAAiB,CAAC;;AAEjDC,CAAC,CAACC,IAAI,CAAC,aAAa,CAAC;AAClBC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC,CAACC,OAAO,CAAC,YAAY,EAAE,CAAC,0BAA0B,EAAE,uBAAuB,CAAU;AACxF,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEC,UAAU,CAAC,CAAC,GAAGD,CAAC,CAACJ,MAAM;;EAE/B,MAAMM,MAAM,GAAGF,CAAC,CAACG,MAAM,CAACC,kBAAkB,CAAC;IACzCC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;;EAEF,MAAMC,kBAA+C,GAAG;IACtDC,MAAM,EAAE,MAAM;IACdC,MAAM,EAAE;MACNN,MAAM;MACND,UAAU,EAAE;IACd,CAAC;IACDQ,QAAQ,EAAE;MACRP,MAAM;MACND,UAAU;MACVS,OAAO,EAAE;MACP;QACEC,MAAM,EAAE;MACV,CAAC;;IAEL,CAAC;IACDC,WAAW,EAAE;MACXC,KAAK,EAAE;IACT;EACF,CAAC;;EAED,MAAMC,OAAO,GAAGb,UAAU,KAAK,0BAA0B;EACzDD,CAAC,CAACe,cAAc;IACd,YAAY;IACZ,MAAMf,CAAC,CAACG,MAAM,CAACa,oBAAoB,CAACV,kBAAkB,CAAC;IACvD,CAACQ;EACH,CAAC;AACH,CAAC,CAAC"}
{"version":3,"file":"shader_module.spec.js","names":["description","makeTestGroup","kCompatModeUnsupportedStorageTextureFormats","CompatibilityTest","g","test","desc","params","u","combine","fn","t","entryPoint","module","device","createShaderModule","code","pipelineDescriptor","layout","vertex","fragment","targets","format","multisample","count","isValid","expectGPUError","createRenderPipeline","interpolate","async","compute","doCreateComputePipelineTest","doCreateRenderPipelineTest"],"sources":["../../../../../../src/webgpu/compat/api/validation/render_pipeline/shader_module.spec.ts"],"sourcesContent":["export const description = `\nTests limitations of createRenderPipeline related to shader modules in compat mode.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { kCompatModeUnsupportedStorageTextureFormats } from '../../../../format_info.js';\nimport { CompatibilityTest } from '../../../compatibility_test.js';\n\nexport const g = makeTestGroup(CompatibilityTest);\n\ng.test('sample_mask')\n  .desc(\n    `\nTests that you can not create a render pipeline with a shader module that uses sample_mask in compat mode.\n\n- Test that a pipeline with a shader that uses sample_mask fails.\n- Test that a pipeline that references a module that has a shader that uses sample_mask\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u.combine('entryPoint', ['fsWithoutSampleMaskUsage', 'fsWithSampleMaskUsage'] as const)\n  )\n  .fn(t => {\n    const { entryPoint } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n       @vertex fn vs() -> @builtin(position) vec4f {\n            return vec4f(1);\n        }\n        struct Output {\n            @builtin(sample_mask) mask_out: u32,\n            @location(0) color : vec4f,\n        }\n        @fragment fn fsWithoutSampleMaskUsage() -> @location(0) vec4f {\n            return vec4f(1.0, 1.0, 1.0, 1.0);\n        }\n        @fragment fn fsWithSampleMaskUsage() -> Output {\n            var o: Output;\n            // We need to make sure this sample_mask isn't optimized out even if its value equals \"no op\".\n            o.mask_out = 0xFFFFFFFFu;\n            o.color = vec4f(1.0, 1.0, 1.0, 1.0);\n            return o;\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n      multisample: {\n        count: 4,\n      },\n    };\n\n    const isValid = entryPoint === 'fsWithoutSampleMaskUsage';\n    t.expectGPUError(\n      'validation',\n      () => t.device.createRenderPipeline(pipelineDescriptor),\n      !isValid\n    );\n  });\n\ng.test('sample_index')\n  .desc(\n    `\nTests that you can not create a render pipeline with a shader module that uses sample_index in compat mode.\n\n- Test that a pipeline with a shader that uses sample_index fails.\n- Test that a pipeline that references a module that has a shader that uses sample_index\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u.combine('entryPoint', ['fsWithoutSampleIndexUsage', 'fsWithSampleIndexUsage'] as const)\n  )\n  .fn(t => {\n    const { entryPoint } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @vertex fn vs() -> @builtin(position) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithoutSampleIndexUsage() -> @location(0) vec4f {\n            return vec4f(0);\n        }\n        @fragment fn fsWithSampleIndexUsage(@builtin(sample_index) sampleIndex: u32) -> @location(0) vec4f {\n            _ = sampleIndex;\n            return vec4f(0);\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n      multisample: {\n        count: 4,\n      },\n    };\n\n    const isValid = entryPoint === 'fsWithoutSampleIndexUsage';\n    t.expectGPUError(\n      'validation',\n      () => t.device.createRenderPipeline(pipelineDescriptor),\n      !isValid\n    );\n  });\n\ng.test('interpolate')\n  .desc(\n    `\nTests that you can not create a render pipeline with a shader module that uses interpolate(linear) nor interpolate(...,sample) in compat mode.\n\n- Test that a pipeline with a shader that uses interpolate(linear) or interpolate(sample) fails.\n- Test that a pipeline that references a module that has a shader that uses interpolate(linear/sample)\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u\n      .combine('interpolate', [\n        '',\n        '@interpolate(linear)',\n        '@interpolate(linear, sample)',\n        '@interpolate(perspective, sample)',\n      ] as const)\n      .combine('entryPoint', [\n        'fsWithoutInterpolationUsage',\n        'fsWithInterpolationUsage1',\n        'fsWithInterpolationUsage2',\n        'fsWithInterpolationUsage3',\n      ] as const)\n  )\n  .fn(t => {\n    const { entryPoint, interpolate } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        struct Vertex {\n            @builtin(position) pos: vec4f,\n            @location(0) ${interpolate} color : vec4f,\n        };\n        @vertex fn vs() -> Vertex {\n            var v: Vertex;\n            v.pos = vec4f(1);\n            v.color = vec4f(1);\n            return v;\n        }\n        @fragment fn fsWithoutInterpolationUsage() -> @location(0) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithInterpolationUsage1(v: Vertex) -> @location(0) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithInterpolationUsage2(v: Vertex) -> @location(0) vec4f {\n            return v.pos;\n        }\n        @fragment fn fsWithInterpolationUsage3(v: Vertex) -> @location(0) vec4f {\n            return v.color;\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n    };\n\n    const isValid = entryPoint === 'fsWithoutInterpolationUsage' || interpolate === '';\n    t.expectGPUError(\n      'validation',\n      () => t.device.createRenderPipeline(pipelineDescriptor),\n      !isValid\n    );\n  });\n\ng.test('unsupportedStorageTextureFormats,computePipeline')\n  .desc(\n    `\nTests that you can not create a compute pipeline with unsupported storage texture formats in compat mode.\n    `\n  )\n  .params(u =>\n    u //\n      .combine('format', kCompatModeUnsupportedStorageTextureFormats)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { format, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var s: texture_storage_2d<${format}, read>;\n        @compute @workgroup_size(1) fn cs() {\n            _ = textureLoad(s, vec2u(0));\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPUComputePipelineDescriptor = {\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'cs',\n      },\n    };\n    t.doCreateComputePipelineTest(async, false, pipelineDescriptor);\n  });\n\ng.test('unsupportedStorageTextureFormats,renderPipeline')\n  .desc(\n    `\nTests that you can not create a render pipeline with unsupported storage texture formats in compat mode.\n    `\n  )\n  .params(u =>\n    u //\n      .combine('format', kCompatModeUnsupportedStorageTextureFormats)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { format, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var s: texture_storage_2d<${format}, read>;\n        @vertex fn vs() -> @builtin(position) vec4f {\n            _ = textureLoad(s, vec2u(0));\n            return vec4f(0);\n        }\n      `,\n    });\n\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n    };\n    t.doCreateRenderPipelineTest(async, false, pipelineDescriptor);\n  });\n"],"mappings":"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"}
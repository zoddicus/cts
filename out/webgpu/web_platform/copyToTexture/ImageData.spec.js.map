{"version":3,"file":"ImageData.spec.js","names":["description","makeTestGroup","kTextureFormatInfo","kValidTextureFormatsForCopyE2T","CopyToTextureUtils","kCopySubrectInfo","kTestColorsAll","makeTestColorsTexelView","g","test","desc","params","u","combine","beginSubcases","beforeAllSubcases","t","skipIfTextureFormatNotSupported","dstColorFormat","fn","width","height","dstPremultiplied","srcDoFlipYDuringCopy","testColors","texelViewSource","format","flipY","premultiplied","imageData","ImageData","writeTextureData","data","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","dst","device","createTexture","size","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","expFormat","baseFormat","flipSrcBeforeCopy","texelViewExpected","getExpectedDstPixelsFromSrcPixels","srcPixels","srcOrigin","srcSize","dstOrigin","dstSize","subRectSize","conversion","srcPremultiplied","doTestAndCheckResult","source","origin","x","y","texture","colorSpace","premultipliedAlpha","depthOrArrayLayers","maxDiffULPsForFloatFormat","maxDiffULPsForNormFormat","copySubRectInfo","copyExtent","kColorFormat"],"sources":["../../../../src/webgpu/web_platform/copyToTexture/ImageData.spec.ts"],"sourcesContent":["export const description = `\ncopyExternalImageToTexture from ImageData source.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { kTextureFormatInfo, kValidTextureFormatsForCopyE2T } from '../../format_info.js';\nimport { CopyToTextureUtils, kCopySubrectInfo } from '../../util/copy_to_texture.js';\n\nimport { kTestColorsAll, makeTestColorsTexelView } from './util.js';\n\nexport const g = makeTestGroup(CopyToTextureUtils);\n\ng.test('from_ImageData')\n  .desc(\n    `\n  Test ImageData can be copied to WebGPU\n  texture correctly. These imageDatas are highly possible living\n  in CPU back resource.\n\n  It generates pixels in ImageData one by one based on a color list:\n  [Red, Green, Blue, Black, White, SemitransparentWhite].\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the ImageData contents.\n\n  Expect alpha to get premultiplied in the copy if, and only if, 'premultipliedAlpha'\n  in 'GPUImageCopyTextureTagged' is set to 'true'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped.\n\n  The tests covers:\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage' (named 'srcDoFlipYDuringCopy' in cases)\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('dstPremultiplied', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15, 255, 256])\n      .combine('height', [1, 2, 4, 15, 255, 256])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n  })\n  .fn(t => {\n    const { width, height, dstColorFormat, dstPremultiplied, srcDoFlipYDuringCopy } = t.params;\n\n    const testColors = kTestColorsAll;\n\n    // Generate correct expected values\n    const texelViewSource = makeTestColorsTexelView({\n      testColors,\n      format: 'rgba8unorm', // ImageData is always in rgba8unorm format.\n      width,\n      height,\n      flipY: false,\n      premultiplied: false,\n    });\n    const imageData = new ImageData(width, height);\n    texelViewSource.writeTextureData(imageData.data, {\n      bytesPerRow: width * 4,\n      rowsPerImage: height,\n      subrectOrigin: [0, 0],\n      subrectSize: { width, height },\n    });\n\n    const dst = t.device.createTexture({\n      size: { width, height },\n      format: dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const expFormat = kTextureFormatInfo[dstColorFormat].baseFormat ?? dstColorFormat;\n    const flipSrcBeforeCopy = false;\n    const texelViewExpected = t.getExpectedDstPixelsFromSrcPixels({\n      srcPixels: imageData.data,\n      srcOrigin: [0, 0],\n      srcSize: [width, height],\n      dstOrigin: [0, 0],\n      dstSize: [width, height],\n      subRectSize: [width, height],\n      format: expFormat,\n      flipSrcBeforeCopy,\n      srcDoFlipYDuringCopy,\n      conversion: {\n        srcPremultiplied: false,\n        dstPremultiplied,\n      },\n    });\n\n    t.doTestAndCheckResult(\n      {\n        source: imageData,\n        origin: { x: 0, y: 0 },\n        flipY: srcDoFlipYDuringCopy,\n      },\n      {\n        texture: dst,\n        origin: { x: 0, y: 0 },\n        colorSpace: 'srgb',\n        premultipliedAlpha: dstPremultiplied,\n      },\n      texelViewExpected,\n      { width, height, depthOrArrayLayers: 1 },\n      // 1.0 and 0.6 are representable precisely by all formats except rgb10a2unorm, but\n      // allow diffs of 1ULP since that's the generally-appropriate threshold.\n      { maxDiffULPsForFloatFormat: 1, maxDiffULPsForNormFormat: 1 }\n    );\n  });\n\ng.test('copy_subrect_from_ImageData')\n  .desc(\n    `\n  Test ImageData can be copied to WebGPU\n  texture correctly. These imageDatas are highly possible living in CPU back resource.\n\n  It generates pixels in ImageData one by one based on a color list:\n  [Red, Green, Blue, Black, White].\n\n  Then call copyExternalImageToTexture() to do a subrect copy, based on a predefined copy\n  rect info list, to the 0 mipLevel of dst texture, and read the contents out to compare\n  with the ImageBitmap contents.\n\n  Expect alpha to get premultiplied in the copy if, and only if, 'premultipliedAlpha'\n  in 'GPUImageCopyTextureTagged' is set to 'true'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped, and origin is top-left consistantly.\n\n  The tests covers:\n  - Source WebGPU Canvas lives in the same GPUDevice or different GPUDevice as test\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage' (named 'srcDoFlipYDuringCopy' in cases)\n  - Valid subrect copies.\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .combine('dstPremultiplied', [true, false])\n      .beginSubcases()\n      .combine('copySubRectInfo', kCopySubrectInfo)\n  )\n  .fn(t => {\n    const { copySubRectInfo, dstPremultiplied, srcDoFlipYDuringCopy } = t.params;\n\n    const testColors = kTestColorsAll;\n    const { srcOrigin, dstOrigin, srcSize, dstSize, copyExtent } = copySubRectInfo;\n    const kColorFormat = 'rgba8unorm';\n\n    // Generate correct expected values\n    const texelViewSource = makeTestColorsTexelView({\n      testColors,\n      format: kColorFormat, // ImageData is always in rgba8unorm format.\n      width: srcSize.width,\n      height: srcSize.height,\n      flipY: false,\n      premultiplied: false,\n    });\n    const imageData = new ImageData(srcSize.width, srcSize.height);\n    texelViewSource.writeTextureData(imageData.data, {\n      bytesPerRow: srcSize.width * 4,\n      rowsPerImage: srcSize.height,\n      subrectOrigin: [0, 0],\n      subrectSize: srcSize,\n    });\n\n    const dst = t.device.createTexture({\n      size: dstSize,\n      format: kColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const flipSrcBeforeCopy = false;\n    const texelViewExpected = t.getExpectedDstPixelsFromSrcPixels({\n      srcPixels: imageData.data,\n      srcOrigin,\n      srcSize,\n      dstOrigin,\n      dstSize,\n      subRectSize: copyExtent,\n      format: kColorFormat,\n      flipSrcBeforeCopy,\n      srcDoFlipYDuringCopy,\n      conversion: {\n        srcPremultiplied: false,\n        dstPremultiplied,\n      },\n    });\n\n    t.doTestAndCheckResult(\n      {\n        source: imageData,\n        origin: srcOrigin,\n        flipY: srcDoFlipYDuringCopy,\n      },\n      {\n        texture: dst,\n        origin: dstOrigin,\n        colorSpace: 'srgb',\n        premultipliedAlpha: dstPremultiplied,\n      },\n      texelViewExpected,\n      copyExtent,\n      // 1.0 and 0.6 are representable precisely by all formats except rgb10a2unorm, but\n      // allow diffs of 1ULP since that's the generally-appropriate threshold.\n      { maxDiffULPsForFloatFormat: 1, maxDiffULPsForNormFormat: 1 }\n    );\n  });\n"],"mappings":"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"}
{"version":3,"file":"params_builder.js","names":["mergeParams","mergeParamsChecked","comparePublicParamsPaths","Ordering","stringifyPublicParams","assert","mapLazy","objectEquals","ParamsBuilderBase","constructor","cases","builderIterateCasesWithSubcases","builder","caseFilter","iterateCasesWithSubcases","CaseParamsBuilder","caseP","ordering","StrictSuperset","Unordered","undefined","Symbol","iterator","expandWithParams","expander","baseGenerator","a","b","kvPairs","Object","entries","some","k","v","expand","key","JSON","stringify","combineWithParams","newParams","assertNotGenerator","seenValues","Set","params","paramsStr","has","add","combine","values","mapped","filter","pred","unless","x","beginSubcases","SubcaseParamsBuilder","kUnitCaseParamsBuilder","generator","subcases","Array","from","length","base","before"],"sources":["../../../src/common/framework/params_builder.ts"],"sourcesContent":["import { Merged, mergeParams, mergeParamsChecked } from '../internal/params_utils.js';\nimport { comparePublicParamsPaths, Ordering } from '../internal/query/compare.js';\nimport { stringifyPublicParams } from '../internal/query/stringify_params.js';\nimport { DeepReadonly } from '../util/types.js';\nimport { assert, mapLazy, objectEquals } from '../util/util.js';\n\nimport { TestParams } from './fixture.js';\n\n// ================================================================\n// \"Public\" ParamsBuilder API / Documentation\n// ================================================================\n\n/**\n * Provides doc comments for the methods of CaseParamsBuilder and SubcaseParamsBuilder.\n * (Also enforces rough interface match between them.)\n */\nexport interface ParamsBuilder {\n  /**\n   * Expands each item in `this` into zero or more items.\n   * Each item has its parameters expanded with those returned by the `expander`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `expand` for readability.\n   *\n   * ```text\n   *               this = [     a       ,      b     ,       c       ]\n   * this.map(expander) = [   f(a)           f(b)          f(c)      ]\n   *                    = [[a1, a2, a3] ,    [ b1 ]  ,       []      ]\n   *  merge and flatten = [ merge(a, a1), merge(a, a2), merge(a, a3), merge(b, b1) ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expandWithParams(expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` into zero or more items. Each item has its parameters expanded\n   * with one new key, `key`, and the values returned by `expander`.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expand(key: string, expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` to multiple items, one for each item in `newParams`.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ] and `newParams`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `combine` for readability.\n   *\n   * ```text\n   *                     this = [ {a:1}, {b:2} ]\n   *                newParams = [ {x:1}, {y:2} ]\n   * this.combineP(newParams) = [ {a:1,x:1}, {a:1,y:2}, {b:2,x:1}, {b:2,y:2} ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combineWithParams(newParams: Iterable<any>): any;\n\n  /**\n   * Expands each item in `this` to multiple items with `{ [name]: value }` for each value.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ]\n   * and `[ {[name]: value} for each value in values ]`\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combine(key: string, newParams: Iterable<any>): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns true.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  filter(pred: (_: any) => boolean): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns false.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  unless(pred: (_: any) => boolean): any;\n}\n\n/**\n * Determines the resulting parameter object type which would be generated by an object of\n * the given ParamsBuilder type.\n */\nexport type ParamTypeOf<\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  T extends ParamsBuilder,\n> = T extends SubcaseParamsBuilder<infer CaseP, infer SubcaseP>\n  ? Merged<CaseP, SubcaseP>\n  : T extends CaseParamsBuilder<infer CaseP>\n  ? CaseP\n  : never;\n\n// ================================================================\n// Implementation\n// ================================================================\n\n/**\n * Iterable over pairs of either:\n * - `[case params, Iterable<subcase params>]` if there are subcases.\n * - `[case params, undefined]` if not.\n */\nexport type CaseSubcaseIterable<CaseP, SubcaseP> = Iterable<\n  readonly [DeepReadonly<CaseP>, Iterable<DeepReadonly<SubcaseP>> | undefined]\n>;\n\n/**\n * Base class for `CaseParamsBuilder` and `SubcaseParamsBuilder`.\n */\nexport abstract class ParamsBuilderBase<CaseP extends {}, SubcaseP extends {}> {\n  protected readonly cases: (caseFilter: TestParams | null) => Generator<CaseP>;\n\n  constructor(cases: (caseFilter: TestParams | null) => Generator<CaseP>) {\n    this.cases = cases;\n  }\n\n  /**\n   * Hidden from test files. Use `builderIterateCasesWithSubcases` to access this.\n   */\n  protected abstract iterateCasesWithSubcases(\n    caseFilter: TestParams | null\n  ): CaseSubcaseIterable<CaseP, SubcaseP>;\n}\n\n/**\n * Calls the (normally hidden) `iterateCasesWithSubcases()` method.\n */\nexport function builderIterateCasesWithSubcases(\n  builder: ParamsBuilderBase<{}, {}>,\n  caseFilter: TestParams | null\n) {\n  interface IterableParamsBuilder {\n    iterateCasesWithSubcases(caseFilter: TestParams | null): CaseSubcaseIterable<{}, {}>;\n  }\n\n  return (builder as unknown as IterableParamsBuilder).iterateCasesWithSubcases(caseFilter);\n}\n\n/**\n * Builder for combinatorial test **case** parameters.\n *\n * CaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of cases according to the method called.\n *\n * This means, for example, that the `unit` passed into `TestBuilder.params()` can be reused.\n */\nexport class CaseParamsBuilder<CaseP extends {}>\n  extends ParamsBuilderBase<CaseP, {}>\n  implements Iterable<DeepReadonly<CaseP>>, ParamsBuilder\n{\n  *iterateCasesWithSubcases(caseFilter: TestParams | null): CaseSubcaseIterable<CaseP, {}> {\n    for (const caseP of this.cases(caseFilter)) {\n      if (caseFilter) {\n        // this.cases() only filters out cases which conflict with caseFilter. Now that we have\n        // the final caseP, filter out cases which are missing keys that caseFilter requires.\n        const ordering = comparePublicParamsPaths(caseP, caseFilter);\n        if (ordering === Ordering.StrictSuperset || ordering === Ordering.Unordered) {\n          continue;\n        }\n      }\n\n      yield [caseP as DeepReadonly<typeof caseP>, undefined];\n    }\n  }\n\n  [Symbol.iterator](): Iterator<DeepReadonly<CaseP>> {\n    return this.cases(null) as Iterator<DeepReadonly<CaseP>>;\n  }\n\n  /** @inheritDoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: CaseP) => Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    const baseGenerator = this.cases;\n    return new CaseParamsBuilder(function* (caseFilter) {\n      for (const a of baseGenerator(caseFilter)) {\n        for (const b of expander(a)) {\n          if (caseFilter) {\n            // If the expander generated any key-value pair that conflicts with caseFilter, skip.\n            const kvPairs = Object.entries(b);\n            if (kvPairs.some(([k, v]) => k in caseFilter && !objectEquals(caseFilter[k], v))) {\n              continue;\n            }\n          }\n\n          yield mergeParamsChecked(a, b);\n        }\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: CaseP) => Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    const baseGenerator = this.cases;\n    return new CaseParamsBuilder(function* (caseFilter) {\n      for (const a of baseGenerator(caseFilter)) {\n        assert(!(key in a), `New key '${key}' already exists in ${JSON.stringify(a)}`);\n\n        for (const v of expander(a)) {\n          // If the expander generated a value for this key that conflicts with caseFilter, skip.\n          if (caseFilter && key in caseFilter) {\n            if (!objectEquals(caseFilter[key], v)) {\n              continue;\n            }\n          }\n          yield { ...a, [key]: v } as Merged<CaseP, { [name in NewPKey]: NewPValue }>;\n        }\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    assertNotGenerator(newParams);\n    const seenValues = new Set<string>();\n    for (const params of newParams) {\n      const paramsStr = stringifyPublicParams(params);\n      assert(!seenValues.has(paramsStr), `Duplicate entry in combine[WithParams]: ${paramsStr}`);\n      seenValues.add(paramsStr);\n    }\n\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritDoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    const mapped = mapLazy(values, v => ({ [key]: v }) as { [name in NewPKey]: NewPValue });\n    return this.combineWithParams(mapped);\n  }\n\n  /** @inheritDoc */\n  filter(pred: (_: CaseP) => boolean): CaseParamsBuilder<CaseP> {\n    const baseGenerator = this.cases;\n    return new CaseParamsBuilder(function* (caseFilter) {\n      for (const a of baseGenerator(caseFilter)) {\n        if (pred(a)) yield a;\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  unless(pred: (_: CaseP) => boolean): CaseParamsBuilder<CaseP> {\n    return this.filter(x => !pred(x));\n  }\n\n  /**\n   * \"Finalize\" the list of cases and begin defining subcases.\n   * Returns a new SubcaseParamsBuilder. Methods called on SubcaseParamsBuilder\n   * generate new subcases instead of new cases.\n   */\n  beginSubcases(): SubcaseParamsBuilder<CaseP, {}> {\n    return new SubcaseParamsBuilder(this.cases, function* () {\n      yield {};\n    });\n  }\n}\n\n/**\n * The unit CaseParamsBuilder, representing a single case with no params: `[ {} ]`.\n *\n * `punit` is passed to every `.params()`/`.paramsSubcasesOnly()` call, so `kUnitCaseParamsBuilder`\n * is only explicitly needed if constructing a ParamsBuilder outside of a test builder.\n */\nexport const kUnitCaseParamsBuilder = new CaseParamsBuilder(function* () {\n  yield {};\n});\n\n/**\n * Builder for combinatorial test _subcase_ parameters.\n *\n * SubcaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of subcases according to the method called.\n */\nexport class SubcaseParamsBuilder<CaseP extends {}, SubcaseP extends {}>\n  extends ParamsBuilderBase<CaseP, SubcaseP>\n  implements ParamsBuilder\n{\n  protected readonly subcases: (_: CaseP) => Generator<SubcaseP>;\n\n  constructor(\n    cases: (caseFilter: TestParams | null) => Generator<CaseP>,\n    generator: (_: CaseP) => Generator<SubcaseP>\n  ) {\n    super(cases);\n    this.subcases = generator;\n  }\n\n  *iterateCasesWithSubcases(caseFilter: TestParams | null): CaseSubcaseIterable<CaseP, SubcaseP> {\n    for (const caseP of this.cases(caseFilter)) {\n      if (caseFilter) {\n        // this.cases() only filters out cases which conflict with caseFilter. Now that we have\n        // the final caseP, filter out cases which are missing keys that caseFilter requires.\n        const ordering = comparePublicParamsPaths(caseP, caseFilter);\n        if (ordering === Ordering.StrictSuperset || ordering === Ordering.Unordered) {\n          continue;\n        }\n      }\n\n      const subcases = Array.from(this.subcases(caseP));\n      if (subcases.length) {\n        yield [\n          caseP as DeepReadonly<typeof caseP>,\n          subcases as DeepReadonly<(typeof subcases)[number]>[],\n        ];\n      }\n    }\n  }\n\n  /** @inheritDoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    const baseGenerator = this.subcases;\n    return new SubcaseParamsBuilder(this.cases, function* (base) {\n      for (const a of baseGenerator(base)) {\n        for (const b of expander(mergeParams(base, a))) {\n          yield mergeParamsChecked(a, b);\n        }\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    const baseGenerator = this.subcases;\n    return new SubcaseParamsBuilder(this.cases, function* (base) {\n      for (const a of baseGenerator(base)) {\n        const before = mergeParams(base, a);\n        assert(!(key in before), () => `Key '${key}' already exists in ${JSON.stringify(before)}`);\n\n        for (const v of expander(before)) {\n          yield { ...a, [key]: v } as Merged<SubcaseP, { [k in NewPKey]: NewPValue }>;\n        }\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    assertNotGenerator(newParams);\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritDoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    return this.expand(key, () => values);\n  }\n\n  /** @inheritDoc */\n  filter(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    const baseGenerator = this.subcases;\n    return new SubcaseParamsBuilder(this.cases, function* (base) {\n      for (const a of baseGenerator(base)) {\n        if (pred(mergeParams(base, a))) yield a;\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  unless(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return this.filter(x => !pred(x));\n  }\n}\n\n/** Assert an object is not a Generator (a thing returned from a generator function). */\nfunction assertNotGenerator(x: object) {\n  if ('constructor' in x) {\n    assert(\n      x.constructor !== (function* () {})().constructor,\n      'Argument must not be a generator, as generators are not reusable'\n    );\n  }\n}\n"],"mappings":"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"}
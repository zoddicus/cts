{"version":3,"file":"tree.js","names":["loadMetadataForSuite","globalTestConfig","assert","now","comparePublicParamsPaths","compareQueries","Ordering","TestQueryMultiCase","TestQuerySingleCase","TestQueryMultiFile","TestQueryMultiTest","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","stringifySingleParam","StacklessError","TestTree","constructor","forQuery","root","query","level","depthInLevel","create","maxChunkTime","suite","chunking","undefined","Number","isFinite","metadata","propagateCounts","iterateCollapsedNodes","includeIntermediateNodes","includeEmptySubtrees","alwaysExpandThroughLevel","expandThroughLevel","Math","max","iterateSubtreeNodes","iterateLeaves","iterateSubtreeLeaves","dissolveSingleChildTrees","newRoot","toString","subtreeToString","subtree","opts","child","children","collapsible","size","subtreeCounts","tests","nodesWithTODO","totalTimeMS","subcaseCount","counts","testLevelQuery","filePathParts","testPathParts","subcaseTiming","subcaseMS","totalTiming","countsToString","tree","name","indent","s","JSON","stringify","description","loadTreeForQuery","loader","queryToLoad","subqueriesToExpand","Infinity","specs","listing","subqueriesToExpandEntries","Array","from","entries","seenSubqueriesToExpand","length","fill","isCollapsible","subquery","every","i","toExpand","ordering","Equal","StrictSubset","foundCase","subtreeL0","makeTreeForSuite","imports_start","pEntriesWithImports","entry","file","setSubtreeDescriptionAndCountTODOs","readme","queryL1","orderingL1","Unordered","pEntryWithImport","importedSpec","importSpecFile","kForceSerialImporting","push","entriesWithImports","Promise","all","frameworkDebugLog","imported_time","performance","readmeSubtree","addSubtreeForDirPath","spec","subtreeL1","addSubtreeForFilePath","groupHasTests","t","g","iterate","queryL2","testPath","orderingL2","subtreeL2","addSubtreeForTestPath","testCreationStack","caseFilter","params","c","id","addLeafForCase","sq","subquerySeen","trim","indexOf","readableRelativeName","Map","subqueryFile","part","getOrInsertSubtree","test","subqueryTest","checkCollapsible","subqueryParams","k","v","Object","insertLeaf","key","parent","createSubtree","get","set","leaf","readableNameForCase","run","rec","expectations","isUnimplemented","computeSubcaseCount","has","shouldDissolveThisTree","newChild","paramsKeys","keys","lastKey"],"sources":["../../../src/common/internal/tree.ts"],"sourcesContent":["import { loadMetadataForSuite, TestMetadataListing } from '../framework/metadata.js';\nimport { globalTestConfig } from '../framework/test_config.js';\nimport { RunCase, RunFn } from '../internal/test_group.js';\nimport { assert, now } from '../util/util.js';\n\nimport { TestFileLoader } from './file_loader.js';\nimport { TestParamsRW } from './params_utils.js';\nimport { comparePublicParamsPaths, compareQueries, Ordering } from './query/compare.js';\nimport {\n  TestQuery,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n} from './query/query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './query/separators.js';\nimport { stringifySingleParam } from './query/stringify_params.js';\nimport { StacklessError } from './util.js';\n\n// `loadTreeForQuery()` loads a TestTree for a given queryToLoad.\n// The resulting tree is a linked-list all the way from `suite:*` to queryToLoad,\n// and under queryToLoad is a tree containing every case matched by queryToLoad.\n//\n// `subqueriesToExpand` influences the `collapsible` flag on nodes in the resulting tree.\n// A node is considered \"collapsible\" if none of the subqueriesToExpand is a StrictSubset\n// of that node.\n//\n// In WebKit/Blink-style web_tests, an expectation file marks individual cts.https.html \"variants\n// as \"Failure\", \"Crash\", etc. By passing in the list of expectations as the subqueriesToExpand,\n// we can programmatically subdivide the cts.https.html \"variants\" list to be able to implement\n// arbitrarily-fine suppressions (instead of having to suppress entire test files, which would\n// lose a lot of coverage).\n//\n// `iterateCollapsedNodes()` produces the list of queries for the variants list.\n//\n// Though somewhat complicated, this system has important benefits:\n//   - Avoids having to suppress entire test files, which would cause large test coverage loss.\n//   - Minimizes the number of page loads needed for fine-grained suppressions.\n//     (In the naive case, we could do one page load per test case - but the test suite would\n//     take impossibly long to run.)\n//   - Enables developers to put any number of tests in one file as appropriate, without worrying\n//     about expectation granularity.\n\ninterface TestTreeNodeBase<T extends TestQuery> {\n  readonly query: T;\n  /**\n   * Readable \"relative\" name for display in standalone runner.\n   * Not always the exact relative name, because sometimes there isn't\n   * one (e.g. s:f:* relative to s:f,*), but something that is readable.\n   */\n  readonly readableRelativeName: string;\n  subtreeCounts?: { tests: number; nodesWithTODO: number; totalTimeMS: number };\n  subcaseCount?: number;\n}\n\nexport interface TestSubtree<T extends TestQuery = TestQuery> extends TestTreeNodeBase<T> {\n  readonly children: Map<string, TestTreeNode>;\n  collapsible: boolean;\n  description?: string;\n  readonly testCreationStack?: Error;\n}\n\nexport interface TestTreeLeaf extends TestTreeNodeBase<TestQuerySingleCase> {\n  readonly run: RunFn;\n  readonly isUnimplemented?: boolean;\n  subtreeCounts?: undefined;\n  subcaseCount: number;\n}\n\nexport type TestTreeNode = TestSubtree | TestTreeLeaf;\n\n/**\n * When iterating through \"collapsed\" tree nodes, indicates how many \"query levels\" to traverse\n * through before starting to collapse nodes.\n *\n * Corresponds with TestQueryLevel, but excludes 4 (SingleCase):\n * - 1 = MultiFile. Expands so every file is in the collapsed tree.\n * - 2 = MultiTest. Expands so every test is in the collapsed tree.\n * - 3 = MultiCase. Expands so every case is in the collapsed tree (i.e. collapsing disabled).\n */\nexport type ExpandThroughLevel = 1 | 2 | 3;\n\nexport class TestTree {\n  /**\n   * The `queryToLoad` that this test tree was created for.\n   * Test trees are always rooted at `suite:*`, but they only contain nodes that fit\n   * within `forQuery`.\n   *\n   * This is used for `iterateCollapsedNodes` which only starts collapsing at the next\n   * `TestQueryLevel` after `forQuery`.\n   */\n  readonly forQuery: TestQuery;\n  readonly root: TestSubtree;\n\n  private constructor(forQuery: TestQuery, root: TestSubtree) {\n    this.forQuery = forQuery;\n    this.root = root;\n    assert(\n      root.query.level === 1 && root.query.depthInLevel === 0,\n      'TestTree root must be the root (suite:*)'\n    );\n  }\n\n  static async create(\n    forQuery: TestQuery,\n    root: TestSubtree,\n    maxChunkTime: number\n  ): Promise<TestTree> {\n    const suite = forQuery.suite;\n\n    let chunking = undefined;\n    if (Number.isFinite(maxChunkTime)) {\n      const metadata = loadMetadataForSuite(`./src/${suite}`);\n      assert(metadata !== null, `metadata for ${suite} is missing, but maxChunkTime was requested`);\n      chunking = { metadata, maxChunkTime };\n    }\n    await TestTree.propagateCounts(root, chunking);\n\n    return new TestTree(forQuery, root);\n  }\n\n  /**\n   * Iterate through the leaves of a version of the tree which has been pruned to exclude\n   * subtrees which:\n   * - are at a deeper `TestQueryLevel` than `this.forQuery`, and\n   * - were not a `Ordering.StrictSubset` of any of the `subqueriesToExpand` during tree creation.\n   */\n  iterateCollapsedNodes({\n    includeIntermediateNodes = false,\n    includeEmptySubtrees = false,\n    alwaysExpandThroughLevel,\n  }: {\n    /** Whether to include intermediate tree nodes or only collapsed-leaves. */\n    includeIntermediateNodes?: boolean;\n    /** Whether to include collapsed-leaves with no children. */\n    includeEmptySubtrees?: boolean;\n    /** Never collapse nodes up through this level. */\n    alwaysExpandThroughLevel: ExpandThroughLevel;\n  }): IterableIterator<Readonly<TestTreeNode>> {\n    const expandThroughLevel = Math.max(this.forQuery.level, alwaysExpandThroughLevel);\n    return TestTree.iterateSubtreeNodes(this.root, {\n      includeIntermediateNodes,\n      includeEmptySubtrees,\n      expandThroughLevel,\n    });\n  }\n\n  iterateLeaves(): IterableIterator<Readonly<TestTreeLeaf>> {\n    return TestTree.iterateSubtreeLeaves(this.root);\n  }\n\n  /**\n   * Dissolve nodes which have only one child, e.g.:\n   *   a,* { a,b,* { a,b:* { ... } } }\n   * collapses down into:\n   *   a,* { a,b:* { ... } }\n   * which is less needlessly verbose when displaying the tree in the standalone runner.\n   */\n  dissolveSingleChildTrees(): void {\n    const newRoot = dissolveSingleChildTrees(this.root);\n    assert(newRoot === this.root);\n  }\n\n  toString(): string {\n    return TestTree.subtreeToString('(root)', this.root, '');\n  }\n\n  static *iterateSubtreeNodes(\n    subtree: TestSubtree,\n    opts: {\n      includeIntermediateNodes: boolean;\n      includeEmptySubtrees: boolean;\n      expandThroughLevel: number;\n    }\n  ): IterableIterator<TestTreeNode> {\n    if (opts.includeIntermediateNodes) {\n      yield subtree;\n    }\n\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        // Is a subtree\n        const collapsible = child.collapsible && child.query.level > opts.expandThroughLevel;\n        if (child.children.size > 0 && !collapsible) {\n          yield* TestTree.iterateSubtreeNodes(child, opts);\n        } else if (child.children.size > 0 || opts.includeEmptySubtrees) {\n          // Don't yield empty subtrees (e.g. files with no tests) unless includeEmptySubtrees\n          yield child;\n        }\n      } else {\n        // Is a leaf\n        yield child;\n      }\n    }\n  }\n\n  static *iterateSubtreeLeaves(subtree: TestSubtree): IterableIterator<TestTreeLeaf> {\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        yield* TestTree.iterateSubtreeLeaves(child);\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  /** Propagate the subtreeTODOs/subtreeTests state upward from leaves to parent nodes. */\n  static async propagateCounts(\n    subtree: TestSubtree,\n    chunking: { metadata: TestMetadataListing; maxChunkTime: number } | undefined\n  ): Promise<{ tests: number; nodesWithTODO: number; totalTimeMS: number; subcaseCount: number }> {\n    subtree.subtreeCounts ??= { tests: 0, nodesWithTODO: 0, totalTimeMS: 0 };\n    subtree.subcaseCount = 0;\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        const counts = await TestTree.propagateCounts(child, chunking);\n        subtree.subtreeCounts.tests += counts.tests;\n        subtree.subtreeCounts.nodesWithTODO += counts.nodesWithTODO;\n        subtree.subtreeCounts.totalTimeMS += counts.totalTimeMS;\n        subtree.subcaseCount += counts.subcaseCount;\n      } else {\n        subtree.subcaseCount = child.subcaseCount;\n      }\n    }\n\n    // If we're chunking based on a maxChunkTime, then at each\n    // TestQueryMultiCase node of the tree we look at its total time. If the\n    // total time is larger than the maxChunkTime, we set collapsible=false to\n    // make sure it gets split up in the output. Note:\n    // - TestQueryMultiTest and higher nodes are never set to collapsible anyway, so we ignore them.\n    // - TestQuerySingleCase nodes can't be collapsed, so we ignore them.\n    if (chunking && subtree.query instanceof TestQueryMultiCase) {\n      const testLevelQuery = new TestQueryMultiCase(\n        subtree.query.suite,\n        subtree.query.filePathParts,\n        subtree.query.testPathParts,\n        {}\n      ).toString();\n\n      const metadata = chunking.metadata;\n\n      const subcaseTiming: number | undefined = metadata[testLevelQuery]?.subcaseMS;\n      if (subcaseTiming !== undefined) {\n        const totalTiming = subcaseTiming * subtree.subcaseCount;\n        subtree.subtreeCounts.totalTimeMS = totalTiming;\n        if (totalTiming > chunking.maxChunkTime) {\n          subtree.collapsible = false;\n        }\n      }\n    }\n\n    return { ...subtree.subtreeCounts, subcaseCount: subtree.subcaseCount ?? 0 };\n  }\n\n  /** Displays counts in the format `(Nodes with TODOs) / (Total test count)`. */\n  static countsToString(tree: TestTreeNode): string {\n    if (tree.subtreeCounts) {\n      return `${tree.subtreeCounts.nodesWithTODO} / ${tree.subtreeCounts.tests}`;\n    } else {\n      return '';\n    }\n  }\n\n  static subtreeToString(name: string, tree: TestTreeNode, indent: string): string {\n    const collapsible = 'run' in tree ? '>' : tree.collapsible ? '+' : '-';\n    let s =\n      indent +\n      `${collapsible} ${TestTree.countsToString(tree)} ${JSON.stringify(name)} => ${tree.query}`;\n    if ('children' in tree) {\n      if (tree.description !== undefined) {\n        s += `\\n${indent}  | ${JSON.stringify(tree.description)}`;\n      }\n\n      for (const [name, child] of tree.children) {\n        s += '\\n' + TestTree.subtreeToString(name, child, indent + '  ');\n      }\n    }\n    return s;\n  }\n}\n\n// MAINTENANCE_TODO: Consider having subqueriesToExpand actually impact the depth-order of params\n// in the tree.\nexport async function loadTreeForQuery(\n  loader: TestFileLoader,\n  queryToLoad: TestQuery,\n  {\n    subqueriesToExpand,\n    maxChunkTime = Infinity,\n  }: { subqueriesToExpand: TestQuery[]; maxChunkTime?: number }\n): Promise<TestTree> {\n  const suite = queryToLoad.suite;\n  const specs = await loader.listing(suite);\n\n  const subqueriesToExpandEntries = Array.from(subqueriesToExpand.entries());\n  const seenSubqueriesToExpand: boolean[] = new Array(subqueriesToExpand.length);\n  seenSubqueriesToExpand.fill(false);\n\n  const isCollapsible = (subquery: TestQuery) =>\n    subqueriesToExpandEntries.every(([i, toExpand]) => {\n      const ordering = compareQueries(toExpand, subquery);\n\n      // If toExpand == subquery, no expansion is needed (but it's still \"seen\").\n      if (ordering === Ordering.Equal) seenSubqueriesToExpand[i] = true;\n      return ordering !== Ordering.StrictSubset;\n    });\n\n  // L0 = suite-level, e.g. suite:*\n  // L1 =  file-level, e.g. suite:a,b:*\n  // L2 =  test-level, e.g. suite:a,b:c,d:*\n  // L3 =  case-level, e.g. suite:a,b:c,d:\n  let foundCase = false;\n  // L0 is suite:*\n  const subtreeL0 = makeTreeForSuite(suite, isCollapsible);\n\n  const imports_start = now();\n  const pEntriesWithImports = []; // Promise<entry with importedSpec>[]\n  for (const entry of specs) {\n    if (entry.file.length === 0 && 'readme' in entry) {\n      // Suite-level readme.\n      setSubtreeDescriptionAndCountTODOs(subtreeL0, entry.readme);\n      continue;\n    }\n\n    {\n      const queryL1 = new TestQueryMultiFile(suite, entry.file);\n      const orderingL1 = compareQueries(queryL1, queryToLoad);\n      if (orderingL1 === Ordering.Unordered) {\n        // File path is not matched by this query.\n        continue;\n      }\n    }\n\n    // We're going to be fetching+importing a bunch of things, so do it in async.\n    const pEntryWithImport = (async () => {\n      if ('readme' in entry) {\n        return entry;\n      } else {\n        return {\n          ...entry,\n          importedSpec: await loader.importSpecFile(queryToLoad.suite, entry.file),\n        };\n      }\n    })();\n\n    const kForceSerialImporting = false;\n    if (kForceSerialImporting) {\n      await pEntryWithImport;\n    }\n    pEntriesWithImports.push(pEntryWithImport);\n  }\n\n  const entriesWithImports = await Promise.all(pEntriesWithImports);\n  if (globalTestConfig.frameworkDebugLog) {\n    const imported_time = performance.now() - imports_start;\n    globalTestConfig.frameworkDebugLog(\n      `Imported importedSpecFiles[${entriesWithImports.length}] in ${imported_time}ms.`\n    );\n  }\n\n  for (const entry of entriesWithImports) {\n    if ('readme' in entry) {\n      // Entry is a README that is an ancestor or descendant of the query.\n      // (It's included for display in the standalone runner.)\n\n      // readmeSubtree is suite:a,b,*\n      // (This is always going to dedup with a file path, if there are any test spec files under\n      // the directory that has the README).\n      const readmeSubtree: TestSubtree<TestQueryMultiFile> = addSubtreeForDirPath(\n        subtreeL0,\n        entry.file,\n        isCollapsible\n      );\n      setSubtreeDescriptionAndCountTODOs(readmeSubtree, entry.readme);\n      continue;\n    }\n\n    // Entry is a spec file.\n    const spec = entry.importedSpec;\n    // subtreeL1 is suite:a,b:*\n    const subtreeL1: TestSubtree<TestQueryMultiTest> = addSubtreeForFilePath(\n      subtreeL0,\n      entry.file,\n      isCollapsible\n    );\n    setSubtreeDescriptionAndCountTODOs(subtreeL1, spec.description);\n\n    let groupHasTests = false;\n    for (const t of spec.g.iterate()) {\n      groupHasTests = true;\n      {\n        const queryL2 = new TestQueryMultiCase(suite, entry.file, t.testPath, {});\n        const orderingL2 = compareQueries(queryL2, queryToLoad);\n        if (orderingL2 === Ordering.Unordered) {\n          // Test path is not matched by this query.\n          continue;\n        }\n      }\n\n      // subtreeL2 is suite:a,b:c,d:*\n      const subtreeL2: TestSubtree<TestQueryMultiCase> = addSubtreeForTestPath(\n        subtreeL1,\n        t.testPath,\n        t.testCreationStack,\n        isCollapsible\n      );\n      // This is 1 test. Set tests=1 then count TODOs.\n      subtreeL2.subtreeCounts ??= { tests: 1, nodesWithTODO: 0, totalTimeMS: 0 };\n      if (t.description) setSubtreeDescriptionAndCountTODOs(subtreeL2, t.description);\n\n      let caseFilter = null;\n      if ('params' in queryToLoad) {\n        caseFilter = queryToLoad.params;\n      }\n\n      // MAINTENANCE_TODO: If tree generation gets too slow, avoid actually iterating the cases in a\n      // file if there's no need to (based on the subqueriesToExpand).\n      for (const c of t.iterate(caseFilter)) {\n        // iterate() guarantees c's query is equal to or a subset of queryToLoad.\n\n        if (queryToLoad instanceof TestQuerySingleCase) {\n          // A subset is OK if it's TestQueryMultiCase, but for SingleCase it must match exactly.\n          const ordering = comparePublicParamsPaths(c.id.params, queryToLoad.params);\n          if (ordering !== Ordering.Equal) {\n            continue;\n          }\n        }\n\n        // Leaf for case is suite:a,b:c,d:x=1;y=2\n        addLeafForCase(subtreeL2, c, isCollapsible);\n        foundCase = true;\n      }\n    }\n    if (!groupHasTests && !subtreeL1.subtreeCounts) {\n      throw new StacklessError(\n        `${subtreeL1.query} has no tests - it must have \"TODO\" in its description`\n      );\n    }\n  }\n\n  for (const [i, sq] of subqueriesToExpandEntries) {\n    const subquerySeen = seenSubqueriesToExpand[i];\n    if (!subquerySeen) {\n      throw new StacklessError(\n        `subqueriesToExpand entry did not match anything \\\n(could be wrong, or could be redundant with a previous subquery):\\n  ${sq.toString()}`\n      );\n    }\n  }\n  assert(foundCase, `Query \\`${queryToLoad.toString()}\\` does not match any cases`);\n\n  return TestTree.create(queryToLoad, subtreeL0, maxChunkTime);\n}\n\nfunction setSubtreeDescriptionAndCountTODOs(\n  subtree: TestSubtree<TestQueryMultiFile>,\n  description: string\n) {\n  assert(subtree.description === undefined);\n  subtree.description = description.trim();\n  subtree.subtreeCounts ??= { tests: 0, nodesWithTODO: 0, totalTimeMS: 0 };\n  if (subtree.description.indexOf('TODO') !== -1) {\n    subtree.subtreeCounts.nodesWithTODO++;\n  }\n}\n\nfunction makeTreeForSuite(\n  suite: string,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const query = new TestQueryMultiFile(suite, []);\n  return {\n    readableRelativeName: suite + kBigSeparator,\n    query,\n    children: new Map(),\n    collapsible: isCollapsible(query),\n  };\n}\n\nfunction addSubtreeForDirPath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const subqueryFile: string[] = [];\n  // To start, tree is suite:*\n  // This loop goes from that -> suite:a,* -> suite:a,b,*\n  for (const part of file) {\n    subqueryFile.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiFile(tree.query.suite, subqueryFile);\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  return tree;\n}\n\nfunction addSubtreeForFilePath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiTest> {\n  // To start, tree is suite:*\n  // This goes from that -> suite:a,* -> suite:a,b,*\n  tree = addSubtreeForDirPath(tree, file, isCollapsible);\n  // This goes from that -> suite:a,b:*\n  const subtree = getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiTest(tree.query.suite, tree.query.filePathParts, []);\n    assert(file.length > 0, 'file path is empty');\n    return {\n      readableRelativeName: file[file.length - 1] + kBigSeparator + kWildcard,\n      query,\n      collapsible: isCollapsible(query),\n    };\n  });\n  return subtree;\n}\n\nfunction addSubtreeForTestPath(\n  tree: TestSubtree<TestQueryMultiTest>,\n  test: readonly string[],\n  testCreationStack: Error,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiCase> {\n  const subqueryTest: string[] = [];\n  // To start, tree is suite:a,b:*\n  // This loop goes from that -> suite:a,b:c,* -> suite:a,b:c,d,*\n  for (const part of test) {\n    subqueryTest.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiTest(\n        tree.query.suite,\n        tree.query.filePathParts,\n        subqueryTest\n      );\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  // This goes from that -> suite:a,b:c,d:*\n  return getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiCase(\n      tree.query.suite,\n      tree.query.filePathParts,\n      subqueryTest,\n      {}\n    );\n    assert(subqueryTest.length > 0, 'subqueryTest is empty');\n    return {\n      readableRelativeName: subqueryTest[subqueryTest.length - 1] + kBigSeparator + kWildcard,\n      kWildcard,\n      query,\n      testCreationStack,\n      collapsible: isCollapsible(query),\n    };\n  });\n}\n\nfunction addLeafForCase(\n  tree: TestSubtree<TestQueryMultiTest>,\n  t: RunCase,\n  checkCollapsible: (sq: TestQuery) => boolean\n): void {\n  const query = tree.query;\n  let name: string = '';\n  const subqueryParams: TestParamsRW = {};\n\n  // To start, tree is suite:a,b:c,d:*\n  // This loop goes from that -> suite:a,b:c,d:x=1;* -> suite:a,b:c,d:x=1;y=2;*\n  for (const [k, v] of Object.entries(t.id.params)) {\n    name = stringifySingleParam(k, v);\n    subqueryParams[k] = v;\n\n    tree = getOrInsertSubtree(name, tree, () => {\n      const subquery = new TestQueryMultiCase(\n        query.suite,\n        query.filePathParts,\n        query.testPathParts,\n        subqueryParams\n      );\n      return {\n        readableRelativeName: name + kParamSeparator + kWildcard,\n        query: subquery,\n        collapsible: checkCollapsible(subquery),\n      };\n    });\n  }\n\n  // This goes from that -> suite:a,b:c,d:x=1;y=2\n  const subquery = new TestQuerySingleCase(\n    query.suite,\n    query.filePathParts,\n    query.testPathParts,\n    subqueryParams\n  );\n  checkCollapsible(subquery); // mark seenSubqueriesToExpand\n  insertLeaf(tree, subquery, t);\n}\n\nfunction getOrInsertSubtree<T extends TestQuery>(\n  key: string,\n  parent: TestSubtree,\n  createSubtree: () => Omit<TestSubtree<T>, 'children'>\n): TestSubtree<T> {\n  let v: TestSubtree<T>;\n  const child = parent.children.get(key);\n  if (child !== undefined) {\n    assert('children' in child); // Make sure cached subtree is not actually a leaf\n    v = child as TestSubtree<T>;\n  } else {\n    v = { ...createSubtree(), children: new Map() };\n    parent.children.set(key, v);\n  }\n  return v;\n}\n\nfunction insertLeaf(parent: TestSubtree, query: TestQuerySingleCase, t: RunCase) {\n  const leaf: TestTreeLeaf = {\n    readableRelativeName: readableNameForCase(query),\n    query,\n    run: (rec, expectations) => t.run(rec, query, expectations || []),\n    isUnimplemented: t.isUnimplemented,\n    subcaseCount: t.computeSubcaseCount(),\n  };\n\n  // This is a leaf (e.g. s:f:t:x=1;* -> s:f:t:x=1). The key is always ''.\n  const key = '';\n  assert(!parent.children.has(key), `Duplicate testcase: ${query}`);\n  parent.children.set(key, leaf);\n}\n\nfunction dissolveSingleChildTrees(tree: TestTreeNode): TestTreeNode {\n  if ('children' in tree) {\n    const shouldDissolveThisTree =\n      tree.children.size === 1 && tree.query.depthInLevel !== 0 && tree.description === undefined;\n    if (shouldDissolveThisTree) {\n      // Loops exactly once\n      for (const [, child] of tree.children) {\n        // Recurse on child\n        return dissolveSingleChildTrees(child);\n      }\n    }\n\n    for (const [k, child] of tree.children) {\n      // Recurse on each child\n      const newChild = dissolveSingleChildTrees(child);\n      if (newChild !== child) {\n        tree.children.set(k, newChild);\n      }\n    }\n  }\n  return tree;\n}\n\n/** Generate a readable relative name for a case (used in standalone). */\nfunction readableNameForCase(query: TestQuerySingleCase): string {\n  const paramsKeys = Object.keys(query.params);\n  if (paramsKeys.length === 0) {\n    return query.testPathParts[query.testPathParts.length - 1] + kBigSeparator;\n  } else {\n    const lastKey = paramsKeys[paramsKeys.length - 1];\n    return stringifySingleParam(lastKey, query.params[lastKey]);\n  }\n}\n"],"mappings":"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"}
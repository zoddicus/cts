{"version":3,"file":"params_utils.js","names":["assert","comparePublicParamsPaths","Ordering","kWildcard","kParamSeparator","kParamKVSeparator","paramKeyIsPublic","key","startsWith","extractPublicParams","params","publicParams","k","Object","keys","kPercent","badParamValueChars","RegExp","publicParamsEquals","x","y","Equal","typeAssert","mergeParams","a","b","mergeParamsChecked","merged","length","JSON","stringify"],"sources":["../../../src/common/internal/params_utils.ts"],"sourcesContent":["import { TestParams } from '../framework/fixture.js';\nimport { ResolveType, UnionToIntersection } from '../util/types.js';\nimport { assert } from '../util/util.js';\n\nimport { comparePublicParamsPaths, Ordering } from './query/compare.js';\nimport { kWildcard, kParamSeparator, kParamKVSeparator } from './query/separators.js';\n\nexport type JSONWithUndefined =\n  | undefined\n  | null\n  | number\n  | string\n  | boolean\n  | readonly JSONWithUndefined[]\n  // Ideally this would recurse into JSONWithUndefined, but it breaks code.\n  | { readonly [k: string]: unknown };\nexport interface TestParamsRW {\n  [k: string]: JSONWithUndefined;\n}\nexport type TestParamsIterable = Iterable<TestParams>;\n\nexport function paramKeyIsPublic(key: string): boolean {\n  return !key.startsWith('_');\n}\n\nexport function extractPublicParams(params: TestParams): TestParams {\n  const publicParams: TestParamsRW = {};\n  for (const k of Object.keys(params)) {\n    if (paramKeyIsPublic(k)) {\n      publicParams[k] = params[k];\n    }\n  }\n  return publicParams;\n}\n\n/** Used to escape reserved characters in URIs */\nconst kPercent = '%';\n\nexport const badParamValueChars = new RegExp(\n  '[' + kParamKVSeparator + kParamSeparator + kWildcard + kPercent + ']'\n);\n\nexport function publicParamsEquals(x: TestParams, y: TestParams): boolean {\n  return comparePublicParamsPaths(x, y) === Ordering.Equal;\n}\n\nexport type KeyOfNeverable<T> = T extends never ? never : keyof T;\nexport type AllKeysFromUnion<T> = keyof T | KeyOfNeverable<UnionToIntersection<T>>;\nexport type KeyOfOr<T, K, Default> = K extends keyof T ? T[K] : Default;\n\n/**\n * Flatten a union of interfaces into a single interface encoding the same type.\n *\n * Flattens a union in such a way that:\n * `{ a: number, b?: undefined } | { b: string, a?: undefined }`\n * (which is the value type of `[{ a: 1 }, { b: 1 }]`)\n * becomes `{ a: number | undefined, b: string | undefined }`.\n *\n * And also works for `{ a: number } | { b: string }` which maps to the same.\n */\nexport type FlattenUnionOfInterfaces<T> = {\n  [K in AllKeysFromUnion<T>]: KeyOfOr<\n    T,\n    // If T always has K, just take T[K] (union of C[K] for each component C of T):\n    K,\n    // Otherwise, take the union of C[K] for each component C of T, PLUS undefined:\n    undefined | KeyOfOr<UnionToIntersection<T>, K, void>\n  >;\n};\n\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nfunction typeAssert<_ extends 'pass'>() {}\n{\n  type Test<T, U> = [T] extends [U]\n    ? [U] extends [T]\n      ? 'pass'\n      : { actual: ResolveType<T>; expected: U }\n    : { actual: ResolveType<T>; expected: U };\n\n  type T01 = { a: number } | { b: string };\n  type T02 = { a: number } | { b?: string };\n  type T03 = { a: number } | { a?: number };\n  type T04 = { a: number } | { a: string };\n  type T05 = { a: number } | { a?: string };\n\n  type T11 = { a: number; b?: undefined } | { a?: undefined; b: string };\n\n  type T21 = { a: number; b?: undefined } | { b: string };\n  type T22 = { a: number; b?: undefined } | { b?: string };\n  type T23 = { a: number; b?: undefined } | { a?: number };\n  type T24 = { a: number; b?: undefined } | { a: string };\n  type T25 = { a: number; b?: undefined } | { a?: string };\n  type T26 = { a: number; b?: undefined } | { a: undefined };\n  type T27 = { a: number; b?: undefined } | { a: undefined; b: undefined };\n\n  /* prettier-ignore */ {\n    typeAssert<Test<FlattenUnionOfInterfaces<T01>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T02>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T03>, { a: number | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T04>, { a: number | string }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T05>, { a: number | string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T11>, { a: number | undefined; b: string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T22>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T23>, { a: number | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T24>, { a: number | string; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T25>, { a: number | string | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T27>, { a: number | undefined; b: undefined }>>();\n\n    // Unexpected test results - hopefully okay to ignore these\n    typeAssert<Test<FlattenUnionOfInterfaces<T21>, { b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T26>, { a: number | undefined }>>();\n  }\n}\n\nexport type Merged<A, B> = MergedFromFlat<A, FlattenUnionOfInterfaces<B>>;\nexport type MergedFromFlat<A, B> = {\n  [K in keyof A | keyof B]: K extends keyof B ? B[K] : K extends keyof A ? A[K] : never;\n};\n\n/** Merges two objects into one `{ ...a, ...b }` and return it with a flattened type. */\nexport function mergeParams<A extends {}, B extends {}>(a: A, b: B): Merged<A, B> {\n  return { ...a, ...b } as Merged<A, B>;\n}\n\n/**\n * Merges two objects into one `{ ...a, ...b }` and asserts they had no overlapping keys.\n * This is slower than {@link mergeParams}.\n */\nexport function mergeParamsChecked<A extends {}, B extends {}>(a: A, b: B): Merged<A, B> {\n  const merged = mergeParams(a, b);\n  assert(\n    Object.keys(merged).length === Object.keys(a).length + Object.keys(b).length,\n    () => `Duplicate key between ${JSON.stringify(a)} and ${JSON.stringify(b)}`\n  );\n  return merged;\n}\n"],"mappings":";;GAEA,SAASA,MAAM,QAAQ,iBAAiB;;AAExC,SAASC,wBAAwB,EAAEC,QAAQ,QAAQ,oBAAoB;AACvE,SAASC,SAAS,EAAEC,eAAe,EAAEC,iBAAiB,QAAQ,uBAAuB;;;;;;;;;;;;;;;;AAgBrF,OAAO,SAASC,gBAAgBA,CAACC,GAAW,EAAW;EACrD,OAAO,CAACA,GAAG,CAACC,UAAU,CAAC,GAAG,CAAC;AAC7B;;AAEA,OAAO,SAASC,mBAAmBA,CAACC,MAAkB,EAAc;EAClE,MAAMC,YAA0B,GAAG,CAAC,CAAC;EACrC,KAAK,MAAMC,CAAC,IAAIC,MAAM,CAACC,IAAI,CAACJ,MAAM,CAAC,EAAE;IACnC,IAAIJ,gBAAgB,CAACM,CAAC,CAAC,EAAE;MACvBD,YAAY,CAACC,CAAC,CAAC,GAAGF,MAAM,CAACE,CAAC,CAAC;IAC7B;EACF;EACA,OAAOD,YAAY;AACrB;;AAEA;AACA,MAAMI,QAAQ,GAAG,GAAG;;AAEpB,OAAO,MAAMC,kBAAkB,GAAG,IAAIC,MAAM;EAC1C,GAAG,GAAGZ,iBAAiB,GAAGD,eAAe,GAAGD,SAAS,GAAGY,QAAQ,GAAG;AACrE,CAAC;;AAED,OAAO,SAASG,kBAAkBA,CAACC,CAAa,EAAEC,CAAa,EAAW;EACxE,OAAOnB,wBAAwB,CAACkB,CAAC,EAAEC,CAAC,CAAC,KAAKlB,QAAQ,CAACmB,KAAK;AAC1D;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA,SAASC,UAAUA,CAAA,EAAqB,CAAC;AACzC;;;;;;;;;;;;;;;;;;;;;;;EAuBwB;IACpBA,UAAU,CAAwF,CAAC;IACnGA,UAAU,CAAwF,CAAC;IACnGA,UAAU,CAAiE,CAAC;IAC5EA,UAAU,CAA8D,CAAC;IACzEA,UAAU,CAA0E,CAAC;;IAErFA,UAAU,CAAwF,CAAC;;IAEnGA,UAAU,CAAwF,CAAC;IACnGA,UAAU,CAA+E,CAAC;IAC1FA,UAAU,CAA4E,CAAC;IACvFA,UAAU,CAAwF,CAAC;IACnGA,UAAU,CAA+E,CAAC;;IAE1F;IACAA,UAAU,CAAiE,CAAC;IAC5EA,UAAU,CAAiE,CAAC;EAC9E;AACF;;;;;;;AAOA;AACA,OAAO,SAASC,WAAWA,CAA6BC,CAAI,EAAEC,CAAI,EAAgB;EAChF,OAAO,EAAE,GAAGD,CAAC,EAAE,GAAGC,CAAC,CAAC,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAA6BF,CAAI,EAAEC,CAAI,EAAgB;EACvF,MAAME,MAAM,GAAGJ,WAAW,CAACC,CAAC,EAAEC,CAAC,CAAC;EAChCzB,MAAM;IACJa,MAAM,CAACC,IAAI,CAACa,MAAM,CAAC,CAACC,MAAM,KAAKf,MAAM,CAACC,IAAI,CAACU,CAAC,CAAC,CAACI,MAAM,GAAGf,MAAM,CAACC,IAAI,CAACW,CAAC,CAAC,CAACG,MAAM;IAC5E,MAAO,yBAAwBC,IAAI,CAACC,SAAS,CAACN,CAAC,CAAE,QAAOK,IAAI,CAACC,SAAS,CAACL,CAAC,CAAE;EAC5E,CAAC;EACD,OAAOE,MAAM;AACf"}
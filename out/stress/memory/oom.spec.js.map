{"version":3,"file":"oom.spec.js","names":["description","makeTestGroup","unreachable","GPUConst","GPUTest","exhaustVramUntilUnder64MB","g","createBufferWithMapState","device","size","mapState","mode","mappedAtCreation","mappable","createBuffer","usage","GPUBufferUsage","UNIFORM","buffer","GPUMapMode","READ","MAP_READ","WRITE","MAP_WRITE","unmap","test","desc","fn","t","params","u","combine","MapMode","kSize","unmapBeforeResolve","buffers","finish","Promise","all","map","value","mapAsync","forEach","expectValidationError","destroy","errorBuffer","pushErrorScope","trackForCleanup","popErrorScope","push","ex","expect","RangeError","promise","shouldReject","Error","shouldThrow","getMappedRange","unimplemented"],"sources":["../../../src/stress/memory/oom.spec.ts"],"sourcesContent":["export const description = `\nStress tests covering robustness when available VRAM is exhausted.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { unreachable } from '../../common/util/util.js';\nimport { GPUConst } from '../../webgpu/constants.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\nimport { exhaustVramUntilUnder64MB } from '../../webgpu/util/memory.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction createBufferWithMapState(\n  device: GPUDevice,\n  size: number,\n  mapState: GPUBufferMapState,\n  mode: GPUMapModeFlags,\n  mappedAtCreation: boolean\n) {\n  const mappable = mapState === 'unmapped';\n  if (!mappable && !mappedAtCreation) {\n    return device.createBuffer({\n      size,\n      usage: GPUBufferUsage.UNIFORM,\n      mappedAtCreation,\n    });\n  }\n  let buffer: GPUBuffer;\n  switch (mode) {\n    case GPUMapMode.READ:\n      buffer = device.createBuffer({\n        size,\n        usage: GPUBufferUsage.MAP_READ,\n        mappedAtCreation,\n      });\n      break;\n    case GPUMapMode.WRITE:\n      buffer = device.createBuffer({\n        size,\n        usage: GPUBufferUsage.MAP_WRITE,\n        mappedAtCreation,\n      });\n      break;\n    default:\n      unreachable();\n  }\n  // If we want the buffer to be mappable and also mappedAtCreation, we call unmap on it now.\n  if (mappable && mappedAtCreation) {\n    buffer.unmap();\n  }\n  return buffer;\n}\n\ng.test('vram_oom')\n  .desc(`Tests that we can allocate buffers until we run out of VRAM.`)\n  .fn(async t => {\n    await exhaustVramUntilUnder64MB(t.device);\n  });\n\ng.test('map_after_vram_oom')\n  .desc(\n    `Allocates tons of buffers and textures with varying mapping states (unmappable,\nmappable, mapAtCreation, mapAtCreation-then-unmapped) until OOM; then attempts\nto mapAsync all the mappable objects. The last buffer should be an error buffer so\nmapAsync on it should reject and produce a validation error. `\n  )\n  .params(u =>\n    u\n      .combine('mapState', ['mapped', 'unmapped'] as GPUBufferMapState[])\n      .combine('mode', [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE])\n      .combine('mappedAtCreation', [true, false])\n      .combine('unmapBeforeResolve', [true, false])\n  )\n  .fn(async t => {\n    // Use a relatively large size to quickly hit OOM.\n    const kSize = 512 * 1024 * 1024;\n\n    const { mapState, mode, mappedAtCreation, unmapBeforeResolve } = t.params;\n    const mappable = mapState === 'unmapped';\n    const buffers: GPUBuffer[] = [];\n    // Closure to call map and verify results on all of the buffers.\n    const finish = async () => {\n      if (mappable) {\n        await Promise.all(buffers.map(value => value.mapAsync(mode)));\n      } else {\n        buffers.forEach(value => {\n          t.expectValidationError(() => {\n            void value.mapAsync(mode);\n          });\n        });\n      }\n      // Finally, destroy all the buffers to free the resources.\n      buffers.forEach(buffer => buffer.destroy());\n    };\n\n    let errorBuffer: GPUBuffer;\n    for (;;) {\n      if (mappedAtCreation) {\n        // When mappedAtCreation is true, OOM can happen on the client which throws a RangeError. In\n        // this case, we don't do any validations on the OOM buffer.\n        try {\n          t.device.pushErrorScope('out-of-memory');\n          const buffer = t.trackForCleanup(\n            createBufferWithMapState(t.device, kSize, mapState, mode, mappedAtCreation)\n          );\n          if (await t.device.popErrorScope()) {\n            errorBuffer = buffer;\n            break;\n          }\n          buffers.push(buffer);\n        } catch (ex) {\n          t.expect(ex instanceof RangeError);\n          await finish();\n          return;\n        }\n      } else {\n        t.device.pushErrorScope('out-of-memory');\n        const buffer = t.trackForCleanup(\n          createBufferWithMapState(t.device, kSize, mapState, mode, mappedAtCreation)\n        );\n        if (await t.device.popErrorScope()) {\n          errorBuffer = buffer;\n          break;\n        }\n        buffers.push(buffer);\n      }\n    }\n\n    // Do some validation on the OOM buffer.\n    let promise: Promise<void>;\n    t.expectValidationError(() => {\n      promise = errorBuffer.mapAsync(mode);\n    });\n    if (unmapBeforeResolve) {\n      // Should reject with abort error because buffer will be unmapped\n      // before validation check finishes.\n      t.shouldReject('AbortError', promise!);\n    } else {\n      // Should also reject in addition to the validation error.\n      t.shouldReject('OperationError', promise!);\n\n      // Wait for validation error before unmap to ensure validation check\n      // ends before unmap.\n      try {\n        await promise!;\n        throw new Error('The promise should be rejected.');\n      } catch {\n        // Should cause an exception because the promise should be rejected.\n      }\n    }\n\n    // Should throw an OperationError because the buffer is not mapped.\n    // Note: not a RangeError because the state of the buffer is checked first.\n    t.shouldThrow('OperationError', () => {\n      errorBuffer.getMappedRange();\n    });\n\n    // Should't be a validation error even if the buffer failed to be mapped.\n    errorBuffer.unmap();\n    errorBuffer.destroy();\n\n    // Finish the rest of the test w.r.t the mappable buffers.\n    await finish();\n  });\n\ng.test('validation_vs_oom')\n  .desc(\n    `Tests that calls affected by both OOM and validation errors expose the\nvalidation error with precedence.`\n  )\n  .unimplemented();\n\ng.test('recovery')\n  .desc(\n    `Tests that after going VRAM-OOM, destroying allocated resources eventually\nallows new resources to be allocated.`\n  )\n  .unimplemented();\n"],"mappings":"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"}
{"version":3,"file":"oom.spec.js","names":["description","makeTestGroup","unreachable","GPUConst","GPUTest","exhaustVramUntilUnder64MB","g","createBufferWithMapState","t","size","mapState","mode","mappedAtCreation","mappable","createBufferTracked","usage","GPUBufferUsage","UNIFORM","buffer","GPUMapMode","READ","MAP_READ","WRITE","MAP_WRITE","unmap","test","desc","fn","params","u","combine","MapMode","kSize","unmapBeforeResolve","buffers","finish","Promise","all","map","value","mapAsync","forEach","expectValidationError","destroy","errorBuffer","device","pushErrorScope","popErrorScope","push","ex","expect","RangeError","promise","shouldReject","Error","shouldThrow","getMappedRange","unimplemented"],"sources":["../../../src/stress/memory/oom.spec.ts"],"sourcesContent":["export const description = `\nStress tests covering robustness when available VRAM is exhausted.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { unreachable } from '../../common/util/util.js';\nimport { GPUConst } from '../../webgpu/constants.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\nimport { exhaustVramUntilUnder64MB } from '../../webgpu/util/memory.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction createBufferWithMapState(\n  t: GPUTest,\n  size: number,\n  mapState: GPUBufferMapState,\n  mode: GPUMapModeFlags,\n  mappedAtCreation: boolean\n) {\n  const mappable = mapState === 'unmapped';\n  if (!mappable && !mappedAtCreation) {\n    return t.createBufferTracked({\n      size,\n      usage: GPUBufferUsage.UNIFORM,\n      mappedAtCreation,\n    });\n  }\n  let buffer: GPUBuffer;\n  switch (mode) {\n    case GPUMapMode.READ:\n      buffer = t.createBufferTracked({\n        size,\n        usage: GPUBufferUsage.MAP_READ,\n        mappedAtCreation,\n      });\n      break;\n    case GPUMapMode.WRITE:\n      buffer = t.createBufferTracked({\n        size,\n        usage: GPUBufferUsage.MAP_WRITE,\n        mappedAtCreation,\n      });\n      break;\n    default:\n      unreachable();\n  }\n  // If we want the buffer to be mappable and also mappedAtCreation, we call unmap on it now.\n  if (mappable && mappedAtCreation) {\n    buffer.unmap();\n  }\n  return buffer;\n}\n\ng.test('vram_oom')\n  .desc(`Tests that we can allocate buffers until we run out of VRAM.`)\n  .fn(async t => {\n    await exhaustVramUntilUnder64MB(t);\n  });\n\ng.test('map_after_vram_oom')\n  .desc(\n    `Allocates tons of buffers and textures with varying mapping states (unmappable,\nmappable, mapAtCreation, mapAtCreation-then-unmapped) until OOM; then attempts\nto mapAsync all the mappable objects. The last buffer should be an error buffer so\nmapAsync on it should reject and produce a validation error. `\n  )\n  .params(u =>\n    u\n      .combine('mapState', ['mapped', 'unmapped'] as GPUBufferMapState[])\n      .combine('mode', [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE])\n      .combine('mappedAtCreation', [true, false])\n      .combine('unmapBeforeResolve', [true, false])\n  )\n  .fn(async t => {\n    // Use a relatively large size to quickly hit OOM.\n    const kSize = 512 * 1024 * 1024;\n\n    const { mapState, mode, mappedAtCreation, unmapBeforeResolve } = t.params;\n    const mappable = mapState === 'unmapped';\n    const buffers: GPUBuffer[] = [];\n    // Closure to call map and verify results on all of the buffers.\n    const finish = async () => {\n      if (mappable) {\n        await Promise.all(buffers.map(value => value.mapAsync(mode)));\n      } else {\n        buffers.forEach(value => {\n          t.expectValidationError(() => {\n            void value.mapAsync(mode);\n          });\n        });\n      }\n      // Finally, destroy all the buffers to free the resources.\n      buffers.forEach(buffer => buffer.destroy());\n    };\n\n    let errorBuffer: GPUBuffer;\n    for (;;) {\n      if (mappedAtCreation) {\n        // When mappedAtCreation is true, OOM can happen on the client which throws a RangeError. In\n        // this case, we don't do any validations on the OOM buffer.\n        try {\n          t.device.pushErrorScope('out-of-memory');\n          const buffer = createBufferWithMapState(t, kSize, mapState, mode, mappedAtCreation);\n          if (await t.device.popErrorScope()) {\n            errorBuffer = buffer;\n            break;\n          }\n          buffers.push(buffer);\n        } catch (ex) {\n          t.expect(ex instanceof RangeError);\n          await finish();\n          return;\n        }\n      } else {\n        t.device.pushErrorScope('out-of-memory');\n        const buffer = createBufferWithMapState(t, kSize, mapState, mode, mappedAtCreation);\n        if (await t.device.popErrorScope()) {\n          errorBuffer = buffer;\n          break;\n        }\n        buffers.push(buffer);\n      }\n    }\n\n    // Do some validation on the OOM buffer.\n    let promise: Promise<void>;\n    t.expectValidationError(() => {\n      promise = errorBuffer.mapAsync(mode);\n    });\n    if (unmapBeforeResolve) {\n      // Should reject with abort error because buffer will be unmapped\n      // before validation check finishes.\n      t.shouldReject('AbortError', promise!);\n    } else {\n      // Should also reject in addition to the validation error.\n      t.shouldReject('OperationError', promise!);\n\n      // Wait for validation error before unmap to ensure validation check\n      // ends before unmap.\n      try {\n        await promise!;\n        throw new Error('The promise should be rejected.');\n      } catch {\n        // Should cause an exception because the promise should be rejected.\n      }\n    }\n\n    // Should throw an OperationError because the buffer is not mapped.\n    // Note: not a RangeError because the state of the buffer is checked first.\n    t.shouldThrow('OperationError', () => {\n      errorBuffer.getMappedRange();\n    });\n\n    // Should't be a validation error even if the buffer failed to be mapped.\n    errorBuffer.unmap();\n    errorBuffer.destroy();\n\n    // Finish the rest of the test w.r.t the mappable buffers.\n    await finish();\n  });\n\ng.test('validation_vs_oom')\n  .desc(\n    `Tests that calls affected by both OOM and validation errors expose the\nvalidation error with precedence.`\n  )\n  .unimplemented();\n\ng.test('recovery')\n  .desc(\n    `Tests that after going VRAM-OOM, destroying allocated resources eventually\nallows new resources to be allocated.`\n  )\n  .unimplemented();\n"],"mappings":"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"}
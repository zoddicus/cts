{"version":3,"file":"non_halting.spec.js","names":["description","makeTestGroup","GPUTest","g","test","desc","fn","t","data","Uint32Array","buffer","makeBufferWithContents","GPUBufferUsage","STORAGE","COPY_SRC","module","device","createShaderModule","code","pipeline","createComputePipeline","layout","compute","entryPoint","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","lost","createRenderPipeline","vertex","buffers","primitive","topology","fragment","targets","format","uniforms","UNIFORM","renderTarget","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","draw"],"sources":["../../../src/stress/shaders/non_halting.spec.ts"],"sourcesContent":["export const description = `\nStress tests covering robustness in the presence of non-halting shaders.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('compute')\n  .desc(\n    `Tests execution of compute passes with non-halting dispatch operations.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const data = new Uint32Array([0]);\n    const buffer = t.makeBufferWithContents(data, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);\n    const module = t.device.createShaderModule({\n      code: `\n        struct Buffer { data: u32, };\n        @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n        @compute @workgroup_size(1) fn main() {\n          loop {\n            if (buffer.data == 1u) {\n              break;\n            }\n            buffer.data = buffer.data + 2u;\n          }\n        }\n      `,\n    });\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: { module, entryPoint: 'main' },\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n\ng.test('vertex')\n  .desc(\n    `Tests execution of render passes with a non-halting vertex stage.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const module = t.device.createShaderModule({\n      code: `\n        struct Data { counter: u32, increment: u32, };\n        @group(0) @binding(0) var<uniform> data: Data;\n        @vertex fn vmain() -> @builtin(position) vec4<f32> {\n          var counter: u32 = data.counter;\n          loop {\n            if (counter % 2u == 1u) {\n              break;\n            }\n            counter = counter + data.increment;\n          }\n          return vec4<f32>(1.0, 1.0, 0.0, f32(counter));\n        }\n        @fragment fn fmain() -> @location(0) vec4<f32> {\n          return vec4<f32>(1.0);\n        }\n      `,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const uniforms = t.makeBufferWithContents(new Uint32Array([0, 2]), GPUBufferUsage.UNIFORM);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniforms },\n        },\n      ],\n    });\n    const renderTarget = t.createTextureTracked({\n      size: [1, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n\ng.test('fragment')\n  .desc(\n    `Tests execution of render passes with a non-halting fragment stage.\n\nThis is expected to hang for a bit, but it should ultimately result in graceful\ndevice loss.`\n  )\n  .fn(async t => {\n    const module = t.device.createShaderModule({\n      code: `\n        struct Data { counter: u32, increment: u32, };\n        @group(0) @binding(0) var<uniform> data: Data;\n        @vertex fn vmain() -> @builtin(position) vec4<f32> {\n          return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n        @fragment fn fmain() -> @location(0) vec4<f32> {\n          var counter: u32 = data.counter;\n          loop {\n            if (counter % 2u == 1u) {\n              break;\n            }\n            counter = counter + data.increment;\n          }\n          return vec4<f32>(1.0 / f32(counter), 0.0, 0.0, 1.0);\n        }\n      `,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    const uniforms = t.makeBufferWithContents(new Uint32Array([0, 2]), GPUBufferUsage.UNIFORM);\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniforms },\n        },\n      ],\n    });\n    const renderTarget = t.createTextureTracked({\n      size: [1, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      format: 'rgba8unorm',\n    });\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.draw(1);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n    await t.device.lost;\n  });\n"],"mappings":"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"}